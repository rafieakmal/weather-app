(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('d3'), require('rsvp'), require('oregondsp'), require('pikaday'), require('js-quantities')) :
  typeof define === 'function' && define.amd ? define(['exports', 'moment', 'd3', 'rsvp', 'oregondsp', 'pikaday', 'js-quantities'], factory) :
  (global = global || self, factory(global.seisplotjs = {}, global.moment, global.d3, global.RSVP, global.OregonDSPTop, global.Pikaday, global.Qty));
}(this, (function (exports, moment, d3, RSVP, OregonDSPTop, Pikaday, Qty) { 'use strict';

  var moment__default = 'default' in moment ? moment['default'] : moment;
  var RSVP__default = 'default' in RSVP ? RSVP['default'] : RSVP;
  Pikaday = Pikaday && Object.prototype.hasOwnProperty.call(Pikaday, 'default') ? Pikaday['default'] : Pikaday;
  Qty = Qty && Object.prototype.hasOwnProperty.call(Qty, 'default') ? Qty['default'] : Qty;

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */

  /**
   * Inserts text as css into the head of an html document. No checking
   * as to validity of the css is done, just inserts a style
   * element at the beginning of the head.
   * 
   * @param  cssText textual css for insertion
   * @returns the style html element inserted
   */
  function insertCSS(cssText) {
    let head = document.head;

    if (head === null) {
      throw new Error("document.head is null");
    }

    let styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    styleElement.appendChild(document.createTextNode(cssText));
    head.insertBefore(styleElement, head.firstChild);
    return styleElement;
  }

  var cssutil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    insertCSS: insertCSS
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  RSVP__default.on('error', function (reason) {
    // eslint-disable-next-line no-console
    console.assert(false, reason);
  }); //reexport
  const XML_MIME = "application/xml";
  const JSON_MIME = "application/json";
  const JSONAPI_MIME = "application/vnd.api+json";
  const TEXT_MIME = "text/plain"; // flow predicate %check functions

  function hasArgs(value) {
    return arguments.length !== 0 && typeof value !== 'undefined';
  }
  function hasNoArgs(value) {
    return arguments.length === 0 || typeof value === 'undefined';
  }
  function isStringArg(value) {
    return arguments.length !== 0 && typeof value === 'string';
  }
  function isNumArg(value) {
    return typeof value === 'number';
  }
  function isNonEmptyStringArg(value) {
    return arguments.length !== 0 && isStringArg(value) && value.length !== 0;
  }
  function isObject(obj) {
    return obj !== null && typeof obj === 'object';
  }
  function isDef(v) {
    return typeof v !== 'undefined' && v !== null;
  }
  /**
   * Converts entire DataView to a string as utf-8.
   *
   * @param   dataView bytes to convert
   * @returns           the string
   */

  function dataViewToString(dataView) {
    let out = "";

    for (let i = 0; i < dataView.byteLength; i++) {
      out += String.fromCharCode(dataView.getUint8(i));
    }

    return out;
  }
  /**
   * Log a message to the console. Put here to limit lint console errors
   * for the times we really do want to use console.log. Will also append a
   * p tag to a div#debug if it exists.
   *
   * @param   msg the message to log
   */

  function log(msg) {
    // eslint-disable-next-line no-console
    if (console) {
      console.log("".concat(stringify(msg)));
    }

    d3.select("div#debug").append("p").text("".concat(stringify(msg)));
  }
  /**
   * String representation of input. This is kind of dumb but makes
   *  flow happier.
   *
   * @param value any kind of thing that can be turned into a string
   * @returns a string
   */

  function stringify(value) {
    if (typeof value === 'string') {
      return value;
    } else if (typeof value === 'number') {
      return value.toString();
    } else if (typeof value === 'boolean') {
      return value ? "true" : "false";
    } else if (typeof value === 'undefined') {
      return "undefined";
    } else if (typeof value === 'function') {
      return "function " + value.name;
    } else if (typeof value === 'object') {
      if (value) {
        if (value instanceof moment__default) {
          return value.toISOString();
        } else {
          return value.constructor.name + " " + value.toString();
        }
      } else {
        return "null";
      } // symbol not yet supported by flow
      //  } else if (typeof value === 'symbol') {
      //    return value.toString();

    } else {
      return "<unknown" + typeof value + "???>";
    }
  }
  /**
   * Calculates offset of remote server versus local time. It is assumed that the
   * argument was acquired as close in time to calling this as possible.
   *
   * @param  serverTimeUTC now as reported by remote server
   * @returns offset in seconds to now on local machine
   */

  function calcClockOffset(serverTimeUTC) {
    return moment__default.utc().diff(serverTimeUTC, 'seconds', true);
  }
  /**
   * Any two of startTime, endTime and duration can be specified, or just duration which
   * then assumes endTime is now.
   * startTime and endTime are moment objects, duration is in seconds.
   * clockOffset is the seconds that should be subtracted from the computer time
   * to get real world time, ie computerUTC - UTC
   * or moment.utc().diff(serverTimeUTC, 'seconds', true).
   * default is zero.
   */

  class StartEndDuration {
    constructor(startTime, endTime, duration = null, clockOffset = 0) {
      if (isDef(duration)) {
        if (typeof duration === "string" || duration instanceof String) {
          if (duration.charAt(0) === 'P') {
            this._duration = moment__default.duration(duration);
          } else {
            this._duration = moment__default.duration(Number.parseFloat(duration), 'seconds');
          }
        } else if (typeof duration === "number" || duration instanceof Number) {
          this._duration = moment__default.duration(duration, 'seconds');
        } else if (moment__default.isDuration(duration)) {
          this._duration = moment__default.duration(duration);
        } else {
          throw new Error("Unknown type for duration: ".concat(typeof duration, "  ").concat(JSON.stringify(duration)));
        }
      }

      if (startTime && endTime) {
        this._startTime = checkStringOrDate(startTime);
        this._endTime = checkStringOrDate(endTime);
        this._duration = moment__default.duration(this.endTime.diff(this.startTime));
      } else if (startTime && this._duration) {
        this._startTime = checkStringOrDate(startTime);
        this._endTime = moment__default.utc(this.startTime).add(this.duration);
      } else if (endTime && this._duration) {
        this._endTime = checkStringOrDate(endTime);
        this._startTime = moment__default.utc(this.endTime).subtract(this.duration);
      } else if (this._duration) {
        if (clockOffset === undefined) {
          this._clockOffset = moment__default.duration(0, 'seconds');
        } else if (clockOffset instanceof Number) {
          this._clockOffset = moment__default.duration(clockOffset, 'seconds');
        } else {
          this._clockOffset = clockOffset;
        }

        this._endTime = moment__default.utc().subtract(clockOffset);
        this._startTime = moment__default.utc(this.endTime).subtract(this.duration);
      } else {
        throw new Error("need some combination of startTime, endTime and duration");
      }
    }

    get start() {
      return this._startTime;
    }

    get startTime() {
      return this._startTime;
    }

    get end() {
      return this._endTime;
    }

    get endTime() {
      return this._endTime;
    }

    get duration() {
      return this._duration;
    }

    get clockOffset() {
      return this._clockOffset;
    }
    /**
     * Check if this time window contains the given moment. Equality to start
     * or end is considered being contained in.
     *
     * @param   other moment to check
     * @returns        true if moment is inside this time range
     */


    contains(other) {
      if (other instanceof moment__default) {
        if (this.startTime.isAfter(other) || this.endTime.isBefore(other)) {
          return false;
        }

        return true;
      } else if (other instanceof StartEndDuration) {
        return this.contains(other.startTime) && this.contains(other.endTime);
      } else {
        throw new Error("expect moment or StartEndDuration");
      }
    }

    overlaps(other) {
      if (this.startTime.isAfter(other.endTime) || this.endTime.isBefore(other.startTime)) {
        return false;
      }

      return true;
    }

    intersect(other) {
      let out = null;

      if (this.overlaps(other)) {
        let tb = this.startTime;

        if (tb.isBefore(other.startTime)) {
          tb = other.startTime;
        }

        let te = this.endTime;

        if (te.isAfter(other.endTime)) {
          te = other.endTime;
        }

        out = new StartEndDuration(tb, te);
      }

      return out;
    }

    union(other) {
      let tb = this.startTime;

      if (tb.isAfter(other.startTime)) {
        tb = other.startTime;
      }

      let te = this.endTime;

      if (te.isBefore(other.endTime)) {
        te = other.endTime;
      }

      return new StartEndDuration(tb, te);
    }

    toString() {
      return "StartEndDuration: ".concat(toIsoWoZ(this.startTime), " to ").concat(toIsoWoZ(this.endTime), " ").concat(this.duration);
    }

  }
  /**
   * converts the input value is a moment, throws Error if not
   * a string, Date or moment. Zero length string or "now" return
   * current time.
   *
   * @param d 'now', string time, Date, number of milliseconds since epoch, or moment
   * @returns moment created from argument
   */

  function checkStringOrDate(d) {
    if (moment__default.isMoment(d)) {
      return d;
    } else if (d instanceof Date) {
      return moment__default.utc(d);
    } else if (d instanceof Number || typeof d === "number") {
      return moment__default.utc(d);
    } else if (d instanceof String || typeof d === "string") {
      let lc = d.toLowerCase();

      if (d.length === 0 || lc === "now") {
        return moment__default.utc();
      } else {
        return moment__default.utc(d);
      }
    }

    throw new Error("unknown date type: " + d + " " + typeof d);
  }
  /**
   * Converts name and value into a html query parameter, with appending ampersand.
   *
   * @param   name parameter name
   * @param   val  parameter value
   * @returns      formated query parameter
   */

  function makeParam(name, val) {
    return name + "=" + encodeURIComponent(stringify(val)) + "&";
  }
  /**
   * converts to ISO8601 but removes the trailing Z as FDSN web services
   * do not allow that.
   *
   * @param  date moment to convert to string
   * @returns ISO8601 without timezone Z
   **/

  function toIsoWoZ(date) {
    let out = date.toISOString();
    return out.substring(0, out.length - 1);
  }
  /**
   * @returns the protocol, http or https for the document if possible.
   **/

  function checkProtocol() {
    let _protocol = 'http:';

    if (typeof document !== 'undefined' && document.location && "https:" === document.location.protocol) {
      _protocol = 'https:';
    }

    return _protocol;
  }
  /**
   * Create default fetch init object with the given mimeType. Sets
   * no-cache, follow redirects, cors mode, referrer as seisplotjs and mimetype as a header.
   *
   * @param   mimeType requested mime type
   * @returns           object with fetch configuration parameters
   */

  function defaultFetchInitObj(mimeType) {
    let headers = {};

    if (isStringArg(mimeType)) {
      headers.Accept = mimeType;
    }

    return {
      cache: 'no-cache',
      redirect: 'follow',
      // manual, *follow, error
      mode: "cors",
      referrer: "seisplotjs",
      headers: headers
    };
  }
  /**
   * Does a fetch, but times out if it takes too long.
   *
   * @param   url        url to retrieve
   * @param   fetchInit  fetch configuration, initialization
   * @param   timeoutSec maximum time to wait in seconds
   * @returns             promise to the result
   * @throws Error if time out or other failure
   */

  function doFetchWithTimeout(url, fetchInit, timeoutSec) {
    const controller = new AbortController();
    const signal = controller.signal;

    if (!isDef(fetchInit)) {
      fetchInit = defaultFetchInitObj();
    }

    if (!isDef(timeoutSec)) {
      timeoutSec = 30;
    }

    setTimeout(() => controller.abort(), timeoutSec * 1000);
    fetchInit.signal = signal;
    let absoluteUrl;

    if (isStringArg(url)) {
      absoluteUrl = new URL(url, document.URL);
    } else if (url instanceof URL) {
      absoluteUrl = url;
    } else {
      throw new Error("url must be string or URL, ".concat(stringify(url)));
    }

    log("attempt to fetch ".concat(stringify(absoluteUrl)));
    return fetch(absoluteUrl, fetchInit).catch(err => {
      log("fetch failed, possible CORS or PrivacyBadger or NoScript?");
      throw err;
    }).then(function (response) {
      if (response.ok) {
        return response;
      } // $FlowFixMe


      throw new Error("fetch response was not ok. ".concat(response.ok, " ").concat(response.status));
    });
  }
  /**
   * Recursively calculates the mean of a slice of an array. This helps with
   * very long seismograms to equally weight each sample point without overflowing.
   *
   * @param   dataSlice slice of a seismogram
   * @param   totalPts  number of points in the original seismogram
   * @returns            sum of slice data points divided by totalPts
   */

  function meanOfSlice(dataSlice, totalPts) {
    if (dataSlice.length < 8) {
      return dataSlice.reduce(function (acc, val) {
        return acc + val;
      }, 0) / totalPts;
    } else {
      let byTwo = Math.floor(dataSlice.length / 2);
      return meanOfSlice(dataSlice.slice(0, byTwo), totalPts) + meanOfSlice(dataSlice.slice(byTwo, dataSlice.length), totalPts);
    }
  }

  var util = /*#__PURE__*/Object.freeze({
    __proto__: null,
    moment: moment__default,
    RSVP: RSVP__default,
    XML_MIME: XML_MIME,
    JSON_MIME: JSON_MIME,
    JSONAPI_MIME: JSONAPI_MIME,
    TEXT_MIME: TEXT_MIME,
    hasArgs: hasArgs,
    hasNoArgs: hasNoArgs,
    isStringArg: isStringArg,
    isNumArg: isNumArg,
    isNonEmptyStringArg: isNonEmptyStringArg,
    isObject: isObject,
    isDef: isDef,
    dataViewToString: dataViewToString,
    log: log,
    stringify: stringify,
    calcClockOffset: calcClockOffset,
    StartEndDuration: StartEndDuration,
    checkStringOrDate: checkStringOrDate,
    makeParam: makeParam,
    toIsoWoZ: toIsoWoZ,
    checkProtocol: checkProtocol,
    defaultFetchInitObj: defaultFetchInitObj,
    doFetchWithTimeout: doFetchWithTimeout,
    meanOfSlice: meanOfSlice
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  // converted from Steim2.java in seedCodec
  // http://github.com/crotwell/seedcodec/
  // constants for compression types

  /** ascii */
  const ASCII = 0;
  /** 16 bit integer, or java short */

  const SHORT = 1;
  /** 24 bit integer */

  const INT24 = 2;
  /** 32 bit integer, or java int */

  const INTEGER = 3;
  /** ieee float */

  const FLOAT = 4;
  /** ieee double*/

  const DOUBLE = 5;
  /** Steim1 compression */

  const STEIM1 = 10;
  /** Steim2 compression */

  const STEIM2 = 11;
  /** CDSN 16 bit gain ranged */

  const CDSN = 16;
  /** (A)SRO */

  const SRO = 30;
  /** DWWSSN 16 bit */

  const DWWSSN = 32;
  class CodecException extends Error {
    constructor(message) {
      super(message);
      this.message = message;
      this.name = 'CodecException';
    }

  }
  class UnsupportedCompressionType extends Error {
    constructor(message) {
      super(message);
      this.message = message;
      this.name = 'UnsupportedCompressionType';
    }

  }
  function isFloatCompression(compressionType) {
    if (compressionType === FLOAT || compressionType === DOUBLE) {
      return true;
    }

    return false;
  }
  /**
   * A holder for compressed data independent of the file format.
   */

  class EncodedDataSegment {
    constructor(compressionType, dataView, numSamples, littleEndian) {
      this.compressionType = compressionType;
      this.dataView = dataView;
      this.numSamples = numSamples;
      this.littleEndian = littleEndian;
    }

    isFloatCompression() {
      return isFloatCompression(this.compressionType);
    }

    decode() {
      return decompress(this.compressionType, this.dataView, this.numSamples, this.littleEndian);
    }

  }
  /**
   *  Decompress the samples from the provided DataView and
   *  return an array of the decompressed values.
   *  Only 16 bit short, 32 bit int, 32 bit float and 64 bit double
   *  along with Steim1 and Steim2 are supported.
   *
   *  @param compressionType compression format as defined in SEED blockette 1000
   *  @param dataView input DataView to be decoded
   *  @param numSamples the number of samples that can be decoded from array
   *  <b>b</b>
   *  @param littleEndian if true, dataView is little-endian (intel byte order) <b>b</b>.
   *  @returns array of length <b>numSamples</b>.
   *  @throws CodecException fail to decompress.
   *  @throws UnsupportedCompressionType unsupported compression type
   */

  function decompress(compressionType, dataView, numSamples, littleEndian) {
    // in case of record with no data points, ex detection blockette, which often have compression type
    // set to 0, which messes up the decompresser even though it doesn't matter since there is no data.
    if (numSamples === 0) {
      return new Int32Array(0);
    }

    let out;
    let offset = 0;
    let i;

    switch (compressionType) {
      case SHORT:
      case DWWSSN:
        // 16 bit values
        if (dataView.byteLength < 2 * numSamples) {
          throw new CodecException("Not enough bytes for " + numSamples + " 16 bit data points, only " + dataView.byteLength + " bytes.");
        }

        out = new Int32Array(numSamples);

        for (i = 0; i < numSamples; i++) {
          out[i] = dataView.getInt16(offset, littleEndian);
          offset += 2;
        }

        break;

      case INTEGER:
        // 32 bit integers
        if (dataView.byteLength < 4 * numSamples) {
          throw new CodecException("Not enough bytes for " + numSamples + " 32 bit data points, only " + dataView.byteLength + " bytes.");
        }

        out = new Int32Array(numSamples);

        for (i = 0; i < numSamples; i++) {
          out[i] = dataView.getInt32(offset, littleEndian);
          offset += 4;
        }

        break;

      case FLOAT:
        // 32 bit floats
        if (dataView.byteLength < 4 * numSamples) {
          throw new CodecException("Not enough bytes for " + numSamples + " 32 bit data points, only " + dataView.byteLength + " bytes.");
        }

        out = new Float32Array(numSamples);

        for (i = 0; i < numSamples; i++) {
          out[i] = dataView.getFloat32(offset, littleEndian);
          offset += 4;
        }

        break;

      case DOUBLE:
        // 64 bit doubles
        if (dataView.byteLength < 8 * numSamples) {
          throw new CodecException("Not enough bytes for " + numSamples + " 64 bit data points, only " + dataView.byteLength + " bytes.");
        }

        out = new Float64Array(numSamples);

        for (i = 0; i < numSamples; i++) {
          out[i] = dataView.getFloat64(offset, littleEndian);
          offset += 8;
        }

        break;

      case STEIM1:
        // steim 1
        out = decodeSteim1(dataView, numSamples, littleEndian, 0);
        break;

      case STEIM2:
        // steim 2
        out = decodeSteim2(dataView, numSamples, littleEndian, 0);
        break;

      default:
        // unknown format????
        throw new UnsupportedCompressionType("Type " + compressionType + " is not supported at this time.");
    } // end of switch ()


    return out;
  }
  /**
   *  Decode the indicated number of samples from the provided byte array and
   *  return an integer array of the decompressed values.  Being differencing
   *  compression, there may be an offset carried over from a previous data
   *  record.  This offset value can be placed in <b>bias</b>, otherwise leave
   *  the value as 0.
   *
   *  @param dataView input DataView to be decoded
   *  @param numSamples the number of samples that can be decoded from array
   *  <b>b</b>
   *  @param littleEndian if true, dataView is little-endian (intel byte order) <b>b</b>.
   *  @param bias the first difference value will be computed from this value.
   *  If set to 0, the method will attempt to use the X(0) constant instead.
   *  @returns int array of length <b>numSamples</b>.
   *  @throws CodecException - encoded data length is not multiple of 64
   *  bytes.
   */

  function decodeSteim1(dataView, numSamples, littleEndian, bias) {
    // Decode Steim1 compression format from the provided byte array, which contains numSamples number
    // of samples.  swapBytes is set to true if the value words are to be byte swapped.  bias represents
    // a previous value which acts as a starting constant for continuing differences integration.  At the
    // very start, bias is set to 0.
    if (dataView.byteLength % 64 !== 0) {
      throw new CodecException("encoded data length is not multiple of 64 bytes (" + dataView.byteLength + ")");
    }

    let buf = new ArrayBuffer(4 * numSamples);
    let samples = new Int32Array(buf);
    let tempSamples;
    let numFrames = dataView.byteLength / 64;
    let current = 0;
    let start = 0;
    let firstData = 0;
    let lastValue = 0;
    let i, j;

    for (i = 0; i < numFrames; i++) {
      tempSamples = extractSteim1Samples(dataView, i * 64, littleEndian); // returns only differences except for frame 0

      firstData = 0; // d(0) is byte 0 by default

      if (i === 0) {
        // special case for first frame
        lastValue = bias; // assign our X(-1)
        // x0 and xn are in 1 and 2 spots

        start = tempSamples[1]; // X(0) is byte 1 for frame 0
        //  end = tempSamples[2];    // X(n) is byte 2 for frame 0

        firstData = 3; // d(0) is byte 3 for frame 0
        // if bias was zero, then we want the first sample to be X(0) constant

        if (bias === 0) lastValue = start - tempSamples[3]; // X(-1) = X(0) - d(0)
      }

      for (j = firstData; j < tempSamples.length && current < numSamples; j++) {
        samples[current] = lastValue + tempSamples[j]; // X(n) = X(n-1) + d(n)

        lastValue = samples[current];
        current++;
      }
    } // end for each frame...


    if (current !== numSamples) {
      throw new CodecException("Number of samples decompressed doesn't match number in header: " + current + " !== " + numSamples);
    } // ignore last sample check???
    //if (end !== samples[numSamples-1]) {
    //    throw new SteimException("Last sample decompressed doesn't match value x(n) value in Steim1 record: "+samples[numSamples-1]+" !== "+end);
    //}


    return samples;
  }
  /**
   * Extracts differences from the next 64 byte frame of the given compressed
   * byte array (starting at offset) and returns those differences in an int
   * array.
   * An offset of 0 means that we are at the first frame, so include the header
   * bytes in the returned int array...else, do not include the header bytes
   * in the returned array.
   *
   * @param dataView byte array of compressed data differences
   * @param offset index to begin reading compressed bytes for decoding
   * @param littleEndian reverse the endian-ness of the compressed bytes being read
   * @returns integer array of difference (and constant) values
   */

  function extractSteim1Samples(dataView, offset, littleEndian) {
    /* get nibbles */
    let nibbles = dataView.getInt32(offset, littleEndian);
    let currNibble = 0;
    let temp = []; // 4 samples * 16 longwords, can't be more than 64

    let currNum = 0;
    let i, n;

    for (i = 0; i < 16; i++) {
      // i is the word number of the frame starting at 0
      //currNibble = (nibbles >>> (30 - i*2 ) ) & 0x03; // count from top to bottom each nibble in W(0)
      currNibble = nibbles >> 30 - i * 2 & 0x03; // count from top to bottom each nibble in W(0)
      //System.err.print("c(" + i + ")" + currNibble + ",");  // DEBUG
      // Rule appears to be:
      // only check for byte-swap on actual value-atoms, so a 32-bit word in of itself
      // is not swapped, but two 16-bit short *values* are or a single
      // 32-bit int *value* is, if the flag is set to TRUE.  8-bit values
      // are naturally not swapped.
      // It would seem that the W(0) word is swap-checked, though, which is confusing...
      // maybe it has to do with the reference to high-order bits for c(0)

      switch (currNibble) {
        case 0:
          //System.out.println("0 means header info");
          // only include header info if offset is 0
          if (offset === 0) {
            temp[currNum++] = dataView.getInt32(offset + i * 4, littleEndian);
          }

          break;

        case 1:
          //System.out.println("1 means 4 one byte differences");
          for (n = 0; n < 4; n++) {
            temp[currNum] = dataView.getInt8(offset + i * 4 + n);
            currNum++;
          }

          break;

        case 2:
          //System.out.println("2 means 2 two byte differences");
          for (n = 0; n < 4; n += 2) {
            temp[currNum] = dataView.getInt16(offset + i * 4 + n, littleEndian);
            currNum++;
          }

          break;

        case 3:
          //System.out.println("3 means 1 four byte difference");
          temp[currNum++] = dataView.getInt32(offset + i * 4, littleEndian);
          break;

        default:
          throw new CodecException("unreachable case: " + currNibble);
        //System.out.println("default");
      }
    }

    return temp;
  }
  /**
   *  Decode the indicated number of samples from the provided byte array and
   *  return an integer array of the decompressed values.  Being differencing
   *  compression, there may be an offset carried over from a previous data
   *  record.  This offset value can be placed in <b>bias</b>, otherwise leave
   *  the value as 0.
   *
   *  @param dataView input byte array to be decoded
   *  @param numSamples the number of samples that can be decoded from array
   *  @param swapBytes if true, swap reverse the endian-ness of the elements of
   *  dataview
   *  @param bias the first difference value will be computed from this value.
   *  If set to 0, the method will attempt to use the X(0) constant instead.
   *  @returns int array of length <b>numSamples</b>.
   *  @throws SteimException - encoded data length is not multiple of 64
   *  bytes.
   */


  function decodeSteim2(dataView, numSamples, swapBytes, bias) {
    if (dataView.byteLength % 64 !== 0) {
      throw new CodecException("encoded data length is not multiple of 64 bytes (" + dataView.byteLength + ")");
    }

    let buf = new ArrayBuffer(4 * numSamples);
    let samples = new Int32Array(buf);
    let tempSamples;
    let numFrames = dataView.byteLength / 64;
    let current = 0;
    let start = 0;
    let firstData = 0;
    let lastValue = 0; //System.err.println("DEBUG: number of samples: " + numSamples + ", number of frames: " + numFrames + ", byte array size: " + b.length);

    for (let i = 0; i < numFrames; i++) {
      tempSamples = extractSteim2Samples(dataView, i * 64, swapBytes); // returns only differences except for frame 0

      firstData = 0; // d(0) is byte 0 by default

      if (i === 0) {
        // special case for first frame
        lastValue = bias; // assign our X(-1)
        // x0 and xn are in 1 and 2 spots

        start = tempSamples[1]; // X(0) is byte 1 for frame 0
        // end = tempSamples[2];    // X(n) is byte 2 for frame 0

        firstData = 3; // d(0) is byte 3 for frame 0
        // if bias was zero, then we want the first sample to be X(0) constant

        if (bias === 0) lastValue = start - tempSamples[3]; // X(-1) = X(0) - d(0)
      } //System.err.print("DEBUG: ");


      for (let j = firstData; j < tempSamples.length && current < numSamples; j++) {
        samples[current] = lastValue + tempSamples[j]; // X(n) = X(n-1) + d(n)

        lastValue = samples[current];
        current++;
      } //System.err.println("DEBUG: end of frame " + i);

    } // end for each frame...


    if (current !== numSamples) {
      throw new CodecException("Number of samples decompressed doesn't match number in header: " + current + " !== " + numSamples);
    } // ignore last sample check???
    //if (end !== samples[numSamples-1]) {
    //    throw new SteimException("Last sample decompressed doesn't match value x(n) value in Steim2 record: "+samples[numSamples-1]+" !== "+end);
    //}


    return samples;
  }
  /**
   * Extracts differences from the next 64 byte frame of the given compressed
   * byte array (starting at offset) and returns those differences in an int
   * array.
   * An offset of 0 means that we are at the first frame, so include the header
   * bytes in the returned int array...else, do not include the header bytes
   * in the returned array.
   *
   * @param dataView byte array of compressed data differences
   * @param offset index to begin reading compressed bytes for decoding
   * @param swapBytes reverse the endian-ness of the compressed bytes being read
   * @returns integer array of difference (and constant) values
   */

  function extractSteim2Samples(dataView, offset, swapBytes) {
    /* get nibbles */
    let nibbles = dataView.getUint32(offset, swapBytes);
    let currNibble = 0;
    let dnib = 0;
    let temp = new Int32Array(106); //max 106 = 7 samples * 15 long words + 1 nibble int

    let tempInt;
    let currNum = 0;
    let diffCount = 0; // number of differences

    let bitSize = 0; // bit size

    let headerSize = 0; // number of header/unused bits at top

    for (let i = 0; i < 16; i++) {
      currNibble = nibbles >> 30 - i * 2 & 0x03;

      switch (currNibble) {
        case 0:
          // "0 means header info"
          // only include header info if offset is 0
          if (offset === 0) {
            temp[currNum++] = dataView.getInt32(offset + i * 4, swapBytes);
          }

          break;

        case 1:
          //  "1 means 4 one byte differences " +currNum+" "+dataView.getInt8(offset+(i*4))+" "+dataView.getInt8(offset+(i*4)+1)+" "+dataView.getInt8(offset+(i*4)+2)+" "+dataView.getInt8(offset+(i*4)+3)
          temp[currNum++] = dataView.getInt8(offset + i * 4);
          temp[currNum++] = dataView.getInt8(offset + i * 4 + 1);
          temp[currNum++] = dataView.getInt8(offset + i * 4 + 2);
          temp[currNum++] = dataView.getInt8(offset + i * 4 + 3);
          break;

        case 2:
          tempInt = dataView.getUint32(offset + i * 4, swapBytes);
          dnib = tempInt >> 30 & 0x03;

          switch (dnib) {
            case 1:
              // "2,1 means 1 thirty bit difference"
              temp[currNum++] = tempInt << 2 >> 2;
              break;

            case 2:
              // "2,2 means 2 fifteen bit differences"
              temp[currNum++] = tempInt << 2 >> 17; // d0

              temp[currNum++] = tempInt << 17 >> 17; // d1

              break;

            case 3:
              //  "2,3 means 3 ten bit differences"
              temp[currNum++] = tempInt << 2 >> 22; // d0

              temp[currNum++] = tempInt << 12 >> 22; // d1

              temp[currNum++] = tempInt << 22 >> 22; // d2

              break;

            default:
              throw new CodecException("Unknown case currNibble=".concat(currNibble, " dnib=").concat(dnib));
          }

          break;

        case 3:
          tempInt = dataView.getUint32(offset + i * 4, swapBytes);
          dnib = tempInt >> 30 & 0x03; // for case 3, we are going to use a for-loop formulation that
          // accomplishes the same thing as case 2, just less verbose.

          diffCount = 0; // number of differences

          bitSize = 0; // bit size

          headerSize = 0; // number of header/unused bits at top

          switch (dnib) {
            case 0:
              //System.out.println("3,0 means 5 six bit differences");
              headerSize = 2;
              diffCount = 5;
              bitSize = 6;
              break;

            case 1:
              //System.out.println("3,1 means 6 five bit differences");
              headerSize = 2;
              diffCount = 6;
              bitSize = 5;
              break;

            case 2:
              //System.out.println("3,2 means 7 four bit differences, with 2 unused bits");
              headerSize = 4;
              diffCount = 7;
              bitSize = 4;
              break;

            default:
              throw new CodecException("Unknown case currNibble=".concat(currNibble, " dnib=").concat(dnib));
          }

          if (diffCount > 0) {
            for (let d = 0; d < diffCount; d++) {
              // for-loop formulation
              temp[currNum++] = tempInt << headerSize + d * bitSize >> (diffCount - 1) * bitSize + headerSize;
            }
          }

          break;

        default:
          throw new CodecException("Unknown case currNibble=".concat(currNibble));
      }
    }

    return temp.slice(0, currNum);
  }

  var seedcodec = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ASCII: ASCII,
    SHORT: SHORT,
    INT24: INT24,
    INTEGER: INTEGER,
    FLOAT: FLOAT,
    DOUBLE: DOUBLE,
    STEIM1: STEIM1,
    STEIM2: STEIM2,
    CDSN: CDSN,
    SRO: SRO,
    DWWSSN: DWWSSN,
    CodecException: CodecException,
    UnsupportedCompressionType: UnsupportedCompressionType,
    isFloatCompression: isFloatCompression,
    EncodedDataSegment: EncodedDataSegment,
    decompress: decompress,
    decodeSteim1: decodeSteim1,
    decodeSteim2: decodeSteim2
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const OregonDSP = OregonDSPTop.com.oregondsp.signalProcessing;
  const Complex = OregonDSP.filter.iir.Complex;
  function createComplex(real, imag) {
    return OregonDSP.filter.iir.Complex_init(real, imag);
  }

  var oregondsputil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OregonDSP: OregonDSP,
    Complex: Complex,
    createComplex: createComplex
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** xml namespace for stationxml */

  const STAML_NS = 'http://www.fdsn.org/xml/station/1'; // StationXML classes

  class Network {
    constructor(networkCode) {
      this.networkCode = networkCode;
      this.stations = [];
    }

    get startDate() {
      return this._startDate;
    }

    set startDate(value) {
      this._startDate = checkStringOrDate(value);
    }

    get endDate() {
      return this._endDate;
    }

    set endDate(value) {
      this._endDate = checkStringOrDate(value);
    }

    get timeRange() {
      return new StartEndDuration(this.startDate, this.endDate);
    }

    codes() {
      return this.networkCode;
    }

    isTempNet() {
      const first = this.networkCode.charAt(0);
      return first === 'X' || first === 'Y' || first === 'Z' || first >= '0' && first <= '9';
    }

  }
  class Station {
    /** @private */

    /** @private */
    constructor(network, stationCode) {
      this.network = network;
      this.stationCode = stationCode;
      this.channels = [];
    }

    get startDate() {
      return this._startDate;
    }

    set startDate(value) {
      this._startDate = checkStringOrDate(value);
    }

    get endDate() {
      return this._endDate;
    }

    set endDate(value) {
      this._endDate = checkStringOrDate(value);
    }

    get timeRange() {
      return new StartEndDuration(this.startDate, this.endDate);
    }

    get networkCode() {
      return this.network.networkCode;
    }

    codes() {
      return this.network.codes() + "." + this.stationCode;
    }

  }
  class Channel {
    /** @private */

    /** @private */

    /** @private */
    constructor(station, channelCode, locationCode) {
      this.station = station;

      if (channelCode.length !== 3) {
        throw new Error("Channel code must be 3 chars: ".concat(channelCode));
      }

      this.channelCode = channelCode;
      this.locationCode = locationCode;

      if (!locationCode) {
        // make sure "null" is encoded as empty string
        this.locationCode = '';
      }

      if (!(this.locationCode.length === 2 || this.locationCode.length === 0)) {
        throw new Error("locationCode must be 2 chars, or empty: \"".concat(locationCode, "\""));
      }
    }

    get startDate() {
      return this._startDate;
    }

    set startDate(value) {
      this._startDate = checkStringOrDate(value);
    }

    get endDate() {
      return this._endDate;
    }

    set endDate(value) {
      this._endDate = checkStringOrDate(value);
    }

    get timeRange() {
      return new StartEndDuration(this.startDate, this.endDate);
    }

    get locationCode() {
      return this._locationCode;
    }

    set locationCode(value) {
      this._locationCode = value;

      if (!value) {
        // make sure "null" is encoded as empty string
        this._locationCode = '';
      }
    }

    get stationCode() {
      return this.station.stationCode;
    }

    get networkCode() {
      return this.station.networkCode;
    }
    /**
     * Checks if this channel has sensitivity defined, within the response.
     *
     * @returns          true if instrumentSensitivity exits
     */


    hasInstrumentSensitivity() {
      return isDef(this.response) && isDef(this.response.instrumentSensitivity);
    }

    set instrumentSensitivity(value) {
      if (typeof this.response === 'undefined') {
        this.response = new Response(value);
      } else {
        this.response.instrumentSensitivity = value;
      }
    }

    get instrumentSensitivity() {
      if (this.response) {
        return this.response.instrumentSensitivity;
      } else {
        throw new Error("no Response or InstrumentSensitivity defined");
      }
    }

    codes() {
      return this.station.codes() + "." + this.locationCode + "." + this.channelCode;
    }

  }
  class InstrumentSensitivity {
    constructor(sensitivity, frequency, inputUnits, outputUnits) {
      this.sensitivity = sensitivity;
      this.frequency = frequency;
      this.inputUnits = inputUnits;
      this.outputUnits = outputUnits;
    }

  }
  class Response {
    constructor(instrumentSensitivity, stages) {
      if (instrumentSensitivity) {
        this.instrumentSensitivity = instrumentSensitivity;
      }

      if (stages) {
        this.stages = stages;
      }
    }

  }
  class Stage {
    constructor(filter, decimation, gain) {
      this.filter = filter;
      this.decimation = decimation;
      this.gain = gain;
    }

  }
  class AbstractFilterType {
    constructor(inputUnits, outputUnits) {
      this.inputUnits = inputUnits;
      this.outputUnits = outputUnits;
    }

  }
  class PolesZeros extends AbstractFilterType {
    constructor(inputUnits, outputUnits) {
      super(inputUnits, outputUnits);
    }

  }
  class FIR extends AbstractFilterType {
    constructor(inputUnits, outputUnits) {
      super(inputUnits, outputUnits);
    }

  }
  class CoefficientsFilter extends AbstractFilterType {
    constructor(inputUnits, outputUnits) {
      super(inputUnits, outputUnits);
    }

  }
  class Decimation {}
  class Gain {}
  /**
   * Parses the FDSN StationXML returned from a query.
   *
   * @param rawXml parsed xml to extract objects from
   * @returns an Array of Network objects.
   */

  function parseStationXml(rawXml) {
    let top = rawXml.documentElement;

    if (!top) {
      throw new Error("No documentElement in XML");
    }

    let netArray = top.getElementsByTagNameNS(STAML_NS, "Network");
    let out = [];

    for (let n of netArray) {
      out.push(convertToNetwork(n));
    }

    return out;
  }
  /** Parses a FDSNStationXML Network xml element into a Network object.
   *
   * @param xml the network xml Element
   * @returns Network instance
   */

  function convertToNetwork(xml) {
    const netCode = _grabAttribute(xml, "code");

    if (!isNonEmptyStringArg(netCode)) {
      throw new Error("network code missing in network!");
    }

    let out = new Network(netCode);
    out.startDate = _grabAttribute(xml, "startDate");

    const rs = _grabAttribute(xml, "restrictedStatus");

    if (isNonEmptyStringArg(rs)) {
      out.restrictedStatus = rs;
    }

    const desc = _grabFirstElText(xml, 'Description');

    if (isNonEmptyStringArg(desc)) {
      out.description = desc;
    }

    if (_grabAttribute(xml, "endDate")) {
      out.endDate = _grabAttribute(xml, "endDate");
    }

    let totSta = xml.getElementsByTagNameNS(STAML_NS, "TotalNumberStations");

    if (totSta && totSta.length > 0) {
      out.totalNumberStations = parseInt(_grabFirstElText(xml, "TotalNumberStations"));
    }

    let staArray = xml.getElementsByTagNameNS(STAML_NS, "Station");
    let stations = [];

    for (let s of staArray) {
      stations.push(convertToStation(out, s));
    }

    out.stations = stations;
    return out;
  }
  /**
   * Parses a FDSNStationXML Station xml element into a Station object.
   *
   * @param network the containing network
   * @param xml the station xml Element
   * @returns Station instance
   */

  function convertToStation(network, xml) {
    let staCode = _grabAttribute(xml, "code");

    if (!isNonEmptyStringArg(staCode)) {
      throw new Error("station code missing in station!");
    }

    let out = new Station(network, staCode);
    out.startDate = _grabAttribute(xml, "startDate");

    const rs = _grabAttribute(xml, "restrictedStatus");

    if (isNonEmptyStringArg(rs)) {
      out.restrictedStatus = rs;
    }

    const lat = _grabFirstElFloat(xml, 'Latitude');

    if (isNumArg(lat)) {
      out.latitude = lat;
    }

    const lon = _grabFirstElFloat(xml, 'Longitude');

    if (isNumArg(lon)) {
      out.longitude = lon;
    }

    const elev = _grabFirstElFloat(xml, 'Elevation');

    if (isNumArg(elev)) {
      out.elevation = elev;
    }

    const name = _grabFirstElText(_grabFirstEl(xml, 'Site'), 'Name');

    if (isStringArg(name)) {
      out.name = name;
    }

    const endDate = _grabAttribute(xml, "endDate");

    if (isDef(endDate)) {
      out.endDate = _grabAttribute(xml, "endDate");
    }

    let chanArray = xml.getElementsByTagNameNS(STAML_NS, "Channel");
    let channels = [];

    for (let c of chanArray) {
      channels.push(convertToChannel(out, c));
    }

    out.channels = channels;
    return out;
  }
  /**
   * Parses a FDSNStationXML Channel xml element into a Channel object.
   *
   * @param station the containing staton
   * @param xml the channel xml Element
   * @returns Channel instance
   */

  function convertToChannel(station, xml) {
    let locCode = _grabAttribute(xml, "locationCode");

    if (!isNonEmptyStringArg(locCode)) {
      locCode = '';
    }

    let chanCode = _grabAttribute(xml, "code");

    if (!isNonEmptyStringArg(chanCode)) {
      throw new Error("channel code missing in channel!");
    }

    let out = new Channel(station, chanCode, locCode);
    out.startDate = _grabAttribute(xml, "startDate");

    const rs = _grabAttribute(xml, "restrictedStatus");

    if (isNonEmptyStringArg(rs)) {
      out.restrictedStatus = rs;
    }

    const lat = _grabFirstElFloat(xml, 'Latitude');

    if (isNumArg(lat)) {
      out.latitude = lat;
    }

    const lon = _grabFirstElFloat(xml, 'Longitude');

    if (isNumArg(lon)) {
      out.longitude = lon;
    }

    const elev = _grabFirstElFloat(xml, 'Elevation');

    if (isNumArg(elev)) {
      out.elevation = elev;
    }

    const depth = _grabFirstElFloat(xml, 'Depth');

    if (isNumArg(depth)) {
      out.depth = depth;
    }

    const azimuth = _grabFirstElFloat(xml, 'Azimuth');

    if (isNumArg(azimuth)) {
      out.azimuth = azimuth;
    }

    const dip = _grabFirstElFloat(xml, 'Dip');

    if (isNumArg(dip)) {
      out.dip = dip;
    }

    const sampleRate = _grabFirstElFloat(xml, 'SampleRate');

    if (isNumArg(sampleRate)) {
      out.sampleRate = sampleRate;
    }

    if (_grabAttribute(xml, "endDate")) {
      out.endDate = _grabAttribute(xml, "endDate");
    }

    let responseXml = xml.getElementsByTagNameNS(STAML_NS, 'Response');

    if (responseXml && responseXml.length > 0) {
      const r = responseXml.item(0);

      if (r) {
        out.response = convertToResponse(r);
      }
    }

    return out;
  }
  /** Parses a FDSNStationXML Response xml element into a Response object.
   *
   * @param responseXml the response xml Element
   * @returns Response instance
   */

  function convertToResponse(responseXml) {
    let out;
    let inst = responseXml.getElementsByTagNameNS(STAML_NS, 'InstrumentSensitivity');

    if (inst && inst.item(0)) {
      const i = inst.item(0);

      if (i) {
        out = new Response(convertToInstrumentSensitivity(i));
      }
    }

    if (!out) {
      // DMC returns empty response element when they know nothing (instead
      // of just leaving it out). Return empty object in this case
      out = new Response();
    }

    let xmlStages = responseXml.getElementsByTagNameNS(STAML_NS, 'Stage');

    if (xmlStages && xmlStages.length > 0) {
      let jsStages = Array.from(xmlStages).map(function (stageXml) {
        return convertToStage(stageXml);
      });
      out.stages = jsStages;
    }

    return out;
  }
  /**
   * Parses a FDSNStationXML InstrumentSensitivity xml element into a InstrumentSensitivity object.
   *
   * @param xml the InstrumentSensitivity xml Element
   * @returns InstrumentSensitivity instance
   */

  function convertToInstrumentSensitivity(xml) {
    let sensitivity = _grabFirstElFloat(xml, 'Value');

    let frequency = _grabFirstElFloat(xml, 'Frequency');

    let inputUnits = _grabFirstElText(_grabFirstEl(xml, 'InputUnits'), 'Name');

    let outputUnits = _grabFirstElText(_grabFirstEl(xml, 'OutputUnits'), 'Name');

    if (!(isDef(sensitivity) && isDef(frequency) && isDef(inputUnits) && isDef(outputUnits))) {
      // $FlowFixMe
      throw new Error("Not all elements of Sensitivity exist: ".concat(sensitivity, " ").concat(frequency, " ").concat(inputUnits, " ").concat(outputUnits));
    }

    return new InstrumentSensitivity(sensitivity, frequency, inputUnits, outputUnits);
  }
  /**
   * Parses a FDSNStationXML Stage xml element into a Stage object.
   *
   * @param stageXml the Stage xml Element
   * @returns Stage instance
   */

  function convertToStage(stageXml) {
    let subEl = stageXml.firstElementChild;
    let filter = null;

    if (!subEl) {
      throw new Error("Stage element has no child elements");
    } else if (stageXml.childElementCount === 1 && subEl.localName === 'StageGain') ; else {
      // shoudl be a filter of some kind, check for units
      let inputUnits = _grabFirstElText(_grabFirstEl(stageXml, 'InputUnits'), 'Name');

      let outputUnits = _grabFirstElText(_grabFirstEl(stageXml, 'OutputUnits'), 'Name');

      if (!isNonEmptyStringArg(inputUnits)) {
        throw new Error("Stage inputUnits required");
      }

      if (!isNonEmptyStringArg(outputUnits)) {
        throw new Error("Stage outputUnits required");
      } // here we assume there must be a filter, and so must have units


      if (subEl.localName === 'PolesZeros') {
        filter = new PolesZeros(inputUnits, outputUnits);

        const pzt = _grabFirstElText(stageXml, 'PzTransferFunctionType');

        if (isNonEmptyStringArg(pzt)) {
          filter.pzTransferFunctionType = pzt;
        }

        const nfa = _grabFirstElFloat(stageXml, 'NormalizationFactor');

        if (isNumArg(nfa)) {
          filter.normalizationFactor = nfa;
        }

        const nfr = _grabFirstElFloat(stageXml, 'NormalizationFrequency');

        if (isNumArg(nfr)) {
          filter.normalizationFrequency = nfr;
        }

        let zeros = Array.from(stageXml.getElementsByTagNameNS(STAML_NS, 'Zero')).map(function (zeroEl) {
          return extractComplex(zeroEl);
        });
        let poles = Array.from(stageXml.getElementsByTagNameNS(STAML_NS, 'Pole')).map(function (poleEl) {
          return extractComplex(poleEl);
        });
        filter.zeros = zeros;
        filter.poles = poles;
      } else if (subEl.localName === 'Coefficients') {
        let coeffXml = subEl;
        filter = new CoefficientsFilter(inputUnits, outputUnits);

        const cft = _grabFirstElText(coeffXml, 'CfTransferFunctionType');

        if (isNonEmptyStringArg(cft)) {
          filter.cfTransferFunction = cft;
        }

        filter.numerator = Array.from(coeffXml.getElementsByTagNameNS(STAML_NS, 'Numerator')).map(function (numerEl) {
          return parseFloat(numerEl.textContent);
        });
        filter.denominator = Array.from(coeffXml.getElementsByTagNameNS(STAML_NS, 'Denominator')).map(function (denomEl) {
          return parseFloat(denomEl.textContent);
        });
      } else if (subEl.localName === 'ResponseList') {
        throw new Error("ResponseList not supported: ");
      } else if (subEl.localName === 'FIR') {
        let firXml = subEl;
        filter = new FIR(inputUnits, outputUnits);

        const s = _grabFirstElText(firXml, 'Symmetry');

        if (isNonEmptyStringArg(s)) {
          filter.symmetry = s;
        }

        filter.numerator = Array.from(firXml.getElementsByTagNameNS(STAML_NS, 'NumeratorCoefficient')).map(function (numerEl) {
          return parseFloat(numerEl.textContent);
        });
      } else if (subEl.localName === 'Polynomial') {
        throw new Error("Polynomial not supported: ");
      } else if (subEl.localName === 'StageGain') ; else {
        throw new Error("Unknown Stage type: " + subEl.localName);
      }

      if (filter) {
        // add description and name if it was there
        let description = _grabFirstElText(subEl, 'Description');

        if (isNonEmptyStringArg(description)) {
          filter.description = description;
        }

        if (subEl.hasAttribute('name')) {
          const n = _grabAttribute(subEl, 'name');

          if (isNonEmptyStringArg(n)) {
            filter.name = n;
          }
        }
      }
    }

    let decimationXml = _grabFirstEl(stageXml, 'Decimation');

    let decimation = null;

    if (decimationXml) {
      decimation = convertToDecimation(decimationXml);
    }

    let gainXml = _grabFirstEl(stageXml, 'StageGain');

    let gain = null;

    if (gainXml) {
      gain = convertToGain(gainXml);
    } else {
      throw new Error("Did not find Gain in stage number " + stringify(_grabAttribute(stageXml, "number")));
    }

    let out = new Stage(filter, decimation, gain);
    return out;
  }
  /**
   * Parses a FDSNStationXML Decimation xml element into a Decimation object.
   *
   * @param decXml the Decimation xml Element
   * @returns Decimation instance
   */

  function convertToDecimation(decXml) {
    let out = new Decimation();

    const insr = _grabFirstElFloat(decXml, 'InputSampleRate');

    if (isNumArg(insr)) {
      out.inputSampleRate = insr;
    }

    const fac = _grabFirstElInt(decXml, 'Factor');

    if (isNumArg(fac)) {
      out.factor = fac;
    }

    out.offset = _grabFirstElInt(decXml, 'Offset');
    out.delay = _grabFirstElFloat(decXml, 'Delay');
    out.correction = _grabFirstElFloat(decXml, 'Correction');
    return out;
  }
  /**
   * Parses a FDSNStationXML Gain xml element into a Gain object.
   *
   * @param gainXml the Gain xml Element
   * @returns Gain instance
   */

  function convertToGain(gainXml) {
    let out = new Gain();

    const v = _grabFirstElFloat(gainXml, 'Value');

    if (isNumArg(v)) {
      out.value = v;
    }

    const f = _grabFirstElFloat(gainXml, 'Frequency');

    if (isNumArg(f)) {
      out.frequency = f;
    }

    return out;
  }
  /**
   * Extracts a complex number from an stationxml element.
   *
   * @param   el xml element
   * @returns     Complex instance
   */

  function extractComplex(el) {
    const re = _grabFirstElFloat(el, 'Real');

    const im = _grabFirstElFloat(el, 'Imaginary');

    if (isNumArg(re) && isNumArg(im)) {
      return createComplex(re, im);
    } else {
      // $FlowFixMe
      throw new Error("Both Real and Imaginary required: ".concat(re, " ").concat(im));
    }
  }
  /**
   * Generator function to access all stations within all networks in the array.
   *
   * @param      networks array of Networks
   * @yields           generator yeiding stations
   */

  function* allStations(networks) {
    for (let n of networks) {
      for (let s of n.stations) {
        yield s;
      }
    }
  }
  /**
   * Generator function to access all channels within all stations
   * within all networks in the array.
   *
   * @param      networks array of Networks
   * @yields           generator yeiding channels
   */

  function* allChannels(networks) {
    for (let s of allStations(networks)) {
      for (let c of s.channels) {
        yield c;
      }
    }
  }
  /**
   * Extract all channels from all stations from all networks in the input array.
   *
   * @param   networks Array of networks.
   * @param   netCode network code to match
   * @param   staCode station code to match
   * @param   locCode location code to match
   * @param   chanCode channel code to match
   * @yields           Array of channels.
   */

  function* findChannels(networks, netCode, staCode, locCode, chanCode) {
    for (let n of networks.filter(n => n.networkCode === netCode)) {
      for (let s of n.stations.filter(s => s.stationCode === staCode)) {
        for (let c of s.channels.filter(c => c.locationCode === locCode && c.channelCode === chanCode)) {
          yield c;
        }
      }
    }
  } // these are similar methods as in seisplotjs.quakeml
  // duplicate here to avoid dependency and diff NS, yes that is dumb...

  const _grabFirstEl = function _grabFirstEl(xml, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let el = xml.getElementsByTagName(tagName);

      if (isObject(el) && el.length > 0) {
        const e = el.item(0);

        if (e) {
          out = e;
        }
      }
    }

    return out;
  };

  const _grabFirstElText = function _grabFirstElText(xml, tagName) {
    let out = undefined;

    let el = _grabFirstEl(xml, tagName);

    if (isObject(el)) {
      out = el.textContent;
    }

    return out;
  };

  const _grabFirstElFloat = function _grabFirstElFloat(xml, tagName) {
    let out = undefined;

    let elText = _grabFirstElText(xml, tagName);

    if (isStringArg(elText)) {
      out = parseFloat(elText);
    }

    return out;
  };

  const _grabFirstElInt = function _grabFirstElInt(xml, tagName) {
    let out = undefined;

    let elText = _grabFirstElText(xml, tagName);

    if (isStringArg(elText)) {
      out = parseInt(elText);
    }

    return out;
  };

  const _grabAttribute = function _grabAttribute(xml, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let a = xml.getAttribute(tagName);

      if (isStringArg(a)) {
        out = a;
      }
    }

    return out;
  };

  const _grabAttributeNS = function _grabAttributeNS(xml, namespace, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let a = xml.getAttributeNS(namespace, tagName);

      if (isStringArg(a)) {
        out = a;
      }
    }

    return out;
  };

  const parseUtil = {
    "_grabFirstEl": _grabFirstEl,
    "_grabFirstElText": _grabFirstElText,
    "_grabFirstElFloat": _grabFirstElFloat,
    "_grabFirstElInt": _grabFirstElInt,
    "_grabAttribute": _grabAttribute,
    "_grabAttributeNS": _grabAttributeNS
  };

  var stationxml = /*#__PURE__*/Object.freeze({
    __proto__: null,
    STAML_NS: STAML_NS,
    Network: Network,
    Station: Station,
    Channel: Channel,
    InstrumentSensitivity: InstrumentSensitivity,
    Response: Response,
    Stage: Stage,
    AbstractFilterType: AbstractFilterType,
    PolesZeros: PolesZeros,
    FIR: FIR,
    CoefficientsFilter: CoefficientsFilter,
    Decimation: Decimation,
    Gain: Gain,
    parseStationXml: parseStationXml,
    convertToNetwork: convertToNetwork,
    convertToStation: convertToStation,
    convertToChannel: convertToChannel,
    convertToResponse: convertToResponse,
    convertToInstrumentSensitivity: convertToInstrumentSensitivity,
    convertToStage: convertToStage,
    convertToDecimation: convertToDecimation,
    convertToGain: convertToGain,
    extractComplex: extractComplex,
    allStations: allStations,
    allChannels: allChannels,
    findChannels: findChannels,
    parseUtil: parseUtil
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const QML_NS = 'http://quakeml.org/xmlns/quakeml/1.2';
  const BED_NS = 'http://quakeml.org/xmlns/bed/1.2';
  const IRIS_NS = 'http://service.iris.edu/fdsnws/event/1/';
  const ANSS_NS = 'http://anss.org/xmlns/event/0.1';
  const ANSS_CATALOG_NS = "http://anss.org/xmlns/catalog/0.1";
  const USGS_HOST = "earthquake.usgs.gov";
  const UNKNOWN_MAG_TYPE = 'unknown'; // QuakeML classes

  /**
   * Represent a QuakeML Event. Renamed to Quake as Event conflicts with
   * other uses in javascript.
   */

  class Quake {
    constructor() {// what is essential???
    }
    /**
     * Parses a QuakeML event xml element into a Quake object. Pass in
     * host=seisplotjs.fdsnevent.USGS_HOST for xml from the USGS service
     * in order to parse the eventid, otherwise this can be left out
     *
     * @param qml the event xml Element
     * @param host optional source of the xml, helpful for parsing the eventid
     * @returns QuakeML Quake(Event) object
     */


    static createFromXml(qml, host) {
      if (qml.localName !== "event") {
        throw new Error("Cannot extract, not a QuakeML Event: ".concat(qml.localName));
      }

      let out = new Quake();

      let s = _grabAttribute$1(qml, 'publicID');

      if (!isNonEmptyStringArg(s)) {
        throw new Error("Quake/Event does not have publicID");
      }

      out.publicId = s;

      const desc = _grabFirstElText$1(_grabFirstEl$1(qml, 'description'), 'text');

      if (isStringArg(desc)) {
        out.description = desc;
      }

      let otimeStr = _grabFirstElText$1(_grabFirstEl$1(_grabFirstEl$1(qml, 'origin'), 'time'), 'value');

      if (isNonEmptyStringArg(otimeStr)) {
        out.time = otimeStr;
      } //need picks before can do origins


      let allPickEls = qml.getElementsByTagNameNS(BED_NS, 'pick');
      let allPicks = [];

      for (let pickEl of allPickEls) {
        allPicks.push(Pick.createFromXml(pickEl));
      }

      let allOriginEls = qml.getElementsByTagNameNS(BED_NS, "origin");
      let allOrigins = [];

      for (let originEl of allOriginEls) {
        allOrigins.push(Origin.createFromXml(originEl, allPicks));
      }

      let allMagEls = qml.getElementsByTagNameNS(BED_NS, "magnitude");
      let allMags = [];

      for (let magEl of allMagEls) {
        allMags.push(Magnitude.createFromXml(magEl));
      }

      out.originList = allOrigins;
      out.magnitudeList = allMags;
      out.pickList = allPicks;
      out.eventId = Quake.extractEventId(qml, host);
      out.preferredOriginId = _grabFirstElText$1(qml, 'preferredOriginID');
      out.preferredMagnitudeId = _grabFirstElText$1(qml, 'preferredMagnitudeID');

      if (isNonEmptyStringArg(out.preferredOriginId)) {
        for (let o of allOrigins) {
          if (o.publicId === out.preferredOriginId) {
            out.preferredOrigin = o;
            out.latitude = o.latitude;
            out.longitude = o.longitude;
            out.depth = o.depth;
            out.time = o.time;
          } else {
            log("no preferredOriginId match: ".concat(o.publicId, " ").concat(out.preferredOriginId));
          }
        }
      } else if (out.originList.length > 1) {
        const o = out.originList[0];
        out.latitude = o.latitude;
        out.longitude = o.longitude;
        out.depth = o.depth;
      }

      if (allMags.length > 0) {
        out.magnitude = allMags[0];
      }

      if (isNonEmptyStringArg(out.preferredMagnitudeId)) {
        for (let m of allMags) {
          if (m.publicId === out.preferredMagnitudeId) {
            out.preferredMagnitude = m;
            out.magnitude = m;
          } else {
            log("no match: ".concat(m.publicId, " ").concat(out.preferredMagnitudeId));
          }
        }
      }

      return out;
    }
    /**
     * Extracts the EventId from a QuakeML element, guessing from one of several
     * incompatible (grumble grumble) formats.
     *
     * @param   qml Quake(Event) to extract from
     * @param   host optional source of the xml to help determine the event id style
     * @returns     Extracted Id, or "unknownEventId" if we can't figure it out
     */


    static extractEventId(qml, host) {
      let eventId = _grabAttributeNS$1(qml, ANSS_CATALOG_NS, 'eventid');

      let catalogEventSource = _grabAttributeNS$1(qml, ANSS_CATALOG_NS, 'eventsource');

      if (isNonEmptyStringArg(eventId)) {
        if (host === USGS_HOST && isNonEmptyStringArg(catalogEventSource)) {
          // USGS, NCEDC and SCEDC use concat of eventsource and eventId as eventit, sigh...
          return catalogEventSource + eventId;
        } else {
          return eventId;
        }
      }

      let publicid = _grabAttribute$1(qml, 'publicID');

      if (isNonEmptyStringArg(publicid)) {
        let re = /eventid=([\w\d]+)/;
        let parsed = re.exec(publicid);

        if (parsed) {
          return parsed[1];
        }

        re = /evid=([\w\d]+)/;
        parsed = re.exec(publicid);

        if (parsed) {
          return parsed[1];
        }
      }

      return "unknownEventId";
    }

    get time() {
      return this._time;
    }

    set time(value) {
      this._time = moment__default.utc(value);
    }

    get arrivals() {
      return this.preferredOrigin.arrivalList;
    }

    get picks() {
      return this.pickList;
    }

    toString() {
      return stringify(this.time) + ' ' + stringify(this.latitude) + " " + stringify(this.longitude) + ' ' + stringify(this.depth) + ' ' + this.magnitude.toString();
    }

  }
  /** Represents a QuakeML Origin. */

  class Origin {
    constructor() {// what is essential???
    }
    /**
     * Parses a QuakeML origin xml element into a Origin object.
     *
     * @param qml the origin xml Element
     * @param allPicks picks already extracted from the xml for linking arrivals with picks
     * @returns Origin instance
     */


    static createFromXml(qml, allPicks) {
      if (qml.localName !== "origin") {
        throw new Error("Cannot extract, not a QuakeML Origin: ".concat(qml.localName));
      }

      let out = new Origin();

      let otimeStr = _grabFirstElText$1(_grabFirstEl$1(qml, 'time'), 'value');

      if (isNonEmptyStringArg(otimeStr)) {
        out.time = otimeStr;
      } else {
        log("origintime is missing...");
      }

      const lat = _grabFirstElFloat$1(_grabFirstEl$1(qml, 'latitude'), 'value');

      if (isNumArg(lat)) {
        out.latitude = lat;
      }

      const lon = _grabFirstElFloat$1(_grabFirstEl$1(qml, 'longitude'), 'value');

      if (isNumArg(lon)) {
        out.longitude = lon;
      }

      const depth = _grabFirstElFloat$1(_grabFirstEl$1(qml, 'depth'), 'value');

      if (isNumArg(depth)) {
        out.depth = depth;
      }

      const pid = _grabAttribute$1(qml, 'publicID');

      if (isNonEmptyStringArg(pid)) {
        out.publicId = pid;
      }

      let allArrivalEls = qml.getElementsByTagNameNS(BED_NS, 'arrival');
      let allArrivals = [];

      for (let arrivalEl of allArrivalEls) {
        allArrivals.push(Arrival.createFromXml(arrivalEl, allPicks));
      }

      out.arrivalList = allArrivals;
      return out;
    }

    toString() {
      return stringify(this.time) + ' ' + stringify(this.latitude) + " " + stringify(this.longitude) + ' ' + stringify(this.depth);
    }

    get arrivals() {
      return this.arrivalList;
    }

  }
  /** Represents a QuakeML Magnitude.
   */

  class Magnitude {
    constructor(mag, type) {
      this.mag = mag;
      this.type = type;
    }
    /**
     * Parses a QuakeML magnitude xml element into a Magnitude object.
     *
     * @param qml the magnitude xml Element
     * @returns Magnitude instance
     */


    static createFromXml(qml) {
      if (qml.localName !== "magnitude") {
        throw new Error("Cannot extract, not a QuakeML Magnitude: ".concat(qml.localName));
      }

      let mag = _grabFirstElFloat$1(_grabFirstElNS(qml, BED_NS, 'mag'), 'value');

      let type = _grabFirstElText$1(qml, 'type');

      if (isNumArg(mag)) {
        // allow type to be undef, but mag needs to be a number
        if (!isNonEmptyStringArg(type)) {
          type = UNKNOWN_MAG_TYPE;
        }

        let out = new Magnitude(mag, type);

        const pid = _grabAttribute$1(qml, 'publicID');

        if (isNonEmptyStringArg(pid)) {
          out.publicId = pid;
        }

        return out;
      } else {
        throw new Error("Did not find mag and type in Element: ".concat(stringify(mag), " ").concat(stringify(type)));
      }
    }

    toString() {
      return stringify(this.mag) + " " + stringify(this.type);
    }

  }
  /** Represents a QuakeML Arrival, a combination of a Pick with a phase name.
   */

  class Arrival {
    constructor(phase, pick) {
      this.phase = phase;
      this.pick = pick;
    }
    /**
     * Parses a QuakeML arrival xml element into a Arrival object.
     *
     * @param arrivalQML the arrival xml Element
     * @param allPicks picks already extracted from the xml for linking arrivals with picks
     * @returns Arrival instance
     */


    static createFromXml(arrivalQML, allPicks) {
      if (arrivalQML.localName !== "arrival") {
        throw new Error("Cannot extract, not a QuakeML Arrival: ".concat(arrivalQML.localName));
      }

      let pickId = _grabFirstElText$1(arrivalQML, 'pickID');

      let phase = _grabFirstElText$1(arrivalQML, 'phase');

      if (isNonEmptyStringArg(phase) && isNonEmptyStringArg(pickId)) {
        let myPick = allPicks.find(function (p) {
          return p.publicId === pickId;
        });

        if (!myPick) {
          throw new Error("Can't find pick with Id=" + pickId + " for Arrival");
        }

        let out = new Arrival(phase, myPick);

        const pid = _grabAttribute$1(arrivalQML, 'publicID');

        if (isNonEmptyStringArg(pid)) {
          out.publicId = pid;
        }

        return out;
      } else {
        throw new Error("Arrival does not have phase or pickId: " + stringify(phase) + " " + stringify(pickId));
      }
    }

  }
  /** Represents a QuakeML Pick.
   */

  class Pick {
    constructor(time, networkCode, stationCode, locationCode, channelCode) {
      this.time = checkStringOrDate(time);
      this.networkCode = networkCode;
      this.stationCode = stationCode;
      this.locationCode = locationCode;
      this.channelCode = channelCode;
    }
    /**
     * Parses a QuakeML pick xml element into a Pick object.
     *
     * @param pickQML the pick xml Element
     * @returns Pick instance
     */


    static createFromXml(pickQML) {
      if (pickQML.localName !== "pick") {
        throw new Error("Cannot extract, not a QuakeML Pick: ".concat(pickQML.localName));
      }

      let otimeStr = _grabFirstElText$1(_grabFirstEl$1(pickQML, 'time'), 'value');

      let time = checkStringOrDate(otimeStr);

      let waveformIdEl = _grabFirstEl$1(pickQML, 'waveformID');

      let netCode = _grabAttribute$1(waveformIdEl, "networkCode");

      let stationCode = _grabAttribute$1(waveformIdEl, "stationCode");

      let locationCode = _grabAttribute$1(waveformIdEl, "locationCode");

      let channelCode = _grabAttribute$1(waveformIdEl, "channelCode"); // handle empty loc code, it can be missing


      if (!isNonEmptyStringArg(locationCode)) {
        locationCode = '';
      }

      if (!isNonEmptyStringArg(netCode) || !isNonEmptyStringArg(stationCode) || !isNonEmptyStringArg(channelCode)) {
        throw new Error("missing codes: " + stringify(netCode) + "." + stringify(stationCode) + "." + stringify(locationCode) + "." + stringify(channelCode));
      }

      let out = new Pick(time, netCode, stationCode, locationCode, channelCode);

      const pid = _grabAttribute$1(pickQML, 'publicID');

      if (isNonEmptyStringArg(pid)) {
        out.publicId = pid;
      }

      return out;
    }

  }
  /**
   * Parses a QuakeML xml document into seisplotjs objects
   *
   *  @param rawXml the xml Document to parse
   *  @param host optional source of the xml, helpful for parsing the eventid
   *  @returns array of Quake objects
   */

  function parseQuakeML(rawXml, host) {
    let top = rawXml.documentElement;

    if (!top) {
      throw new Error("Can't get documentElement");
    }

    let eventArray = top.getElementsByTagName("event");
    let out = [];

    for (let eventEl of eventArray) {
      out.push(Quake.createFromXml(eventEl, host));
    }

    return out;
  } // these are similar methods as in seisplotjs.stationxml
  // duplicate here to avoid dependency and diff NS, yes that is dumb...

  const _grabFirstElNS = function _grabFirstElNS(xml, namespace, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let elList = xml.getElementsByTagNameNS(namespace, tagName);

      if (isObject(elList) && elList.length > 0) {
        const e = elList.item(0);

        if (e) {
          out = e;
        }
      }
    }

    return out;
  };

  const _grabFirstEl$1 = function _grabFirstEl(xml, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let elList = xml.getElementsByTagName(tagName);

      if (isObject(elList) && elList.length > 0) {
        const e = elList.item(0);

        if (e) {
          out = e;
        }
      }
    }

    return out;
  };

  const _grabFirstElText$1 = function _grabFirstElText(xml, tagName) {
    let out = undefined;

    let el = _grabFirstEl$1(xml, tagName);

    if (isObject(el)) {
      out = el.textContent;
    }

    return out;
  };

  const _grabFirstElInt$1 = function _grabFirstElInt(xml, tagName) {
    let out = undefined;

    let el = _grabFirstElText$1(xml, tagName);

    if (isStringArg(el)) {
      out = parseInt(el);
    }

    return out;
  };

  const _grabFirstElFloat$1 = function _grabFirstElFloat(xml, tagName) {
    let out = undefined;

    let el = _grabFirstElText$1(xml, tagName);

    if (isStringArg(el)) {
      out = parseFloat(el);
    }

    return out;
  };

  const _grabAttribute$1 = function _grabAttribute(xml, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let a = xml.getAttribute(tagName);

      if (isStringArg(a)) {
        out = a;
      }
    }

    return out;
  };

  const _grabAttributeNS$1 = function _grabAttributeNS(xml, namespace, tagName) {
    let out = undefined;

    if (isObject(xml)) {
      let a = xml.getAttributeNS(namespace, tagName);

      if (isStringArg(a)) {
        out = a;
      }
    }

    return out;
  };

  const parseUtil$1 = {
    "_grabFirstEl": _grabFirstEl$1,
    "_grabFirstElNS": _grabFirstElNS,
    "_grabFirstElText": _grabFirstElText$1,
    "_grabFirstElFloat": _grabFirstElFloat$1,
    "_grabFirstElInt": _grabFirstElInt$1,
    "_grabAttribute": _grabAttribute$1,
    "_grabAttributeNS": _grabAttributeNS$1
  };

  var quakeml = /*#__PURE__*/Object.freeze({
    __proto__: null,
    QML_NS: QML_NS,
    BED_NS: BED_NS,
    IRIS_NS: IRIS_NS,
    ANSS_NS: ANSS_NS,
    ANSS_CATALOG_NS: ANSS_CATALOG_NS,
    USGS_HOST: USGS_HOST,
    UNKNOWN_MAG_TYPE: UNKNOWN_MAG_TYPE,
    Quake: Quake,
    Origin: Origin,
    Magnitude: Magnitude,
    Arrival: Arrival,
    Pick: Pick,
    parseQuakeML: parseQuakeML,
    parseUtil: parseUtil$1
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const COUNT_UNIT = 'count';

  /**
   * A contiguous segment of a Seismogram.
   *
   * @param  yArray array of Y sample values, ie the timeseries
   * @param  sampleRate sample rate of the seismogram, hertz
   * @param  startTime start time of seismogrm as a momentjs moment in utc or a string that can be parsed
   */
  class SeismogramSegment {
    /** Array of y values */

    /**
     * the sample rate in hertz
     *
     * @private
     */

    /** @private */
    constructor(yArray, sampleRate, startTime) {
      if (yArray instanceof Int32Array || yArray instanceof Float32Array || yArray instanceof Float64Array) {
        this._y = yArray;
        this._compressed = null;
      } else if (Array.isArray(yArray) && yArray.every(ee => ee instanceof EncodedDataSegment)) {
        this._compressed = yArray;
        this._y = null;
      } else if (Array.isArray(yArray) && yArray.every(ee => typeof ee === 'number')) {
        // numbers in js are 64bit, so...
        this._y = Float64Array.from(yArray);
        this._compressed = null;
      }

      this._sampleRate = sampleRate;
      this._startTime = checkStringOrDate(startTime);
      this.yUnit = COUNT_UNIT; // to avoid recalc of end time as it is kind of expensive

      this._endTime_cache = null;
      this._endTime_cache_numPoints = 0;
    }
    /**
     * Y data of the seismogram. Decompresses data if needed.
     *
     * @returns y data as typed array
     */


    get y() {
      let out;

      if (this._y) {
        out = this._y;
      } else {
        if (!this.isEncoded()) {
          throw new Error("Seismogram not y as TypedArray or encoded.");
        } // data is still compressed


        let outLen = this.numPoints;

        if (this._compressed === null) {
          // for flow
          throw new Error("Seismogram not y as TypedArray or encoded.");
        }

        if (this._compressed[0].compressionType === DOUBLE) {
          out = new Float64Array(outLen);
        } else if (this._compressed[0].compressionType === FLOAT) {
          out = new Float32Array(outLen);
        } else {
          out = new Int32Array(outLen);
        }

        let currIdx = 0;

        for (let c of this._compressed) {
          const cData = c.decode();

          for (let i = 0; i < c.numSamples; i++) {
            out[currIdx + i] = cData[i];
          }

          currIdx += c.numSamples;
        }

        this._y = out;
        this._compressed = null;
      }

      return out;
    }

    set y(value) {
      this._y = value;

      this._invalidate_endTime_cache();
    }

    get startTime() {
      return this._startTime;
    }

    set startTime(value) {
      this._startTime = checkStringOrDate(value);

      this._invalidate_endTime_cache();
    }

    get endTime() {
      if (!this._endTime_cache || this._endTime_cache_numPoints !== this.numPoints) {
        // array length modified, recalc cached end time
        this._endTime_cache_numPoints = this.numPoints;
        this._endTime_cache = this.timeOfSample(this._endTime_cache_numPoints - 1);
      }

      return this._endTime_cache;
    }

    get timeWindow() {
      return new StartEndDuration(this.startTime, this.endTime);
    }

    get sampleRate() {
      return this._sampleRate;
    }

    set sampleRate(value) {
      this._sampleRate = value;

      this._invalidate_endTime_cache();
    }

    get numPoints() {
      let out = 0;

      if (this._y) {
        out = this._y.length;
      } else if (this._compressed) {
        for (let c of this._compressed) {
          out += c.numSamples;
        }
      }

      return out;
    }

    get netCode() {
      return this.networkCode;
    }

    get staCode() {
      return this.stationCode;
    }

    get locId() {
      return this.locationCode;
    }

    get locCode() {
      return this.locationCode;
    }

    get chanCode() {
      return this.channelCode;
    }
    /**
     * Checks if the data is encoded
     *
     * @returns true if encoded, false otherwise
     */


    isEncoded() {
      if (this._y && this._y.length > 0) {
        return false;
      } else if (this._compressed && this._compressed.length > 0) {
        return true;
      } else {
        return false;
      }
    }
    /**
     * Gets encoded data, if it is.
     *
     * @returns array of encoded data segments
     * @throws Error if data is not encoded
     */


    getEncoded() {
      if (this.isEncoded()) {
        return this._compressed;
      } else {
        throw new Error("Data is not encoded.");
      }
    }

    yAtIndex(i) {
      return this.y[i];
    }
    /**
     * Finds the min and max values of a SeismogramSegment, with an optional
     * accumulator for use with gappy data.
     *
     * @param minMaxAccumulator optional initialized accumulator as an array
     * of two numbers, min and max
     * @returns min, max as arry of length two
     */


    findMinMax(minMaxAccumulator) {
      let minAmp = Number.MAX_SAFE_INTEGER;
      let maxAmp = -1 * minAmp;

      if (minMaxAccumulator) {
        minAmp = minMaxAccumulator[0];
        maxAmp = minMaxAccumulator[1];
      }

      let yData = this.y;

      for (let n = 0; n < yData.length; n++) {
        if (minAmp > yData[n]) {
          minAmp = yData[n];
        }

        if (maxAmp < yData[n]) {
          maxAmp = yData[n];
        }
      }

      return [minAmp, maxAmp];
    }

    timeOfSample(i) {
      return moment__default.utc(this.startTime).add(i / this.sampleRate, 'seconds');
    }

    indexOfTime(t) {
      if (t.isBefore(this.startTime) || t.isAfter(moment__default.utc(this.endTime).add(1 / this.sampleRate, 'seconds'))) {
        return -1;
      }

      return Math.round(t.diff(this.startTime) * this.sampleRate / 1000);
    }

    hasCodes() {
      return isDef(this.networkCode) || isDef(this.stationCode) || isDef(this.locationCode) || isDef(this.channelCode);
    }
    /**
     * return network, station, location and channels codes as one string
     *
     * @param sep separator, defaults to '.'
     * @returns nslc codes separated by sep
     */


    codes(sep = '.') {
      return (this.networkCode ? this.networkCode : '') + sep + (this.stationCode ? this.stationCode : '') + sep + (this.locationCode ? this.locationCode : '') + sep + (this.channelCode ? this.channelCode : '');
    }

    seisId() {
      return (this.codes() + "_" + this.startTime.toISOString() + "_" + this.endTime.toISOString()).replace(/\./g, '_').replace(/:/g, '');
    }

    clone() {
      let clonedData = this._y;

      if (clonedData !== null) {
        clonedData = clonedData.slice();
      } else if (this.isEncoded()) {
        // shallow copy array, assume Encoded is immutable
        clonedData = Array.from(this.getEncoded());
      } else {
        throw new Error("no _y and no _compressed");
      }

      return this.cloneWithNewData(clonedData);
    }

    cloneWithNewData(clonedData, clonedStartTime = this._startTime) {
      let out = new SeismogramSegment(clonedData, this.sampleRate, moment__default.utc(clonedStartTime));
      out.networkCode = this.networkCode;
      out.stationCode = this.stationCode;
      out.locationCode = this.locationCode;
      out.channelCode = this.channelCode;
      out.yUnit = this.yUnit;
      return out;
    }

    cut(timeWindow) {
      if (timeWindow.endTime.isBefore(this._startTime) || timeWindow.startTime.isAfter(this.endTime)) {
        return null;
      }

      let sIndex = 0;

      if (timeWindow.startTime.isAfter(this._startTime)) {
        let milliDiff = timeWindow.startTime.diff(this._startTime);
        let offset = milliDiff * this.sampleRate / 1000.0;
        sIndex = Math.floor(offset);
      }

      let eIndex = this.y.length;

      if (timeWindow.endTime.isBefore(this.endTime)) {
        let milliDiff = moment__default.utc(this.endTime).diff(timeWindow.endTime);
        let offset = milliDiff * this.sampleRate / 1000.0;
        eIndex = this.y.length - Math.floor(offset);
      }

      let cutY = this.y.slice(sIndex, eIndex);
      let out = this.cloneWithNewData(cutY, moment__default.utc(this._startTime).add(sIndex / this.sampleRate, 'seconds'));
      return out;
    }

    _invalidate_endTime_cache() {
      this._endTime_cache = null;
      this._endTime_cache_numPoints = 0;
    }

  }
  /** Represents time window for a single channel that may
   * contain gaps or overlaps, but is otherwise more or less
   * continuous, or at least adjacent data from the channel.
   * Each segment within
   * the Seismogram will have the same units, channel identifiers
   * and sample rate, but cover different times.
   */

  class Seismogram {
    constructor(segmentArray) {
      this._y = null;

      if (Array.isArray(segmentArray) && segmentArray[0] instanceof SeismogramSegment) {
        this._segmentArray = segmentArray;
      } else if (segmentArray instanceof SeismogramSegment) {
        this._segmentArray = [segmentArray];
      } else {
        throw new Error("segmentArray is not Array<SeismogramSegment> or SeismogramSegment: ".concat(stringify(segmentArray)));
      }

      this.checkAllSimilar();
      this.findStartEnd();
    }

    checkAllSimilar() {
      if (this._segmentArray.length === 0) {
        throw new Error("Seismogram is empty");
      }

      let f = this._segmentArray[0];

      this._segmentArray.forEach((s, i) => {
        if (!s) {
          throw new Error("index ".concat(i, " is null in trace"));
        }

        this.checkSimilar(f, s);
      });
    }

    checkSimilar(f, s) {
      if (s.networkCode !== f.networkCode) {
        throw new Error("NetworkCode not same: " + s.networkCode + " !== " + f.networkCode);
      }

      if (s.stationCode !== f.stationCode) {
        throw new Error("StationCode not same: " + s.stationCode + " !== " + f.stationCode);
      }

      if (s.locationCode !== f.locationCode) {
        throw new Error("LocationCode not same: " + s.locationCode + " !== " + f.locationCode);
      }

      if (s.channelCode !== f.channelCode) {
        throw new Error("ChannelCode not same: " + s.channelCode + " !== " + f.channelCode);
      }

      if (s.yUnit !== f.yUnit) {
        throw new Error("yUnit not same: " + s.yUnit + " !== " + f.yUnit);
      }
    }

    findStartEnd() {
      let allStart = this._segmentArray.map(seis => {
        return moment__default.utc(seis.startTime);
      });

      this._startTime = moment__default.min(allStart);

      let allEnd = this._segmentArray.map(seis => {
        return moment__default.utc(seis.endTime);
      });

      this._endTime = moment__default.max(allEnd);
    }

    findMinMax(minMaxAccumulator) {
      if (this._segmentArray.length === 0) {
        throw new Error("No data");
      }

      for (let s of this._segmentArray) {
        minMaxAccumulator = s.findMinMax(minMaxAccumulator);
      }

      if (minMaxAccumulator) {
        return minMaxAccumulator;
      } else {
        // should never happen, for flow
        throw new Error("No data to calc minmax");
      }
    }
    /**
     * calculates the mean of a seismogrma.
     *
     * @returns       mean value
     */


    mean() {
      let meanVal = 0;
      let npts = this.numPoints;

      for (let s of this.segments) {
        meanVal += meanOfSlice(s.y, s.y.length) * s.numPoints;
      }

      meanVal = meanVal / npts;
      return meanVal;
    }

    get startTime() {
      return this._startTime;
    }

    get endTime() {
      return this._endTime;
    }

    get timeRange() {
      return new StartEndDuration(this.startTime, this.endTime);
    }

    get networkCode() {
      return this._segmentArray[0].networkCode;
    }

    set networkCode(value) {
      this._segmentArray.forEach(s => s.networkCode = value);
    }

    get stationCode() {
      return this._segmentArray[0].stationCode;
    }

    set stationCode(value) {
      this._segmentArray.forEach(s => s.stationCode = value);
    }

    get locationCode() {
      return this._segmentArray[0].locationCode;
    }

    set locationCode(value) {
      this._segmentArray.forEach(s => s.locationCode = value);
    }

    get channelCode() {
      return this._segmentArray[0].channelCode;
    }

    set channelCode(value) {
      this._segmentArray.forEach(s => s.channelCode = value);
    }

    get sampleRate() {
      return this._segmentArray[0].sampleRate;
    }

    get yUnit() {
      return this._segmentArray[0].yUnit;
    }

    get numPoints() {
      return this._segmentArray.reduce((accumulator, seis) => accumulator + seis.numPoints, 0);
    }

    hasCodes() {
      return this._segmentArray[0].hasCodes();
    }

    codes() {
      return this._segmentArray[0].codes();
    }

    get segments() {
      return this._segmentArray;
    }

    append(seismogram) {
      if (seismogram instanceof Seismogram) {
        seismogram._segmentArray.forEach(s => this.append(s));
      } else {
        this.checkSimilar(this._segmentArray[0], seismogram);
        this._startTime = moment__default.min([this.startTime, moment__default.utc(seismogram.startTime)]);
        this._endTime = moment__default.max([this.endTime, moment__default.utc(seismogram.endTime)]);

        this._segmentArray.push(seismogram);
      }
    }
    /**
     * Cut the seismogram. Creates a new seismogram with all datapoints
     * contained in the time window.
     *
     * @param  timeWindow start and end of cut
     * @returns            new seismogram
     */


    cut(timeWindow) {
      // coarse trim first
      let out = this.trim(timeWindow);

      if (out && out._segmentArray) {
        let cutSeisArray = this._segmentArray.map(seg => seg.cut(timeWindow)).filter(Boolean);

        if (cutSeisArray.length > 0) {
          out = new Seismogram(cutSeisArray);
        } else {
          out = null;
        }
      } else {
        out = null;
      }

      return out;
    }
    /**
     * Creates a new Seismogram composed of all seismogram segments that overlap the
     * given time window. If none do, this returns null. This is a faster but coarser
     * version of cut as it only removes whole segments that do not overlap the
     * time window. For most seismograms that consist of a single contiguous
     * data segment, this will do nothing.
     *
     * @param timeWindow time range to trim to
     * @returns seismogram if data in the window, null otherwise
     * @see cut
     */


    trim(timeWindow) {
      let out = null;

      if (this._segmentArray) {
        let trimSeisArray = this._segmentArray.filter(function (d) {
          return d.endTime.isSameOrAfter(timeWindow.startTime);
        }).filter(function (d) {
          return d.startTime.isSameOrBefore(timeWindow.endTime);
        });

        if (trimSeisArray.length > 0) {
          out = new Seismogram(trimSeisArray);
        }
      }

      return out;
    }

    break(duration) {
      if (this._segmentArray) {
        let breakStart = moment__default.utc(this.startTime);
        let out = [];

        while (breakStart.isBefore(this.endTime)) {
          let breakWindow = new StartEndDuration(breakStart, null, duration);

          let cutSeisArray = this._segmentArray.map(seg => seg.cut(breakWindow));

          out = out.concat(cutSeisArray);
          breakStart.add(duration);
        } // check for null, filter true if seg not null


        out = out.filter(Boolean);
        this._segmentArray = out;
      }

      return this;
    }

    isContiguous() {
      if (this._segmentArray.length === 1) {
        return true;
      }

      let prev = null;

      for (const s of this._segmentArray) {
        if (prev && !(prev.endTime.isBefore(s.startTime) && prev.endTime.add(1000 * 1.5 / prev.sampleRate, 'ms').isAfter(s.startTime))) {
          return false;
        }

        prev = s;
      }

      return true;
    }

    merge() {
      let outArray;

      if (this._segmentArray[0].y instanceof Int32Array) {
        outArray = new Int32Array(this.numPoints);
      } else if (this._segmentArray[0].y instanceof Float32Array) {
        outArray = new Float32Array(this.numPoints);
      } else if (this._segmentArray[0].y instanceof Float64Array) {
        outArray = new Float64Array(this.numPoints);
      } else {
        throw new Error("data not one of Int32Array, Float32Array or Float64Array: ".concat(this._segmentArray[0].y.constructor.name));
      }

      let i = 0;

      this._segmentArray.forEach(seg => {
        for (let v of seg.y) {
          outArray[i] = v;
          i++;
        }
      });

      return outArray;
    }
    /**
     * Gets the timeseries as an typed array if it is contiguous.
     *
     * @throws {NonContiguousData} if data is not contiguous.
     * @returns  timeseries as array of number
     */


    get y() {
      if (!this._y) {
        if (this.isContiguous()) {
          this._y = this.merge();
        }
      }

      if (this._y) {
        return this._y;
      } else {
        throw new Error("Seismogram is not contiguous, acces each SeismogramSegment idividually.");
      }
    }

    set y(val) {
      // ToDo
      throw new Error("seismogram y setter not impl, see cloneWithNewData()");
    }

    clone() {
      let cloned = this._segmentArray.map(s => s.clone());

      return new Seismogram(cloned);
    }

    cloneWithNewData(newY) {
      if (newY && newY.length > 0) {
        let seg = this._segmentArray[0].cloneWithNewData(newY);

        return new Seismogram([seg]);
      } else {
        throw new Error("Y value is empty");
      }
    }
    /**
     * factory method to create a single segment Seismogram from either encoded data
     *  or a TypedArray, along with sample rate and start time.
     *
     * @param yArray array of encoded data or typed array
     * @param sampleRate sample rate, samples per second of the data
     * @param startTime time of first sample
     * @returns seismogram initialized with the data
     */


    static createFromContiguousData(yArray, sampleRate, startTime) {
      const seg = new SeismogramSegment(yArray, sampleRate, startTime);
      return new Seismogram([seg]);
    }

  }
  class NonContiguousData extends Error {
    constructor(message) {
      super(message);
      this.name = this.constructor.name;
    }

  }
  function ensureIsSeismogram(seisSeismogram) {
    if (typeof seisSeismogram === "object") {
      if (seisSeismogram instanceof Seismogram) {
        return seisSeismogram;
      } else if (seisSeismogram instanceof SeismogramSegment) {
        return new Seismogram([seisSeismogram]);
      } else {
        let s = typeof seisSeismogram;

        if (seisSeismogram.prototype && seisSeismogram.prototype.constructor) {
          s += " " + seisSeismogram.prototype.constructor.name;
        } else {
          s += " " + seisSeismogram;
        }

        throw new Error("must be Seismogram or SeismogramSegment but " + s);
      }
    } else {
      throw new Error("must be Seismogram or SeismogramSegment but not an object");
    }
  }
  class SeismogramDisplayData {
    /** @private */
    constructor(timeWindow) {
      if (!timeWindow) {
        throw new Error("StartEndDuration must not be missing.");
      }

      this._id = null;
      this._seismogram = null;
      this.label = null;
      this.markerList = [];
      this.channel = null;
      this._instrumentSensitivity = null;
      this.quakeList = [];
      this.timeWindow = timeWindow;
      this.alignmentTime = null;
      this.doShow = true;
      this._statsCache = null;
    }

    static fromSeismogram(seismogram) {
      const out = new SeismogramDisplayData(new StartEndDuration(seismogram.startTime, seismogram.endTime, null, null));
      out.seismogram = seismogram;
      return out;
    }

    static fromChannelAndTimeWindow(channel, timeWindow) {
      const out = new SeismogramDisplayData(timeWindow);
      out.channel = channel;
      return out;
    }

    static fromChannelAndTimes(channel, startTime, endTime) {
      const out = new SeismogramDisplayData(new StartEndDuration(startTime, endTime));
      out.channel = channel;
      return out;
    }

    addQuake(quake) {
      if (Array.isArray(quake)) {
        quake.forEach(q => this.quakeList.push(q));
      } else {
        this.quakeList.push(quake);
      }
    }

    addMarkers(markers) {
      if (Array.isArray(markers)) {
        markers.forEach(m => this.markerList.push(m));
      } else {
        this.markerList.push(markers);
      }
    }

    hasQuake() {
      return this.quakeList.length > 0;
    }

    hasSeismogram() {
      return isDef(this._seismogram);
    }

    hasChannel() {
      return this.channel !== null;
    }

    hasSensitivity() {
      return this._instrumentSensitivity !== null || isDef(this.channel) && this.channel.hasInstrumentSensitivity();
    }
    /**
     * Allows id-ing a seismogram. Optional.
     *
     * @returns         string id
     */


    get id() {
      return this._id;
    }
    /**
     * Allows iding a seismogram. Optional.
     *
     * @param   value string id
     */


    set id(value) {
      this._id = value;
    }
    /**
     * return network code as a string.
     * Uses this.channel if it exists, this.seismogram if not.
     *
     * @returns network code
     */


    get networkCode() {
      if (this.channel !== null) {
        return this.channel.networkCode;
      } else if (isDef(this._seismogram)) {
        return this._seismogram.networkCode;
      } else {
        return "unknown";
      }
    }
    /**
     * return station code as a string.
     * Uses this.channel if it exists, this.seismogram if not.
     *
     * @returns station code
     */


    get stationCode() {
      if (this.channel !== null) {
        return this.channel.stationCode;
      } else if (isDef(this._seismogram)) {
        return this._seismogram.stationCode;
      } else {
        return "unknown";
      }
    }
    /**
     * return location code a a string.
     * Uses this.channel if it exists, this.seismogram if not.
     *
     * @returns location code
     */


    get locationCode() {
      if (this.channel !== null) {
        return this.channel.locationCode;
      } else if (isDef(this._seismogram)) {
        return this._seismogram.locationCode;
      } else {
        return "unknown";
      }
    }
    /**
     * return channels code as a string.
     * Uses this.channel if it exists, this.seismogram if not.
     *
     * @returns channel code
     */


    get channelCode() {
      if (this.channel !== null) {
        return this.channel.channelCode;
      } else if (isDef(this._seismogram)) {
        return this._seismogram.channelCode;
      } else {
        return "unknown";
      }
    }
    /**
     * return network, station, location and channels codes as one string.
     * Uses this.channel if it exists, this.seismogram if not.
     *
     * @param sep separator, defaults to '.'
     * @returns nslc codes separated by sep
     */


    codes(sep = '.') {
      if (this.channel !== null) {
        return this.channel.codes();
      } else {
        return (this.networkCode ? this.networkCode : '') + sep + (this.stationCode ? this.stationCode : '') + sep + (this.locationCode ? this.locationCode : '') + sep + (this.channelCode ? this.channelCode : '');
      }
    }

    get startTime() {
      return this.timeWindow.startTime;
    }

    get endTime() {
      return this.timeWindow.endTime;
    }

    get sensitivity() {
      const channel = this.channel;

      if (this._instrumentSensitivity) {
        return this._instrumentSensitivity;
      } else if (isDef(channel) && channel.hasInstrumentSensitivity()) {
        return channel.instrumentSensitivity;
      } else {
        return null;
      }
    }

    set sensitivity(value) {
      this._instrumentSensitivity = value;
    }

    get min() {
      if (!this._statsCache) {
        this._statsCache = this.calcStats();
      }

      return this._statsCache.min;
    }

    get max() {
      if (!this._statsCache) {
        this._statsCache = this.calcStats();
      }

      return this._statsCache.max;
    }

    get mean() {
      if (!this._statsCache) {
        this._statsCache = this.calcStats();
      }

      return this._statsCache.mean;
    }

    get seismogram() {
      return this._seismogram;
    }

    set seismogram(value) {
      this._seismogram = value;
      this._statsCache = null;
    }

    calcStats() {
      let stats = new SeismogramDisplayStats();

      if (this.seismogram) {
        let minMax = this.seismogram.findMinMax();
        stats.min = minMax[0];
        stats.max = minMax[1]; // $FlowFixMe  know seismogram is not null

        stats.mean = this.seismogram.mean();
      }

      this._statsCache = stats;
      return stats;
    }

    clone() {
      return this.cloneWithNewSeismogram(this.seismogram ? this.seismogram.clone() : null);
    }

    cloneWithNewSeismogram(seis) {
      let out = new SeismogramDisplayData(this.timeWindow);
      Object.getOwnPropertyNames(this).forEach(name => {
        if (name === '_seismogram') {
          out._seismogram = seis; // $FlowFixMe
        } else if (this[name] instanceof moment__default) {
          // $FlowFixMe
          out[name] = moment__default.utc(this[name]); // $FlowFixMe
        } else if (Array.isArray(this[name])) {
          // $FlowFixMe
          out[name] = this[name].slice();
        } else {
          // $FlowFixMe
          out[name] = this[name];
        }
      });
      out.seismogram = seis;
      out._statsCache = null;
      return out;
    }
    /**
     * Cut the seismogram. Creates a new seismogramDisplayData with the cut
     * seismogram and the timeWindow set to the new time window.
     *
     * @param  timeWindow start and end of cut
     * @returns           new seismogramDisplayData
     */


    cut(timeWindow) {
      let cutSeis = this.seismogram;
      let out;

      if (cutSeis) {
        cutSeis = cutSeis.cut(timeWindow);
        out = this.cloneWithNewSeismogram(cutSeis);
      } else {
        // no seismogram, so just clone?
        out = this.clone();
      }

      out.timeWindow = timeWindow;
      return out;
    }

  }
  class SeismogramDisplayStats {
    constructor() {
      this.min = 0;
      this.max = 0;
      this.mean = 0;
      this.trendSlope = 0;
    }

  }
  function findStartEnd(sddList) {
    let allStart = sddList.map(sdd => {
      return moment__default.utc(sdd.timeWindow.startTime);
    });
    let startTime = moment__default.min(allStart);
    let allEnd = sddList.map(sdd => {
      return moment__default.utc(sdd.timeWindow.endTime);
    });
    let endTime = moment__default.max(allEnd);
    return new StartEndDuration(startTime, endTime);
  }
  function findMinMax(sddList) {
    let min = sddList.map(sdd => {
      return sdd.min;
    }).reduce(function (p, v) {
      return p < v ? p : v;
    });
    let max = sddList.map(sdd => {
      return sdd.max;
    }).reduce(function (p, v) {
      return p > v ? p : v;
    });
    return [min, max];
  }
  const initial_minAmp = Number.MAX_SAFE_INTEGER;
  const initial_maxAmp = -1 * initial_minAmp;
  function findMinMaxOverTimeRange(sddList, timeWindow) {
    let minMaxArr = sddList.map(sdd => {
      if (sdd.seismogram) {
        const cutSeis = sdd.seismogram.cut(timeWindow);

        if (cutSeis) {
          return cutSeis.findMinMax();
        }
      }

      return [initial_minAmp, initial_maxAmp];
    });
    let min = minMaxArr.map(mm => {
      return mm[0];
    }).reduce(function (p, v) {
      return p < v ? p : v;
    });
    let max = minMaxArr.map(mm => {
      return mm[1];
    }).reduce(function (p, v) {
      return p > v ? p : v;
    });
    return [min, max];
  }
  function findStartEndOfSeismograms(data, accumulator) {
    let out;

    if (!accumulator && !data) {
      throw new Error("data and accumulator are not defined");
    } else if (!accumulator) {
      out = new StartEndDuration(moment__default.utc('2500-01-01'), moment__default.utc('1001-01-01'));
    } else {
      out = accumulator;
    }

    if (Array.isArray(data)) {
      for (let s of data) {
        if (s.startTime < out.startTime) {
          out = new StartEndDuration(moment__default.utc(s.startTime), out.endTime);
        }

        if (out.endTime < s.endTime) {
          out = new StartEndDuration(out.startTime, moment__default.utc(s.endTime));
        }
      }
    } else {
      throw new Error("Expected Array as first arg but was: ".concat(typeof data));
    }

    return out;
  }
  function findMinMaxOfSeismograms(data, minMaxAccumulator) {
    for (let s of data) {
      minMaxAccumulator = s.findMinMax(minMaxAccumulator);
    }

    if (minMaxAccumulator) {
      return minMaxAccumulator;
    } else {
      return [-1, 1];
    }
  }

  var seismogram = /*#__PURE__*/Object.freeze({
    __proto__: null,
    COUNT_UNIT: COUNT_UNIT,
    SeismogramSegment: SeismogramSegment,
    Seismogram: Seismogram,
    NonContiguousData: NonContiguousData,
    ensureIsSeismogram: ensureIsSeismogram,
    SeismogramDisplayData: SeismogramDisplayData,
    SeismogramDisplayStats: SeismogramDisplayStats,
    findStartEnd: findStartEnd,
    findMinMax: findMinMax,
    findMinMaxOverTimeRange: findMinMaxOverTimeRange,
    findStartEndOfSeismograms: findStartEndOfSeismograms,
    findMinMaxOfSeismograms: findMinMaxOfSeismograms
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const MINISEED_MIME = "application/vnd.fdsn.mseed";
  /**
   * parse arrayBuffer into an array of DataRecords.
   *
   * @param arrayBuffer bytes to parse
   * @returns arry of data records
   */

  function parseDataRecords(arrayBuffer) {
    let dataRecords = [];
    let offset = 0;

    while (offset < arrayBuffer.byteLength) {
      let dataView = new DataView(arrayBuffer, offset);
      let dr = parseSingleDataRecord(dataView);
      dataRecords.push(dr);
      offset += dr.header.recordSize;
    }

    return dataRecords;
  }
  /**
   * parse a single DataRecord starting at the beginning of the DataView.
   * Currently only some blockettes are parsed, 100, 1000, 1001, others are separated,
   * but left as just a DataView.
   *
   * @param dataView bytes as DataView
   * @returns data record
   */

  function parseSingleDataRecord(dataView) {
    let header = parseSingleDataRecordHeader(dataView);
    let data = new DataView(dataView.buffer, dataView.byteOffset + header.dataOffset, header.recordSize - header.dataOffset);
    return new DataRecord(header, data);
  }
  /**
   * parse the DataHeader from a single DataRecord starting at the beginning of the DataView.
   *
   * @param dataView bytes as DataView
   * @returns data record header
   */

  function parseSingleDataRecordHeader(dataView) {
    if (dataView.byteLength < 47) {
      throw new Error("Not enought bytes for header, need 47, found ".concat(dataView.byteLength));
    }

    let out = new DataHeader();
    out.seq = makeString(dataView, 0, 6);
    out.typeCode = dataView.getUint8(6);
    out.continuationCode = dataView.getUint8(7);
    out.staCode = makeString(dataView, 8, 5);
    out.locCode = makeString(dataView, 13, 2);
    out.chanCode = makeString(dataView, 15, 3);
    out.netCode = makeString(dataView, 18, 2);
    out.startBTime = parseBTime(dataView, 20);
    let headerByteSwap = checkByteSwap(out.startBTime);

    if (headerByteSwap) {
      out.startBTime = parseBTime(dataView, 20, headerByteSwap);
    }

    out.numSamples = dataView.getInt16(30, headerByteSwap);
    out.sampRateFac = dataView.getInt16(32, headerByteSwap);
    out.sampRateMul = dataView.getInt16(34, headerByteSwap);
    out.activityFlags = dataView.getUint8(36);
    out.ioClockFlags = dataView.getUint8(37);
    out.dataQualityFlags = dataView.getUint8(38);
    out.numBlockettes = dataView.getUint8(39);
    out.timeCorrection = dataView.getInt32(40, headerByteSwap);
    out.dataOffset = dataView.getUint16(44, headerByteSwap);
    out.blocketteOffset = dataView.getUint16(46, headerByteSwap);
    let offset = out.blocketteOffset;
    out.blocketteList = [];
    out.recordSize = 4096;
    out.sampleRate = out.calcSampleRate();
    out.startTime = out.startBTime.toMoment();

    for (let i = 0; i < out.numBlockettes; i++) {
      let nextOffset = dataView.getUint16(offset + 2, headerByteSwap);

      if (nextOffset === 0) {
        // last blockette
        nextOffset = out.dataOffset;
      }

      if (nextOffset === 0) {
        nextOffset = offset; // zero length, probably an error...
      }

      let blockette = parseBlockette(dataView, offset, nextOffset - offset, headerByteSwap);
      out.blocketteList.push(blockette);
      offset = nextOffset;

      if (blockette instanceof Blockette1000) {
        out.recordSize = 1 << blockette.dataRecordLengthByte;
        out.encoding = blockette.encoding;
        out.littleEndian = blockette.wordOrder === 0;
      } else if (blockette instanceof Blockette1001) {
        out.startBTime.microsecond = blockette.microsecond;
      } else if (blockette instanceof Blockette100) {
        out.sampleRate = blockette.sampleRate;
      }
    }

    out.endTime = out.timeOfSample(out.numSamples - 1);
    return out;
  }
  /**
   * parses a Blockette within the DataView.
   *
   * @param  dataView containing the data
   * @param  offset offset into the DataView to start
   * @param  length size in bytes of the Blockette
   * @param headerByteSwap true if byte swapping is needed
   * @returns Blockette instance
   */

  function parseBlockette(dataView, offset, length, headerByteSwap) {
    const type = dataView.getUint16(offset, headerByteSwap);
    const body = new DataView(dataView.buffer, dataView.byteOffset + offset, length);

    if (type === 1000) {
      const encoding = body.getUint8(4);
      const wordOrder = body.getUint8(5);
      const dataRecordLengthByte = body.getUint8(6);
      return new Blockette1000(type, body, encoding, dataRecordLengthByte, wordOrder);
    } else if (type === 1001) {
      const timeQual = body.getUint8(4);
      const microsecond = body.getUint8(5); //const reserved = body.getUint8(6)

      const frameCount = body.getUint8(7);
      return new Blockette1001(type, body, timeQual, microsecond, frameCount);
    } else if (type === 100) {
      const sampleRate = body.getFloat32(4);
      const flags = body.getUint8(8);
      return new Blockette100(type, body, sampleRate, flags);
    } else {
      return new Blockette(type, body);
    }
  }
  /**
   * Represents a SEED Data Record, with header, blockettes and data.
   *  */

  class DataRecord {
    constructor(header, data) {
      this.header = header;
      this.data = data;
    }
    /**
     * Decompresses the data , if the compression type is known.
     *
     * @returns decompressed data
     */


    decompress() {
      return this.asEncodedDataSegment().decode();
    }

    asEncodedDataSegment() {
      return new EncodedDataSegment(this.header.encoding, this.data, this.header.numSamples, this.header.littleEndian);
    }
    /**
     * Concatenates the net, station, loc and channel codes,
     * separated by the given seperator, or periods if not given.
     *
     * @param sep optional separater, defaults to .
     * @returns string of codes
     */


    codes(sep) {
      if (!isNonEmptyStringArg(sep)) {
        sep = '.';
      }

      return this.header.netCode + sep + this.header.staCode + sep + this.header.locCode + sep + this.header.chanCode;
    }

  }
  /**
   * Represents the header part of the DataRecord, including all the actual
   *  fixed header plus fields pulled from a blockette 1000 if present.
   */

  class DataHeader {
    constructor() {
      this.seq = "      ";
      this.typeCode = 68; // D

      this.continuationCode = 32; // space

      this.staCode = '';
      this.locCode = '';
      this.chanCode = '';
      this.netCode = '';
      this.startBTime = new BTime(1900, 1, 0, 0, 0, 0);
      this.numSamples = 0;
      this.sampRateFac = 0;
      this.sampRateMul = 0;
      this.activityFlags = 0;
      this.ioClockFlags = 0;
      this.dataQualityFlags = 0;
      this.numBlockettes = 0;
      this.timeCorrection = 0;
      this.dataOffset = 0;
      this.blocketteOffset = 0;
      this.blocketteList = [];
      this.recordSize = 4096;
      this.encoding = 0;
      this.littleEndian = false;
      this.sampleRate = 0;
      this.startTime = this.startBTime.toMoment();
      this.endTime = moment__default.utc(this.startTime);
    }

    toString() {
      return this.netCode + "." + this.staCode + "." + this.locCode + "." + this.chanCode + " " + this.startTime.toISOString() + " " + this.encoding;
    }
    /**
     * Calculates the sample rate in hertz from the sampRateFac and sampRateMul
     * parameters. This.sampleRate value is set to this value at construction.
     *
     * @returns sample rate
     */


    calcSampleRate() {
      let factor = this.sampRateFac;
      let multiplier = this.sampRateMul;
      let sampleRate = 10000.0; // default (impossible) value;

      if (factor * multiplier !== 0.0) {
        // in the case of log records
        sampleRate = Math.pow(Math.abs(factor), factor / Math.abs(factor)) * Math.pow(Math.abs(multiplier), multiplier / Math.abs(multiplier));
      }

      return sampleRate;
    }
    /**
     * Calculates the time of the i-th sample in the record, zero based,
     *  so timeOfSample(0) is the start and timeOfSample(this.numSamples-1) is end.
     *
     * @param i sample index
     * @returns time at i-th sample as moment
     */


    timeOfSample(i) {
      return moment__default.utc(this.startTime).add(i / this.sampleRate, 'second');
    }

  }
  class Blockette {
    constructor(type, body) {
      this.type = type;
      this.body = body;
    }

  }
  class Blockette1000 extends Blockette {
    constructor(type, body, encoding, dataRecordLengthByte, wordOrder) {
      super(type, body);

      if (type !== 1000) {
        throw new Error("Not a blockette1000: " + this.type);
      }

      this.encoding = encoding;
      this.dataRecordLengthByte = dataRecordLengthByte;
      this.wordOrder = wordOrder;
    }

  }
  class Blockette1001 extends Blockette {
    constructor(type, body, timeQual, microsecond, frameCount) {
      super(type, body);

      if (type !== 1001) {
        throw new Error("Not a blockette1001: " + this.type);
      }

      this.timeQual = timeQual;
      this.microsecond = microsecond;
      this.frameCount = frameCount;
    }

  }
  class Blockette100 extends Blockette {
    constructor(type, body, sampleRate, flags) {
      super(type, body);

      if (type !== 100) {
        throw new Error("Not a blockette100: " + this.type);
      }

      this.sampleRate = sampleRate;
      this.flags = flags;
    }

  }

  function makeString(dataView, offset, length) {
    let out = "";

    for (let i = offset; i < offset + length; i++) {
      let charCode = dataView.getUint8(i);

      if (charCode > 31) {
        out += String.fromCharCode(charCode);
      }
    }

    return out.trim();
  }

  function parseBTime(dataView, offset, byteSwap) {
    if (!isDef(byteSwap)) {
      byteSwap = false;
    }

    let year = dataView.getInt16(offset, byteSwap);
    let jday = dataView.getInt16(offset + 2, byteSwap);
    let hour = dataView.getInt8(offset + 4);
    let min = dataView.getInt8(offset + 5);
    let sec = dataView.getInt8(offset + 6); // byte 7 unused, alignment

    let tenthMilli = dataView.getInt16(offset + 8, byteSwap);
    return new BTime(year, jday, hour, min, sec, tenthMilli);
  }
  class BTime {
    // -50 to 49, not part of BTime proper, but added in case of B1001
    constructor(year, jday, hour, min, sec, tenthMilli) {
      this.length = 10;
      this.year = year;
      this.jday = jday;
      this.hour = hour;
      this.min = min;
      this.sec = sec;
      this.tenthMilli = tenthMilli;
      this.microsecond = 0;
    }

    toString() {
      return this.year + "-" + this.jday + " " + this.hour + ":" + this.min + ":" + this.sec + "." + this.tenthMilli.toFixed().padStart(4, '0') + " " + this.toMoment().toISOString();
    }
    /**
     * Converts this BTime to a momentjs utc moment. Note momentjs's precision
     * is limited to milliseconds.
     *
     * @returns         BTime as a moment
     */


    toMoment() {
      let m = new moment__default.utc([this.year, 0, 1, this.hour, this.min, this.sec, 0]);
      m.add(Math.round(this.tenthMilli / 10), 'ms');
      m.dayOfYear(this.jday);

      if (m.isValid()) {
        return m;
      } else {
        throw new Error("BTime.start is invalid moment: ".concat(this.year, " ").concat(this.jday, " ").concat(this.hour, " ").concat(this.min, " ").concat(this.sec, " ").concat(this.tenthMilli));
      }
    }

  }
  /**
   * Sanity checks on a BTime to see if a record might be in the wrong byte order
   * and so need to be byte swapped before parsing. Checks year betwee 1960 and 2055.
   *
   * @param   bTime  time
   * @returns        true is byte order appears to be wrong, false if it seems ok
   */

  function checkByteSwap(bTime) {
    return bTime.year < 1960 || bTime.year > 2055;
  }
  /** Determines if two DataRecords are contiguous, ie if the second starts
   * after the end of the first and the start time of the second is within
   * 1.5 times the sample period of the end of the first.
   *
   * @param dr1 first data record
   * @param dr2 seconds data record
   * @returns true if contiguous
   */

  function areContiguous(dr1, dr2) {
    let h1 = dr1.header;
    let h2 = dr2.header;
    return h1.endTime.isBefore(h2.startTime) && h1.endTime.valueOf() + 1000 * 1.5 / h1.sampleRate > h2.startTime.valueOf();
  }
  /**
   * Concatentates a sequence of DataRecords into a single seismogram object.
   * Assumes that they are all contiguous and in order. Header values from the first
   * DataRecord are used.
   *
   * @param contig array of data records
   * @returns SeismogramSegment instance
   * */

  function createSeismogramSegment(contig) {
    if (!Array.isArray(contig)) {
      contig = [contig];
    }

    let contigData = contig.map(dr => dr.asEncodedDataSegment());
    let out = new SeismogramSegment(contigData, contig[0].header.sampleRate, contig[0].header.startTime);
    out.networkCode = contig[0].header.netCode;
    out.stationCode = contig[0].header.staCode;
    out.locationCode = contig[0].header.locCode;
    out.channelCode = contig[0].header.chanCode;
    return out;
  }
  /**
   * Merges data records into a Seismogram object, each of
   * which consists of SeismogramSegment objects
   * containing the data as EncodedDataSegment objects. DataRecords are
   * sorted by startTime.
   * This assumes all data records are from the same channel, byChannel
   * can be used first if multiple channels may be present.
   *
   * @param drList array of data records
   * @returns Seismogram instance
   */

  function merge(drList) {
    let out = [];
    let currDR;
    drList.sort(function (a, b) {
      return a.header.startTime.diff(b.header.startTime);
    });
    let contig = [];

    for (let i = 0; i < drList.length; i++) {
      currDR = drList[i];

      if (contig.length === 0) {
        contig.push(currDR);
      } else if (areContiguous(contig[contig.length - 1], currDR)) {
        contig.push(currDR);
      } else {
        //found a gap
        out.push(createSeismogramSegment(contig));
        contig = [currDR];
      }
    }

    if (contig.length > 0) {
      // last segment
      out.push(createSeismogramSegment(contig));
      contig = [];
    }

    return new Seismogram(out);
  }
  /**
   * Splits a list of data records by channel code, returning a Map
   * with each NSLC string mapped to an array of data records.
   *
   * @param drList array of data records
   * @returns map of arrays of data records keyed by channel
   * */

  function byChannel(drList) {
    let out = new Map();
    let key;

    for (let i = 0; i < drList.length; i++) {
      let currDR = drList[i];
      key = currDR.codes();
      let drArray = out.get(key);

      if (!drArray) {
        drArray = [currDR];
        out.set(key, drArray);
      } else {
        drArray.push(currDR);
      }
    }

    return out;
  }
  /**
   * splits the DataRecords by channel and creates a single
   * Seismogram for each channel.
   *
   * @param   drList DataRecords array
   * @returns         Array of Seismogram
   */

  function seismogramPerChannel(drList) {
    let out = [];
    let byChannelMap = byChannel(drList);
    byChannelMap.forEach(segments => out.push(merge(segments)));
    return out;
  }

  var miniseed = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MINISEED_MIME: MINISEED_MIME,
    parseDataRecords: parseDataRecords,
    parseSingleDataRecord: parseSingleDataRecord,
    parseSingleDataRecordHeader: parseSingleDataRecordHeader,
    parseBlockette: parseBlockette,
    DataRecord: DataRecord,
    DataHeader: DataHeader,
    Blockette: Blockette,
    Blockette1000: Blockette1000,
    Blockette1001: Blockette1001,
    Blockette100: Blockette100,
    parseBTime: parseBTime,
    BTime: BTime,
    checkByteSwap: checkByteSwap,
    areContiguous: areContiguous,
    createSeismogramSegment: createSeismogramSegment,
    merge: merge,
    byChannel: byChannel,
    seismogramPerChannel: seismogramPerChannel
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** const for datalink protocol for web sockets, DataLink1.0 */

  const DATALINK_PROTOCOL = "DataLink1.0";
  /** const for query mode, QUERY */

  const QUERY_MODE = "QUERY";
  /** const for streaming mode, STREAM */

  const STREAM_MODE = "STREAM";
  /** const for maximum process number to create fake number for datalink id, 2^16-2 */

  const MAX_PROC_NUM = Math.pow(2, 16) - 2;
  /** const for fake user name for datalink id, browser */

  const USER_BROWSER = "browser";
  /** const for fake program name for datalink id, seisplotjs */

  const DEFAULT_PROGRAM = "seisplotjs";
  /** const for fake architecture for datalink id, javascript */

  const DEFAULT_ARCH = "javascript";
  /** const for error response, ERROR */

  const ERROR = "ERROR";
  const PACKET = "PACKET";
  const STREAM = "STREAM";
  const ENDSTREAM = "ENDSTREAM";
  const MSEED_TYPE = "/MSEED";
  const IRIS_RINGSERVER_URL = "ws://rtserve.iris.washington.edu/datalink";

  let defaultHandleResponse = function defaultHandleResponse(message) {
    log("Unhandled datalink response: " + message);
  };
  /**
   * A websocket based Datalink connection to a ringserver.
   * Currently only the IRIS
   * ringserver, https://github.com/iris-edu/ringserver,
   * supports websockets, but it may be possible to use thrid party
   * tools to proxy the websocket to a TCP datalink socket.
   * The datalink protocol is documented here
   *  https://raw.githubusercontent.com/iris-edu/libdali/master/doc/DataLink.protocol
   *
   * @param url websocket url to the ringserver
   * @param packetHandler callback for packets as they arrive
   * @param errorHandler callback for errors
   */


  class DataLinkConnection {
    /** @private */
    constructor(url, packetHandler, errorHandler) {
      this.url = url;
      this._mode = QUERY_MODE;
      this.packetHandler = packetHandler;
      this.errorHandler = errorHandler;
      this.closeHandler = null;
      this.serverId = null; // meant to be processId, so use 1 <= num <= 2^15 to be safe

      this.clientIdNum = Math.floor(Math.random() * MAX_PROC_NUM) + 1;
      this.programname = DEFAULT_PROGRAM;
      this.username = USER_BROWSER;
      this.architecture = DEFAULT_ARCH;
      this._responseResolve = null;
      this._responseReject = null;
    }
    /**
     * Set a callback function called when the connection is closed.
     *
     * @param  closeHandler callback function
     */


    setOnClose(closeHandler) {
      this.closeHandler = closeHandler;
    }
    /**
     * creates the websocket connection and sends the client ID.
     *
     *  @returns a Promise that resolves to the server's ID.
     */


    connect() {
      const that = this;
      return new RSVP.Promise(function (resolve, reject) {
        const webSocket = new WebSocket(that.url, DATALINK_PROTOCOL);
        that.webSocket = webSocket;
        webSocket.binaryType = 'arraybuffer';

        webSocket.onmessage = function (event) {
          that.handle(event);
        };

        webSocket.onerror = function (event) {
          that.handleError(new Error("" + stringify(event)));
          reject(event);
        };

        webSocket.onclose = function (closeEvent) {
          that.webSocket = null; // clean up

          that._mode = QUERY_MODE;

          if (that.closeHandler) {
            that.closeHandler(closeEvent);
          }
        };

        webSocket.onopen = function () {
          resolve(that);
        };
      }).then(datalink => {
        return datalink.sendId();
      }).then(idmsg => {
        that.serverId = idmsg;
        return idmsg;
      });
    }
    /**
     * @returns true if the websocket is connected (non-null)
     */


    isConnected() {
      return this.webSocket !== null;
    }
    /**
     * @returns the current mode, QUERY_MODE or STREAM_MODE
     *
     */


    get mode() {
      return this._mode;
    }
    /**
     * Switches to streaming mode to receive data packets from the ringserver.
     */


    stream() {
      if (this._mode === STREAM_MODE) {
        return;
      }

      this._mode = STREAM_MODE;
      this.sendDLCommand(STREAM, "");
    }
    /**
     * Switches back to query mode to enable commands to be sent to the ringserver.
     */


    endStream() {
      if (this.webSocket === null || this._mode === null || this._mode === QUERY_MODE) {
        return;
      }

      this._mode = QUERY_MODE;
      this.sendDLCommand(ENDSTREAM, "");
    }
    /**
     * Closes the connection and the underlying websocket. No communication
     * is possible until connect() is called again.
     */


    close() {
      if (this.webSocket) {
        this.endStream(); // end streaming just in case

        if (this.webSocket) {
          this.webSocket.close();
        }

        this.webSocket = null;
        this._mode = null;
      }
    }
    /**
     * Send a ID Command. Command is a string.
     *
     * @returns a Promise that resolves to the response from the ringserver.
     */


    sendId() {
      const that = this;
      return this.id(this.programname, this.username, stringify(this.clientIdNum), this.architecture).then(this.ensureDataLinkResponse).then(dlResponse => {
        if (dlResponse.type === 'ID') {
          that.serverId = '' + dlResponse.message;
          return that.serverId;
        } else {
          throw new Error("not ID response: " + stringify(dlResponse.type));
        }
      });
    }
    /**
     * encodes as a Datalink packet, header with optional data section as
     * binary Uint8Array. Size of the binary data is appended
     * to the header if present.
     *
     * @param header the command/header string
     * @param data optional data portion
     * @returns datalink packet as an ArrayBuffer
     */


    encodeDL(header, data) {
      let cmdLen = header.length;
      let len = 3 + header.length;
      let lenStr = "";

      if (data && data.length > 0) {
        lenStr = String(data.length);
        len += lenStr.length + 1;
        cmdLen += lenStr.length + 1;
        len += data.length;
      }

      let rawPacket = new ArrayBuffer(len);
      const binaryPacket = new Uint8Array(rawPacket);
      let packet = new DataView(rawPacket);
      packet.setUint8(0, 68); // ascii D

      packet.setUint8(1, 76); // ascii L

      packet.setUint8(2, cmdLen);
      let i = 3;

      for (const c of header) {
        packet.setUint8(i, c.charCodeAt(0));
        i++;
      }

      const SPACE = ' ';

      if (data && data.length > 0) {
        packet.setUint8(i, SPACE.charCodeAt(0)); // ascii space

        i++;

        for (const c of lenStr) {
          packet.setUint8(i, c.charCodeAt(0));
          i++;
        }

        binaryPacket.set(data, i);
      }

      return rawPacket;
    }
    /** sends the header with optional binary data
     * as the data section. Size of the data is appended
     * to the header before sending if present.
     *
     * @param header header to send
     * @param data optional data to send
     */


    sendDLBinary(header, data) {
      const rawPacket = this.encodeDL(header, data);

      if (this.webSocket) {
        this.webSocket.send(rawPacket);
      } else {
        throw new Error("WebSocket has been closed.");
      }
    }
    /** sends the command as header with optional dataString
     * as the data section. Size of the dataString is appended
     * to the header before sending.
     *
     * @param command the command/header string
     * @param dataString optional data portion of packet
     */


    sendDLCommand(command, dataString) {
      this.sendDLBinary(command, stringToUint8Array(dataString));
    }
    /**
     * Send a DataLink Command and await the response. Command is a string.
     *
     * @param header packet header
     * @param data optional data portion of packet
     * @returns a Promise that resolves with the webSocket MessageEvent.
     */


    awaitDLBinary(header, data) {
      let that = this;
      let promise = new RSVP.Promise(function (resolve, reject) {
        that._responseResolve = resolve;
        that._responseReject = reject;
        that.sendDLBinary(header, data);
      }).then(response => {
        that._responseResolve = null;
        that._responseReject = null;
        return response;
      }).catch(error => {
        that._responseResolve = null;
        that._responseReject = null;
        throw error;
      });
      return promise;
    }
    /**
     * Send a DataLink Command and await the response. Command is a string.
     * Returns a Promise that resolves with the webSocket MessageEvent.
     *
     * @param command the command/header string
     * @param dataString optional data portion of packet
     * @returns promise to server's response
     */


    awaitDLCommand(command, dataString) {
      return this.awaitDLBinary(command, stringToUint8Array(dataString));
    }
    /**
     * Writes data to the ringserver and awaits a acknowledgement.
     *
     * @param   streamid    stream id for packet header
     * @param   hpdatastart start of timewindow the packet covers
     * @param   hpdataend   end of timewindow the packet covers
     * @param   data        optional data to send
     * @returns             promise to server's response
     */


    writeAck(streamid, hpdatastart, hpdataend, data) {
      let header = "WRITE ".concat(streamid, " ").concat(momentToHPTime(hpdatastart), " ").concat(momentToHPTime(hpdataend), " A");
      return this.awaitDLBinary(header, data);
    }
    /**
     * Makes sure a response actually is a DataLinkResponse
     *
     * @param   dl datalink packet/response
     * @returns DataLinkResponse after checking instanceof
     * @throws Error if not a DataLinkResponse
     */


    ensureDataLinkResponse(dl) {
      if (dl instanceof DataLinkResponse) {
        return dl;
      }

      throw new Error("Expected DataLinkResponse but got ".concat(dl.header));
    }
    /**
     * Makes sure a response actually is a DataLinkPacket
     *
     * @param   dl datalink packet/response
     * @returns DataLinkPacket after checking instanceof
     * @throws Error if not a DataLinkPacket
     */


    ensureDataLinkPacket(dl) {
      if (dl instanceof DataLinkPacket) {
        return dl;
      }

      throw new Error("Expected DataLinkPacket but got ".concat(dl.type));
    }
    /**
     * Send id and await server's response. All of these are can more or less
     * be filled with dummy values. They are mostly used for logging and debugging
     * on the server side.
     *
     * @param programname name of program, ex seisplotjs
     * @param username name of user, ex browser
     * @param processid process number, used to differentiate between multiple running instances
     * @param architecture cpu architecture, ex javascript
     * @returns promise to servers response
     */


    id(programname, username, processid, architecture) {
      let command = "ID ".concat(programname, ":").concat(username, ":").concat(processid, ":").concat(architecture);
      return this.awaitDLCommand(command).then(this.ensureDataLinkResponse);
    }
    /**
     * Send info command for infoType.
     *
     * @param infoType type to get info for
     * @returns promise to server's response
     */


    info(infoType) {
      let command = "INFO ".concat(infoType);
      return this.awaitDLCommand(command).then(this.ensureDataLinkResponse);
    }
    /**
     * Send position after command.
     *
     * @param time time to position after
     * @returns promise to server's response
     */


    positionAfter(time) {
      return this.positionAfterHPTime(momentToHPTime(time)).then(this.ensureDataLinkResponse);
    }
    /**
     * Send position after command.
     *
     * @param hpTime time to position after
     * @returns promise to server's response
     */


    positionAfterHPTime(hpTime) {
      let command = "POSITION AFTER ".concat(hpTime);
      return this.awaitDLCommand(command).then(this.ensureDataLinkResponse);
    }
    /**
     * Send match command.
     *
     * @param pattern regular expression to match streams
     * @returns promise to server's response
     */


    match(pattern) {
      let command = "MATCH";
      return this.awaitDLCommand(command, pattern).then(this.ensureDataLinkResponse);
    }
    /**
     * Send reject command.
     *
     * @param pattern regular expression to reject streams
     * @returns promise to server's response
     */


    reject(pattern) {
      let command = "REJECT ".concat(pattern);
      return this.awaitDLCommand(command).then(this.ensureDataLinkResponse);
    }
    /**
     * Read a single packet for the given id.
     *
     * @param packetId id of the packet of interest
     * @returns promise to server's response
     */


    read(packetId) {
      let command = "READ ".concat(packetId);
      return this.awaitDLBinary(command).then(this.ensureDataLinkPacket);
    }
    /**
     * Handles a web socket message from the data link connection.
     *
     * @private
     * @param wsEvent web socket event to handle
     */


    handle(wsEvent) {
      const rawData = wsEvent.data;
      let dlPreHeader = new DataView(rawData, 0, 3);

      if ('D' === String.fromCharCode(dlPreHeader.getUint8(0)) && 'L' === String.fromCharCode(dlPreHeader.getUint8(1))) {
        const headerLen = dlPreHeader.getUint8(2);
        const header = dataViewToString(new DataView(rawData, 3, headerLen));

        if (header.startsWith(PACKET)) {
          let packet = new DataLinkPacket(header, new DataView(rawData, 3 + headerLen));

          if (this.packetHandler) {
            try {
              this.packetHandler(packet);
            } catch (e) {
              this.errorHandler(e);
            }
          } else {
            this.errorHandler(new Error("packetHandler not defined"));
          }
        } else {
          let dv;

          if (rawData.byteLength > 3 + headerLen) {
            dv = new DataView(rawData, 3 + headerLen);
          }

          const dlResponse = DataLinkResponse.parse(header, dv);

          if (dlResponse.type === 'ERROR') {
            this.handleError(new Error("value=".concat(dlResponse.value, " ").concat(dlResponse.message)));
          } else {
            if (this._responseResolve) {
              this._responseResolve(dlResponse);
            } else {
              defaultHandleResponse(header);
            }
          }
        }
      } else {
        throw new Error("DataLink Packet did not start with DL");
      }
    }
    /**
     * handle errors that arise
     *
     * @private
     * @param   error the error
     */


    handleError(error) {
      if (this._responseReject) {
        this._responseReject(error);
      }

      if (this.errorHandler) {
        this.errorHandler(error);
      } else {
        log("datalink handleError: " + error.message);
      }
    }

  }
  /**
   * Datalink response, used for ID, INFO, OK and ERROR responses.
   */

  class DataLinkResponse {
    constructor(type, value, message) {
      this.type = type;
      this.value = value;
      this.message = message;
    }

    toString() {
      return "".concat(this.type, " ").concat(this.value, " | ").concat(this.message);
    }

    static parse(header, data) {
      let value = "";
      let s = header.split(' ');
      let type = s[0];
      let message = '';

      if (type === 'ID') {
        message = '' + header.substring(3);
      } else if (type === 'INFO' || type === 'OK' || type === 'ERROR') {
        value = s[1];

        if (data) {
          message = dataViewToString(new DataView(data.buffer, 3 + header.length));
        }
      } else {
        log("unknown DataLink response type: ".concat(type, "  ").concat(header));
        message = header.substring(type.length + 1);
      }

      return new DataLinkResponse(type, value, message);
    }

  }
  /**
   * Represents a Datalink packet from the ringserver.
   * Note this cannot connect directly to a native TCP socket, instead it
   * sends the datalink protocol over a websocket. Currently only the IRIS
   * ringserver supports websockets, but it may be possible to use thrid party
   * tools to proxy the websocket to a TCP datalink socket.
   *
   */

  class DataLinkPacket {
    constructor(header, dataview) {
      this._miniseed = null;
      this.header = header;
      this.data = dataview;
      let split = this.header.split(' ');
      this.streamId = split[1];
      this.pktid = split[2];
      this.hppackettime = split[3];
      this.hppacketstart = split[4];
      this.hppacketend = split[5];
      this.dataSize = Number.parseInt(split[6]);

      if (dataview.byteLength < this.dataSize) {
        throw new Error("not enough bytes in dataview for packet: " + this.dataSize);
      }
    }
    /**
     * Packet start time as a moment.
     *
     * @returns start time
     */


    get packetStart() {
      return hpTimeToMoment(parseInt(this.hppacketstart));
    }
    /**
     * Packet end time as a moment.
     *
     * @returns end time
     */


    get packetEnd() {
      return hpTimeToMoment(parseInt(this.hppacketend));
    }
    /**
     * Packet time as a moment.
     *
     * @returns packet time
     */


    get packetTime() {
      return hpTimeToMoment(parseInt(this.hppackettime));
    }
    /**
     * is this packet a miniseed packet
     *
     * @returns          true if it is miniseed
     */


    isMiniseed() {
      return isDef(this._miniseed) || this.streamId.endsWith(MSEED_TYPE);
    }
    /**
     * Parsed payload as a miniseed data record, if the streamid
     * ends with '/MSEED', null otherwise.
     *
     * @returns miniseed DataRecord or null
     */


    get miniseed() {
      if (!isDef(this._miniseed)) {
        if (this.streamId.endsWith(MSEED_TYPE)) {
          this._miniseed = parseSingleDataRecord(this.data);
        } else {
          this._miniseed = null;
        }
      }

      return this._miniseed;
    }

  }
  /**
   * Convert moment to a HPTime number.
   *
   * @param   m moment to convert
   * @returns  microseconds since epoch
   */

  function momentToHPTime(m) {
    return m.valueOf() * 1000;
  }
  /**
   * Convert hptime number to a moment.
   *
   * @param   hptime hptime to convert
   * @returns  moment in utc for the hptime
   */

  function hpTimeToMoment(hptime) {
    return moment__default.utc(hptime / 1000);
  }
  /**
   * Encode string into a Uint8Array.
   *
   * @param   dataString String to encode.
   * @returns             String as bytes in Uint8Array.
   */

  function stringToUint8Array(dataString) {
    let binaryData = undefined;

    if (isNonEmptyStringArg(dataString)) {
      binaryData = new Uint8Array(dataString.length);

      for (let i = 0; i < dataString.length; i++) {
        binaryData[i] = dataString.charCodeAt(i);
      }
    }

    return binaryData;
  }

  var datalink = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DATALINK_PROTOCOL: DATALINK_PROTOCOL,
    QUERY_MODE: QUERY_MODE,
    STREAM_MODE: STREAM_MODE,
    MAX_PROC_NUM: MAX_PROC_NUM,
    USER_BROWSER: USER_BROWSER,
    DEFAULT_PROGRAM: DEFAULT_PROGRAM,
    DEFAULT_ARCH: DEFAULT_ARCH,
    ERROR: ERROR,
    PACKET: PACKET,
    STREAM: STREAM,
    ENDSTREAM: ENDSTREAM,
    MSEED_TYPE: MSEED_TYPE,
    IRIS_RINGSERVER_URL: IRIS_RINGSERVER_URL,
    DataLinkConnection: DataLinkConnection,
    DataLinkResponse: DataLinkResponse,
    DataLinkPacket: DataLinkPacket,
    momentToHPTime: momentToHPTime,
    hpTimeToMoment: hpTimeToMoment,
    stringToUint8Array: stringToUint8Array
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * Hour and Minute chooser using sliders.
   *
   * @param div selected div to append chooser to
   * @param initialTime initial chooser time value
   * @param updateCallback optional callback function when time is selected
   */

  class HourMinChooser {
    // d3 not yet in flow-typed :(
    // d3 not yet in flow-typed :(
    // d3 not yet in flow-typed :(
    // d3 not yet in flow-typed :(
    // d3 not yet in flow-typed :(
    // d3 not yet in flow-typed :(
    // d3 not yet in flow-typed :(
    constructor(div, initialTime, updateCallback) {
      let mythis = this;

      if (typeof div === 'string') {
        this.div = d3.select(div);
      } else {
        this.div = div;
      }

      this.time = moment__default.utc(initialTime);
      this.updateCallback = updateCallback ? updateCallback : dummyCallback;
      this.hourMinRegEx = /^([0-1]?[0-9]):([0-5]?[0-9])$/;

      this.myOnClick = function (e) {
        // click document outside popup closes popup
        // not sure this if matters???
        if (e.target !== mythis.hourMinField && e.target !== mythis.popupDiv) {
          mythis.hide();
        }
      };

      this.hourMinField = this.div.append("input").classed("pikatime", true).attr("value", this.time.format('HH:mm')).attr("type", "text").on("click", function () {
        mythis.showHide(); // don't propagate click up to document

        d3.event.stopPropagation();
      }).on("change", function () {
        let match = mythis.hourMinRegEx.exec(mythis.hourMinField.property("value"));

        if (match) {
          mythis.hourMinField.style("background-color", null);
          let h = match[1];
          let m = match[2];
          mythis.time.hours(h);
          mythis.time.minutes(m);
          mythis.popupDiv.style("visibility", "hidden");
          mythis.timeModified();
        } else {
          mythis.hourMinField.property("value", mythis.time.format('HH:mm'));
        }
      });
      this.div.append("span").classed("utclabel", true).text("UTC");
      this.popupDiv = this.div.append("div").classed("hourminpopup", true).style("position", "absolute").style("visibility", "hidden").on("click", function () {
        // don't propagate click up to document
        d3.event.stopPropagation();
      });
      this.hourDiv = this.popupDiv.append("div").classed("hour", true);
      this.hourSlider = this.hourDiv.append("label").text("Hour:").append("input");
      this.hourSlider.attr("type", "range").attr("min", "0").attr("max", "23").classed("hourSlider", true).on("input", function () {
        let nHour = +this.value;

        if (mythis.time.hours() !== nHour) {
          mythis.time.hours(nHour);
          mythis.hourSlider.property("value", nHour);
          mythis.timeModified();
        }
      });
      this.hourSlider.attr("value", this.time.hour());
      this.minuteDiv = this.popupDiv.append("div").classed("minute", true);
      this.minuteSlider = this.minuteDiv.append("label").text("Minute:").append("input");
      this.minuteSlider.attr("type", "range").attr("min", "0").attr("max", "59").classed("minuteSlider", true).on("input", function () {
        let nMinute = +this.value;

        if (mythis.time.minutes() !== nMinute) {
          mythis.time.minutes(nMinute);
          mythis.minuteSlider.property("value", nMinute);
          mythis.timeModified();
        }
      });
      this.minuteSlider.attr("value", this.time.minute());
    }
    /**
     * Updates the time without triggering the callback function.
     *
     * @param  newTime new time to update sliders
     */


    updateTime(newTime) {
      this.time = newTime;
      this.hourMinField.property("value", this.time.format('HH:mm'));
      this.hourSlider.property("value", this.time.hour());
      this.minuteSlider.property("value", this.time.minute());
    }
    /**
     * Updates the sliders based on this.time and triggers the callback function.
     */


    timeModified() {
      this.hourSlider.property("value", this.time.hour());
      this.minuteSlider.property("value", this.time.minute());
      this.hourMinField.property("value", this.time.format('HH:mm'));
      this.updateCallback(this.time);
    }
    /**
     * Shows or hides the popup based on current visibility style
     */


    showHide() {
      if (this.popupDiv.style("visibility") === "hidden") {
        this.popupDiv.style("visibility", "visible").classed("is-bound", true);

        this._adjustPopupPosition();

        window.document.addEventListener("click", this.myOnClick, false);
      } else {
        this.popupDiv.style("visibility", "hidden");
        window.document.removeEventListener("click", this.myOnClick);
      }
    }
    /**
     * Hides the popup with sliders.
     */


    hide() {
      this.popupDiv.style("visibility", "hidden").classed("is-bound", false);
      window.document.removeEventListener("click", this.myOnClick);
    }
    /** @private */


    _adjustPopupPosition() {
      let field = this.hourMinField.node();
      let width = this.hourMinField.offsetWidth;
      let height = this.hourMinField.offsetHeight;
      let viewportWidth = window.innerWidth;
      let viewportHeight = window.innerHeight;
      let scrollTop = window.pageYOffset;
      let left = field.offsetLeft;
      let top = field.offsetTop + field.offsetHeight;

      while (field = field.offsetParent) {
        left += field.offsetLeft;
        top += field.offsetTop;
      } // default position is bottom & left


      if (left + width > viewportWidth) {
        left = left - width + field.offsetWidth;
      }

      if (top + height > viewportHeight + scrollTop) {
        top = top - height - field.offsetHeight;
      }

      this.popupDiv.style("left", left + 'px');
      this.popupDiv.style("top", top + 'px');
    }

  }
  /**
   * Date and Time chooser using pikaday for the date and the above
   * HourMinChooser for the hour and minute of time.
   *
   * @param div selected div to append chooser to
   * @param label label for chooser
   * @param initialTime initial chooser time value
   * @param updateCallback optional callback function when time is selected
   */

  class DateTimeChooser {
    // d3 not yet in flow-typed :(
    constructor(div, label, initialTime, updateCallback) {
      if (typeof div === 'string') {
        this.div = d3.select(div);
      } else {
        this.div = div;
      }

      this.label = label;
      this.time = moment__default.utc(initialTime);
      this.time.second(0).millisecond(0); // only hour and min?

      this.updateCallback = updateCallback ? updateCallback : dummyCallback;
      this.dateField = div.append("label").text(this.label).append("input").classed("pikaday", true).attr("value", this.time.toISOString()).attr("type", "text").on("click", function () {
        if (mythis.picker.isVisible()) {
          mythis.picker.hide();
        }
      });
      let mythis = this;
      this.picker = new Pikaday({
        field: this.dateField.node(),
        //  trigger: inputField.node(),
        format: "YYYY-MM-DD",
        onSelect: function onSelect() {
          let pikaValue = this.getMoment();
          let origTime = moment__default.utc(mythis.time);

          if (origTime.year() !== pikaValue.year() || origTime.dayOfYear() !== pikaValue.dayOfYear()) {
            mythis.time.year(pikaValue.year());
            mythis.time.dayOfYear(pikaValue.dayOfYear());
            mythis.timeModified();
          }
        }
      });

      this._internalSetTime(this.time);

      this.hourMin = new HourMinChooser(div, this.time, function (time) {
        mythis._internalSetTime(time);

        mythis.timeModified();
      });
    }
    /**
     * Updates the time without triggering the callback function.
     *
     * @param  newTime new time to update sliders
     */


    updateTime(newTime) {
      this._internalSetTime(newTime);

      this.hourMin.updateTime(newTime);
    }
    /**
     * triggers the callback function.
     */


    timeModified() {
      this.updateCallback(this.time);
    }

    getTime() {
      return this.time;
    }
    /**
     * internal time set
     *
     * @private
     * @param  newTime new time to update
     */


    _internalSetTime(newTime) {
      this.time = moment__default.utc(newTime);
      this.dateField.attr("value", this.time.toISOString()); // re-moment to avoid utc issue, using utc messes up picker, so pretend

      this.picker.setMoment(moment__default([this.time.year(), this.time.month(), this.time.date()]));
    }

  }
  /**
   * Combination of two DateTimeChoosers to specify a start and end time.
   *
   * @param div selected div to append chooser to
   * @param updateCallback optional callback function when time is selected/changed
   */

  class TimeRangeChooser {
    constructor(div, updateCallback) {
      this._mostRecentChanged = 'start';
      this.updateCallback = updateCallback ? updateCallback : dummyCallback;
      let endTime = moment__default.utc();
      this.duration = 300;
      let startTime = moment__default.utc(endTime).subtract(this.duration, 'second');

      if (typeof div === 'string') {
        this.div = d3.select(div);
      } else {
        this.div = div;
      }

      this.div.classed("timeRangeChooser", true);
      let mythis = this;
      let startDiv = this.div.append("span").classed("start", true);
      this.startChooser = new DateTimeChooser(startDiv, "Start:", startTime, function (startTime) {
        mythis.endChooser.updateTime(moment__default.utc(startTime).add(mythis.duration, 'seconds'));
        mythis.updateCallback(mythis.getTimeRange());
        mythis._mostRecentChanged = 'start';
      });
      let durationDiv = this.div.append("span").classed("duration", true);
      durationDiv.append("label").text("Duration:").append("input").classed("pikatime", true).attr("value", this.duration).attr("type", "text").on("input", function () {
        let nDur = +Number.parseInt(this.value);
        mythis.duration = nDur;

        if (mythis._mostRecentChanged === 'end') {
          mythis.startChooser.updateTime(moment__default.utc(mythis.endChooser.getTime()).subtract(mythis.duration, 'seconds'));
          mythis.updateCallback(mythis.getTimeRange());
        } else {
          // change end
          mythis.endChooser.updateTime(moment__default.utc(mythis.startChooser.getTime()).add(mythis.duration, 'seconds'));
          mythis.updateCallback(mythis.getTimeRange());
        }
      });
      let endDiv = this.div.append("span").classed("end", true);
      this.endChooser = new DateTimeChooser(endDiv, "End:", endTime, function (endTime) {
        mythis.startChooser.updateTime(moment__default.utc(endTime).subtract(mythis.duration, 'seconds'));
        mythis.updateCallback(mythis.getTimeRange());
        mythis._mostRecentChanged = 'end';
      });
    }

    getTimeRange() {
      return new StartEndDuration(this.startChooser.getTime(), this.endChooser.getTime());
    }

  }
  /**
   * Dummy callback function for cases where user doesn't need this. Mainly here
   * to keep eslint happy.
   *
   * @param   t new time/time range, not used
   */
  // eslint-disable-next-line no-unused-vars

  function dummyCallback(t) {}
  /**
   * CSS for the parts of HourMin, DateTime and TimeRange choosers
   * that are not using pikaday.
   */


  const chooser_css = "\n\ndiv.timeRangeChooser .utclabel {\n  font-size: smaller;\n}\n\ndiv.timeRangeChooser span div.hourminpopup {\n    z-index: 9999;\n    display: block;\n    position: relative;\n    color: #333;\n    background-color: white;\n    border: 1px solid #ccc;\n    border-bottom-color: #bbb;\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);\n}\n\n\n\n.hourminpopup.is-hidden {\n    display: none;\n}\n.hourminpopup.is-bound {\n    position: absolute;\n    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);\n    background-color: white;\n}\n\ndiv.hourminpopup div label {\n  display: block;\n  float: right;\n}\ndiv.hourminpopup div {\n    display: block;\n    float: right;\n    clear: both;\n}\n\ndiv.hourminpopup input {\n    width: 150px;\n}\n\ndiv.timeRangeChooser span {\n  margin: 2px;\n  margin-right: 5px;\n}\n\ninput.pikaday {\n  width: 70px;\n}\ninput.pikatime {\n  width: 50px;\n}\n\n";
  /**
   * CSS for the pikaday chooser.
   */

  const pikaday_css = "\n@charset \"UTF-8\";\n\n/*!\n * Pikaday\n * Copyright \xA9 2014 David Bushell | BSD & MIT license | http://dbushell.com/\n */\n\n.pika-single {\n    z-index: 9999;\n    display: block;\n    position: relative;\n    color: #333;\n    background: #fff;\n    border: 1px solid #ccc;\n    border-bottom-color: #bbb;\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n}\n\n/*\nclear child float (pika-lendar), using the famous micro clearfix hack\nhttp://nicolasgallagher.com/micro-clearfix-hack/\n*/\n.pika-single:before,\n.pika-single:after {\n    content: \" \";\n    display: table;\n}\n.pika-single:after { clear: both }\n\n.pika-single.is-hidden {\n    display: none;\n}\n\n.pika-single.is-bound {\n    position: absolute;\n    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);\n}\n\n.pika-lendar {\n    float: left;\n    width: 240px;\n    margin: 8px;\n}\n\n.pika-title {\n    position: relative;\n    text-align: center;\n}\n\n.pika-label {\n    display: inline-block;\n    position: relative;\n    z-index: 9999;\n    overflow: hidden;\n    margin: 0;\n    padding: 5px 3px;\n    font-size: 14px;\n    line-height: 20px;\n    font-weight: bold;\n    background-color: #fff;\n}\n.pika-title select {\n    cursor: pointer;\n    position: absolute;\n    z-index: 9998;\n    margin: 0;\n    left: 0;\n    top: 5px;\n    opacity: 0;\n}\n\n.pika-prev,\n.pika-next {\n    display: block;\n    cursor: pointer;\n    position: relative;\n    outline: none;\n    border: 0;\n    padding: 0;\n    width: 20px;\n    height: 30px;\n    /* hide text using text-indent trick, using width value (it's enough) */\n    text-indent: 20px;\n    white-space: nowrap;\n    overflow: hidden;\n    background-color: transparent;\n    background-position: center center;\n    background-repeat: no-repeat;\n    background-size: 75% 75%;\n    opacity: .5;\n}\n\n.pika-prev:hover,\n.pika-next:hover {\n    opacity: 1;\n}\n\n.pika-prev,\n.is-rtl .pika-next {\n    float: left;\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');\n}\n\n.pika-next,\n.is-rtl .pika-prev {\n    float: right;\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');\n}\n\n.pika-prev.is-disabled,\n.pika-next.is-disabled {\n    cursor: default;\n    opacity: .2;\n}\n\n.pika-select {\n    display: inline-block;\n}\n\n.pika-table {\n    width: 100%;\n    border-collapse: collapse;\n    border-spacing: 0;\n    border: 0;\n}\n\n.pika-table th,\n.pika-table td {\n    width: 14.285714285714286%;\n    padding: 0;\n}\n\n.pika-table th {\n    color: #999;\n    font-size: 12px;\n    line-height: 25px;\n    font-weight: bold;\n    text-align: center;\n}\n\n.pika-button {\n    cursor: pointer;\n    display: block;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    outline: none;\n    border: 0;\n    margin: 0;\n    width: 100%;\n    padding: 5px;\n    color: #666;\n    font-size: 12px;\n    line-height: 15px;\n    text-align: right;\n    background: #f5f5f5;\n}\n\n.pika-week {\n    font-size: 11px;\n    color: #999;\n}\n\n.is-today .pika-button {\n    color: #33aaff;\n    font-weight: bold;\n}\n\n.is-selected .pika-button,\n.has-event .pika-button {\n    color: #fff;\n    font-weight: bold;\n    background: #33aaff;\n    box-shadow: inset 0 1px 3px #178fe5;\n    border-radius: 3px;\n}\n\n.has-event .pika-button {\n    background: #005da9;\n    box-shadow: inset 0 1px 3px #0076c9;\n}\n\n.is-disabled .pika-button,\n.is-inrange .pika-button {\n    background: #D5E9F7;\n}\n\n.is-startrange .pika-button {\n    color: #fff;\n    background: #6CB31D;\n    box-shadow: none;\n    border-radius: 3px;\n}\n\n.is-endrange .pika-button {\n    color: #fff;\n    background: #33aaff;\n    box-shadow: none;\n    border-radius: 3px;\n}\n\n.is-disabled .pika-button {\n    pointer-events: none;\n    cursor: default;\n    color: #999;\n    opacity: .3;\n}\n\n.is-outside-current-month .pika-button {\n    color: #999;\n    opacity: .3;\n}\n\n.is-selection-disabled {\n    pointer-events: none;\n    cursor: default;\n}\n\n.pika-button:hover,\n.pika-row.pick-whole-week:hover .pika-button {\n    color: #fff;\n    background: #ff8000;\n    box-shadow: none;\n    border-radius: 3px;\n}\n\n/* styling for abbr */\n.pika-table abbr {\n    border-bottom: none;\n    cursor: help;\n}\n\n";

  if (document) {
    insertCSS(chooser_css);
    insertCSS(pikaday_css);
  }

  var datechooser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    HourMinChooser: HourMinChooser,
    DateTimeChooser: DateTimeChooser,
    TimeRangeChooser: TimeRangeChooser,
    chooser_css: chooser_css,
    pikaday_css: pikaday_css
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */

  /** const for kilometers per degree on the earth, 111.19 */
  const kmPerDeg = 111.19;
  /**
   * Convert degrees into kilometers along the earth surface
   *
   * @param deg degrees to convert
   * @returns kilometers
   */

  function degtokm(deg) {
    return deg * kmPerDeg;
  }
  /**
   * Convert kilometers into degrees along the earth surface
   *
   * @param km kilometers to convert
   * @returns degrees
   */

  function kmtodeg(km) {
    return km / kmPerDeg;
  }

  /**
   *
   * Returns a simple object (DistAzOutput) with:
   *```
   *     delta       => Great Circle Arc distance in degrees
   *     az          => Azimuth of pt. 1 wrt pt. 2 in degrees
   *     baz         => Azimuth of pt. 2 wrt pt. 1 in degrees
   *```
   *
   * azimuth is if you stand at point 2 and measure angle between north
   *   and point 1. I.E. point 1 is the station and point 2 is the event.
   *
   * @param lat1 Latitude of first point (station) (+N, -S) in degrees
   * @param lon1 Longitude of first point(station) (+E, -W) in degrees
   * @param lat2 Latitude of second point (event)
   * @param lon2 Longitude of second point (event)
   * @returns delta, az, baz in a DistAzOutput
   */
  function distaz(lat1, lon1, lat2, lon2) {
    let result = {
      stalat: lat1,
      stalon: lon1,
      evtlat: lat2,
      evtlon: lon2,
      delta: 0.0,
      az: 0.0,
      baz: 0.0
    };

    if (lat1 === lat2 && lon1 === lon2) {
      // don't do calc, just return zero for idential points
      result.delta = 0;
      result.az = 0;
      result.baz = 0;
      return result;
    }

    let scolat, slon, ecolat, elon;
    let a, b, c, d, e, aa, bb, cc, dd, ee, g, gg, h, hh, k, kk;
    let rhs1, rhs2, sph, rad, del, daz, dbaz;
    rad = 2. * Math.PI / 360.0;
    /*
     *
     * scolat and ecolat are the geocentric colatitudes
     * as defined by Richter (pg. 318)
     *
     * Earth Flattening of 1/298.257 take from Bott (pg. 3)
     *
     */

    sph = 1.0 / 298.257;
    scolat = Math.PI / 2.0 - Math.atan((1. - sph) * (1. - sph) * Math.tan(lat1 * rad));
    ecolat = Math.PI / 2.0 - Math.atan((1. - sph) * (1. - sph) * Math.tan(lat2 * rad));
    slon = lon1 * rad;
    elon = lon2 * rad;
    /*
     *
     *  a - e are as defined by Bullen (pg. 154, Sec 10.2)
     *     These are defined for the pt. 1
     *
     */

    a = Math.sin(scolat) * Math.cos(slon);
    b = Math.sin(scolat) * Math.sin(slon);
    c = Math.cos(scolat);
    d = Math.sin(slon);
    e = -Math.cos(slon);
    g = -c * e;
    h = c * d;
    k = -Math.sin(scolat);
    /*
     *
     *  aa - ee are the same as a - e, except for pt. 2
     *
     */

    aa = Math.sin(ecolat) * Math.cos(elon);
    bb = Math.sin(ecolat) * Math.sin(elon);
    cc = Math.cos(ecolat);
    dd = Math.sin(elon);
    ee = -Math.cos(elon);
    gg = -cc * ee;
    hh = cc * dd;
    kk = -Math.sin(ecolat);
    /*
     *
     *  Bullen, Sec 10.2, eqn. 4
     *
     */

    del = Math.acos(a * aa + b * bb + c * cc);
    result.delta = del / rad;
    /*
     *
     *  Bullen, Sec 10.2, eqn 7 / eqn 8
     *
     *    pt. 1 is unprimed, so this is technically the baz
     *
     *  Calculate baz this way to avoid quadrant problems
     *
     */

    rhs1 = (aa - d) * (aa - d) + (bb - e) * (bb - e) + cc * cc - 2.;
    rhs2 = (aa - g) * (aa - g) + (bb - h) * (bb - h) + (cc - k) * (cc - k) - 2.;
    dbaz = Math.atan2(rhs1, rhs2);

    if (dbaz < 0.0) {
      dbaz = dbaz + 2 * Math.PI;
    }

    result.baz = dbaz / rad;
    /*
     *
     *  Bullen, Sec 10.2, eqn 7 / eqn 8
     *
     *    pt. 2 is unprimed, so this is technically the az
     *
     */

    rhs1 = (a - dd) * (a - dd) + (b - ee) * (b - ee) + c * c - 2.;
    rhs2 = (a - gg) * (a - gg) + (b - hh) * (b - hh) + (c - kk) * (c - kk) - 2.;
    daz = Math.atan2(rhs1, rhs2);

    if (daz < 0.0) {
      daz = daz + 2 * Math.PI;
    }

    result.az = daz / rad;
    /*
     *
     *   Make sure 0.0 is always 0.0, not 360.
     *
     */

    if (Math.abs(result.baz - 360.) < .00001) result.baz = 0.0;
    if (Math.abs(result.az - 360.) < .00001) result.az = 0.0;
    return result;
  }

  var distaz$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    kmPerDeg: kmPerDeg,
    degtokm: degtokm,
    kmtodeg: kmtodeg,
    distaz: distaz
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** const for json format, json */

  const FORMAT_JSON = 'json';
  /** const for text format, text */

  const FORMAT_TEXT = 'text';
  /** const for geocsv format, geocsv */

  const FORMAT_GEOCSV = 'geocsv';
  /** const for request format, request */

  const FORMAT_REQUEST = 'request';
  /** const of completely empty json, {} */

  const EMPTY_JSON = JSON.parse('{}');
  /**
   * Major version of the FDSN spec supported here.
   * Currently is 1.
   */

  const SERVICE_VERSION = 1;
  /**
   * Service name as used in the FDSN DataCenters registry,
   * http://www.fdsn.org/datacenters
   */

  const SERVICE_NAME = "fdsnws-availability-".concat(SERVICE_VERSION);
  const IRIS_HOST = "service.iris.edu";
  /**
   * Query to a FDSN Availability web service.
   *
   * @see http://www.fdsn.org/webservices/
   *
   * @param host optional host to connect to, defaults to IRIS
   */

  class AvailabilityQuery {
    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */
    constructor(host) {
      this._specVersion = 1;
      this._protocol = checkProtocol();

      if (isNonEmptyStringArg(host)) {
        this._host = host;
      } else {
        this._host = IRIS_HOST;
      }

      this._port = 80;
      this._timeoutSec = 30;
    }
    /**
     * Gets/Sets the version of the fdsnws spec, 1 is currently the only value.
     *  Setting this is probably a bad idea as the code may not be compatible with
     *  the web service.
     *
     * @param value spec version, usually 1
     * @returns the query when setting, the current value when no argument
     */


    specVersion(value) {
      if (hasArgs(value)) {
        this._specVersion = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._specVersion;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the protocol, http or https. This should match the protocol
     *  of the page loaded, but is autocalculated and generally need not be set.
     *
     * @param value protocol, usually http or https
     * @returns the query when setting, the current value when no argument
     */


    protocol(value) {
      if (isStringArg(value)) {
        this._protocol = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._protocol;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the remote host to connect to.
     *
     * @param value host
     * @returns the query when setting, the current value when no argument
     */


    host(value) {
      if (isStringArg(value)) {
        this._host = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._host;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the nodata parameter, usually 404 or 204 (default), controlling
     * the status code when no matching data is found by the service.
     *
     * @param value number for nodata, usually 404 or 204
     * @returns the query when setting, the current value when no argument
     */


    nodata(value) {
      if (hasNoArgs(value)) {
        return this._nodata;
      } else if (hasArgs(value)) {
        this._nodata = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the port, not usually set unless not on standard http or https ports
     *
     * @param value port
     * @returns the query when setting, the current value when no argument
     */


    port(value) {
      if (hasNoArgs(value)) {
        return this._port;
      } else if (hasArgs(value)) {
        this._port = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the network code to check.
     *
     * @param value network code like IU
     * @returns the query when setting, the current value when no argument
     */


    networkCode(value) {
      if (isStringArg(value)) {
        this._networkCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._networkCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the station code to check.
     *
     * @param value station code like ANMO
     * @returns the query when setting, the current value when no argument
     */


    stationCode(value) {
      if (isStringArg(value)) {
        this._stationCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._stationCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the location code to check.
     *
     * @param value location code like 00
     * @returns the query when setting, the current value when no argument
     */


    locationCode(value) {
      if (isStringArg(value)) {
        this._locationCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._locationCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the channel code to check.
     *
     * @param value channel code like BHZ
     * @returns the query when setting, the current value when no argument
     */


    channelCode(value) {
      if (isStringArg(value)) {
        this._channelCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._channelCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the start time parameter for the query.
     *
     * @param value start time
     * @returns the query when setting, the current value when no argument
     */


    startTime(value) {
      if (hasNoArgs(value)) {
        return this._startTime;
      } else if (hasArgs(value)) {
        this._startTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the end time parameter for the query.
     *
     * @param value end time
     * @returns the query when setting, the current value when no argument
     */


    endTime(value) {
      if (hasNoArgs(value)) {
        return this._endTime;
      } else if (hasArgs(value)) {
        this._endTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Sets startTime and endTime using the given time window
     *
     * @param   se time window
     * @returns    the query
     */


    timeWindow(se) {
      this.startTime(se.startTime);
      this.endTime(se.endTime);
      return this;
    }
    /**
     * Gets/Sets the quality parameter for the query.
     *
     * @param value quality
     * @returns the query when setting, the current value when no argument
     */


    quality(value) {
      if (isStringArg(value)) {
        this._quality = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._quality;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the merge parameter for the query.
     *
     * @param value merge
     * @returns the query when setting, the current value when no argument
     */


    merge(value) {
      if (isStringArg(value)) {
        this._merge = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._merge;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the mergegaps parameter for the query.
     *
     * @param value merge gaps
     * @returns the query when setting, the current value when no argument
     */


    mergeGaps(value) {
      if (isNumArg(value)) {
        this._mergeGaps = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._mergeGaps;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the show parameter for the query.
     *
     * @param value show
     * @returns the query when setting, the current value when no argument
     */


    show(value) {
      if (isStringArg(value)) {
        this._show = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._show;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the limit parameter for the query.
     *
     * @param value limit
     * @returns the query when setting, the current value when no argument
     */


    limit(value) {
      if (hasNoArgs(value)) {
        return this._limit;
      } else if (hasArgs(value)) {
        this._limit = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the order by parameter for the query.
     *
     * @param value order by
     * @returns the query when setting, the current value when no argument
     */


    orderby(value) {
      if (isStringArg(value)) {
        this._orderby = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._orderby;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Gets/Sets the include restricted data parameter for the query.
     *
     * @param value true to include restricted data
     * @returns the query when setting, the current value when no argument
     */


    includeRestricted(value) {
      if (hasNoArgs(value)) {
        return this._includerestricted;
      } else if (hasArgs(value)) {
        this._includerestricted = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the format parameter for the query. Usually not needed as is set
     * by the various query methods.
     *
     * @param value format
     * @returns the query when setting, the current value when no argument
     */


    format(value) {
      if (isStringArg(value)) {
        this._format = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._format;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the timeout in seconds for the request. Default is 30.
     *
     * @param value timeout in seconds
     * @returns the query when setting, the current value when no argument
     */


    timeout(value) {
      if (hasNoArgs(value)) {
        return this._timeoutSec;
      } else if (isNumArg(value)) {
        this._timeoutSec = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Calls query on the remote service, using configured parameters. Calls
     * queryJson internally, then unpacks the result into array of SeismogramDisplayData
     * objects.
     *
     * @returns          promise to array of SeismogramDisplayData, each representing
     * a channel-time window
     */


    query() {
      return this.queryJson().then(function (json) {
        return this.extractFromJson(json);
      });
    }
    /**
     * Calls the query function the remote server and parses the returned data as json.
     *
     * @returns promise to the result as json
     */


    queryJson() {
      const mythis = this;
      this.format(FORMAT_JSON);
      const url = this.formURL("query");
      const fetchInit = defaultFetchInitObj(JSON_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(function (response) {
        if (response.status === 204 || mythis.nodata() && response.status === mythis.nodata()) {
          return EMPTY_JSON;
        }

        let contentType = response.headers.get('content-type');

        if (isNonEmptyStringArg(contentType) && contentType.includes(JSON_MIME)) {
          return response.json();
        } // $FlowFixMe


        throw new TypeError("Oops, we did not get JSON! ".concat(contentType));
      });
    }
    /**
     * Calls extent on the remote service, using configured parameters. Calls
     * extentJson internally, then unpacks the result into array of SeismogramDisplayData
     * objects.
     *
     * @returns          promise to array of SeismogramDisplayData, each representing
     * a channel-time window
     */


    extent() {
      return this.extentJson().then(function (json) {
        return this.extractFromJson(json);
      });
    }
    /**
     * Call the extend function on the remote server and parses the returned data as json.
     *
     * @returns promise to the result as json
     */


    extentJson() {
      const mythis = this;
      this.format(FORMAT_JSON);
      const url = this.formURL("extent");
      const fetchInit = defaultFetchInitObj(JSON_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(function (response) {
        if (response.status === 204 || mythis.nodata() && response.status === mythis.nodata()) {
          return EMPTY_JSON;
        }

        let contentType = response.headers.get('content-type');

        if (isNonEmptyStringArg(contentType) && contentType.includes(JSON_MIME)) {
          return response.json();
        } // $FlowFixMe


        throw new TypeError("Oops, we did not get JSON! ".concat(contentType));
      });
    }
    /**
     * Calls query on the remote service using POST, using configured parameters
     * and forms the POST body using the channelTimeList. Calls
     * postQueryJson internally, then unpacks the result into array of SeismogramDisplayData
     * objects.
     *
     * @param channelTimeList array of channel-time windows for the request
     * @returns          promise to array of SeismogramDisplayData, each representing
     * a channel-time window
     */


    postQuery(channelTimeList) {
      return this.postQueryJson(channelTimeList).then(json => {
        return this.extractFromJson(json);
      });
    }

    postExtent(channelTimeList) {
      return this.postExtentJson(channelTimeList).then(json => {
        return this.extractFromJson(json);
      });
    }

    postExtentJson(channelTimeList) {
      return this.postJson(channelTimeList, 'extent');
    }

    postQueryJson(channelTimeList) {
      return this.postJson(channelTimeList, 'query');
    }

    postJson(channelTimeList, method) {
      const mythis = this;
      this.format(FORMAT_JSON);
      return this.postRaw(channelTimeList, method).then(function (response) {
        if (response.status === 204 || mythis.nodata() && response.status === mythis.nodata()) {
          return EMPTY_JSON;
        }

        let contentType = response.headers.get('content-type');

        if (isNonEmptyStringArg(contentType) && contentType.includes(JSON_MIME)) {
          return response.json();
        } // $FlowFixMe


        throw new TypeError("Oops, we did not get JSON! ".concat(contentType));
      });
    }

    postRaw(channelTimeList, method) {
      if (channelTimeList.length === 0) {
        // return promise faking an not ok fetch response
        return RSVP__default.hash({
          ok: false
        });
      } else {
        const fetchInit = defaultFetchInitObj(JSON_MIME);
        fetchInit.method = "POST";
        fetchInit.body = this.createPostBody(channelTimeList);
        return fetch(this.formBaseURL() + "/".concat(method, "?"), fetchInit).then(function (response) {
          if (response.ok) {
            return response;
          }

          throw new Error('Fetch response was not ok.');
        });
      }
    }

    extractFromJson(jsonChanTimes) {
      let out = [];
      let knownNets = new Map();

      if (isDef(jsonChanTimes.datasources)) {
        for (let ds of jsonChanTimes.datasources) {
          let n = knownNets.get(ds.network);

          if (!n) {
            n = new Network(ds.network);
            knownNets.set(ds.network, n);
          }

          let s = null;

          for (let ss of n.stations) {
            if (ss.stationCode === ds.station) {
              s = ss;
            }
          }

          if (!s) {
            s = new Station(n, ds.station);
            n.stations.push(s);
          }

          let c = new Channel(s, ds.channel, ds.locationCode);

          if (isNonEmptyStringArg(ds.earliest) && isNonEmptyStringArg(ds.latest)) {
            out.push(SeismogramDisplayData.fromChannelAndTimes(c, moment__default.utc(ds.earliest), moment__default.utc(ds.latest)));
          } else if (ds.timespans) {
            for (let ts of ds.timespans) {
              out.push(SeismogramDisplayData.fromChannelAndTimes(c, moment__default.utc(ts[0]), moment__default.utc(ts[1])));
            }
          }
        }
      }

      return out;
    }

    createPostBody(channelTimeList) {
      let out = "";

      if (this._quality) {
        out += this.makePostParm("quality", this.quality());
      }

      if (this._merge) {
        out += this.makePostParm("merge", this.merge());
      }

      if (isNumArg(this._mergeGaps) && (this._format === 'query' || this._format === 'queryauth')) {
        out += this.makePostParm("mergegaps", this.mergeGaps());
      }

      if (this._show && (this._format === 'query' || this._format === 'queryauth')) {
        out += this.makePostParm("show", this.show());
      }

      if (isNumArg(this._limit) && this._limit > 0) {
        out += this.makePostParm("limit", this.limit());
      }

      if (this._orderby) {
        out += this.makePostParm("orderby", this.orderby());
      }

      if (this._includerestricted) {
        out += this.makePostParm("includerestricted", this.includeRestricted());
      }

      if (this._format) {
        out += this.makePostParm("format", this.format());
      }

      if (this._nodata) {
        out += this.makePostParm("nodata", this.nodata());
      }

      for (let ct of channelTimeList) {
        if (isDef(ct.channel)) {
          let sta = ct.channel.station;
          let net = sta.network;
          out += "".concat(net.networkCode, " ").concat(sta.stationCode, " ").concat(ct.channel.locationCode, " ").concat(ct.channel.channelCode, " ").concat(ct.startTime.toISOString(), " ").concat(ct.endTime.toISOString());
          out += '\n';
        } else {
          throw new Error("Channel in missing in createPostBody");
        }
      }

      return out;
    }

    formBaseURL() {
      let colon = ":";

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      return this._protocol + colon + "//" + this._host + (this._port === 80 ? "" : ":" + this._port) + "/fdsnws/availability/" + this._specVersion;
    }

    formVersionURL() {
      return this.formBaseURL() + "/version";
    }
    /**
     * Queries the remote web service to get its version
     *
     * @returns Promise to version string
     */


    queryVersion() {
      let url = this.formVersionURL();
      const fetchInit = defaultFetchInitObj(TEXT_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      });
    }

    makePostParm(name, val) {
      return name + "=" + stringify(val) + "\n";
    }

    formURL(method) {
      if (hasNoArgs(method)) {
        method = "query";
      }

      let url = this.formBaseURL() + "/".concat(method, "?");

      if (this._networkCode) {
        url = url + makeParam("net", this.networkCode());
      }

      if (this._stationCode) {
        url = url + makeParam("sta", this.stationCode());
      }

      if (this._locationCode) {
        url = url + makeParam("loc", this.locationCode());
      }

      if (this._channelCode) {
        url = url + makeParam("cha", this.channelCode());
      }

      if (this._startTime) {
        url = url + makeParam("starttime", toIsoWoZ(this.startTime()));
      }

      if (this._endTime) {
        url = url + makeParam("endtime", toIsoWoZ(this.endTime()));
      }

      if (this._quality) {
        url = url + makeParam("quality", this.quality());
      }

      if (this._merge) {
        url = url + makeParam("merge", this.merge());
      }

      if (this._mergeGaps) {
        url = url + makeParam("mergegaps", this.mergeGaps());
      }

      if (this._show) {
        url = url + makeParam("show", this.show());
      }

      if (isNumArg(this._limit) && this._limit > 0) {
        url = url + makeParam("limit", this.limit());
      }

      if (this._orderby) {
        url = url + makeParam("orderby", this.orderby());
      }

      if (this._includerestricted) {
        url = url + makeParam("includerestricted", this.includeRestricted());
      }

      if (this._format) {
        url = url + makeParam("format", this.format());
      }

      if (this._nodata) {
        url = url + makeParam("nodata", this.nodata());
      }

      if (url.endsWith('&') || url.endsWith('?')) {
        url = url.substr(0, url.length - 1); // zap last & or ?
      }

      return url;
    }

  }
  /* The below are slighly modified from json schema to flow autogenerator.
  *
  * */

  /**
   * Root type of availablility json query.
   */

  var fdsnavailability = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FORMAT_JSON: FORMAT_JSON,
    FORMAT_TEXT: FORMAT_TEXT,
    FORMAT_GEOCSV: FORMAT_GEOCSV,
    FORMAT_REQUEST: FORMAT_REQUEST,
    EMPTY_JSON: EMPTY_JSON,
    SERVICE_VERSION: SERVICE_VERSION,
    SERVICE_NAME: SERVICE_NAME,
    IRIS_HOST: IRIS_HOST,
    AvailabilityQuery: AvailabilityQuery
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** const for miniseed format, mseed */

  const FORMAT_MINISEED = 'miniseed';
  /**
   * Major version of the FDSN spec supported here.
   * Currently is 1.
   */

  const SERVICE_VERSION$1 = 1;
  /**
   * Service name as used in the FDSN DataCenters registry,
   * http://www.fdsn.org/datacenters
   */

  const SERVICE_NAME$1 = "fdsnws-dataselect-".concat(SERVICE_VERSION$1);
  /** const for the default IRIS web service host, service.iris.edu */

  const IRIS_HOST$1 = "service.iris.edu";
  /**
   * Query to a FDSN Dataselect web service.
   *
   * @see http://www.fdsn.org/webservices/
   *
   * @param host optional host to connect to, defaults to IRIS
   */

  class DataSelectQuery {
    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */
    constructor(host) {
      this._specVersion = 1;
      this._protocol = checkProtocol();

      if (isNonEmptyStringArg(host)) {
        this._host = host;
      } else {
        this._host = IRIS_HOST$1;
      }

      this._port = 80;
      this._timeoutSec = 30;
    }
    /**
     * Gets/Sets the version of the fdsnws spec, 1 is currently the only value.
     *  Setting this is probably a bad idea as the code may not be compatible with
     *  the web service.
     *
     * @param value spec version, usually 1
     * @returns new value if getting, this if setting
     */


    specVersion(value) {
      if (hasArgs(value)) {
        this._specVersion = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._specVersion;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the protocol, http or https. This should match the protocol
     *  of the page loaded, but is autocalculated and generally need not be set.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    protocol(value) {
      if (isStringArg(value)) {
        this._protocol = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._protocol;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the remote host to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    host(value) {
      if (isStringArg(value)) {
        this._host = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._host;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the nodata parameter, usually 404 or 204 (default), controlling
     * the status code when no matching data is found by the service.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    nodata(value) {
      if (hasNoArgs(value)) {
        return this._nodata;
      } else if (hasArgs(value)) {
        this._nodata = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the remote port to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    port(value) {
      if (hasNoArgs(value)) {
        return this._port;
      } else if (isNumArg(value)) {
        this._port = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the network query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    networkCode(value) {
      if (isStringArg(value)) {
        this._networkCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._networkCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the station query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    stationCode(value) {
      if (isStringArg(value)) {
        this._stationCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._stationCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the location code query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    locationCode(value) {
      if (isStringArg(value)) {
        this._locationCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._locationCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the channel query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    channelCode(value) {
      if (isStringArg(value)) {
        this._channelCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._channelCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the starttime query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    startTime(value) {
      if (hasNoArgs(value)) {
        return this._startTime;
      } else if (hasArgs(value)) {
        this._startTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the endtime query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    endTime(value) {
      if (hasNoArgs(value)) {
        return this._endTime;
      } else if (hasArgs(value)) {
        this._endTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Sets startTime and endTime using the given time window
     *
     * @param   se time window
     * @returns     this
     */


    timeWindow(se) {
      this.startTime(se.startTime);
      this.endTime(se.endTime);
      return this;
    }
    /** Get/Set the quality query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    quality(value) {
      if (isStringArg(value)) {
        this._quality = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._quality;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the minimum length query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minimumLength(value) {
      if (hasNoArgs(value)) {
        return this._minimumLength;
      } else if (hasArgs(value)) {
        this._minimumLength = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the longest only query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    longestOnly(value) {
      if (hasNoArgs(value)) {
        return this._longestOnly;
      } else if (hasArgs(value)) {
        this._longestOnly = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /**
     * set or get the repository paramter. This is an IRIS-specific
     * parameter that will not work with other dataselect web services.
     *
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    repository(value) {
      if (isStringArg(value)) {
        this._repository = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._repository;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the format query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    format(value) {
      if (isStringArg(value)) {
        this._format = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._format;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * Get/Set the timeout in seconds for the request. Default is 30.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    timeout(value) {
      if (hasNoArgs(value)) {
        return this._timeoutSec;
      } else if (isNumArg(value)) {
        this._timeoutSec = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * queries the web service using the configured parameters, parsing the response
     * into miniseed data records.
     *
     * @returns Promise to Array of miniseed.DataRecords
     */


    queryDataRecords() {
      const mythis = this;
      this.format(FORMAT_MINISEED);
      const url = this.formURL();
      const fetchInit = defaultFetchInitObj(MINISEED_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(function (response) {
        if (response.status === 204 || mythis.nodata() && response.status === mythis.nodata()) {
          // no data
          return new ArrayBuffer(0);
        } else {
          return response.arrayBuffer();
        }
      }).then(function (rawBuffer) {
        let dataRecords = parseDataRecords(rawBuffer);
        return dataRecords;
      });
    }
    /**
     * queries the web service using the configured parameters, parsing the response
     * into miniseed data records and then combining the data records into
     * Seismogram objects.
     *
     * @returns Promise to Array of Seismogram objects
     */


    querySeismograms() {
      return this.queryDataRecords().then(dataRecords => {
        return seismogramPerChannel(dataRecords);
      });
    }

    postQueryDataRecords(channelTimeList) {
      return this.postQueryRaw(channelTimeList).then(fetchResponse => {
        if (fetchResponse.ok) {
          return fetchResponse.arrayBuffer().then(ab => {
            return parseDataRecords(ab);
          });
        } else {
          log("fetchRespone not ok");
          return [];
        }
      });
    }
    /**
     * query the dataselect server using post, which allows for multiple
     * channel-timeranges at once. This assumes that there are not multiple
     * time ranges for the same channel as the results, encapsulated as
     * SeismogramDisplayData objects, are returned one seismogram
     * per channel, which may contain gaps. The original channel and timerange are
     * also populated with each result.
     *
     * @param   channelTimeList array of SeismogramDisplayData objects
     * that will be filled in with the resulting seismogram
     * @returns Promise to the input Array of SeismogramDisplayData objects, each with the
     * seismogram containing the data returned from the server
     */


    postQuerySeismograms(channelTimeList) {
      return this.postQueryDataRecords(channelTimeList).then(dataRecords => {
        return seismogramPerChannel(dataRecords);
      }).then(seisArray => {
        for (let ct of channelTimeList) {
          if (isDef(ct.channel)) {
            let channel = ct.channel;
            let codes = channel.codes();
            let seis = seisArray.find(s => s.codes() === codes);

            if (seis) {
              ct.seismogram = seis;
            }
          } else {
            throw new Error("Channel in missing in postQuerySeismograms");
          }
        }

        return channelTimeList;
      });
    }

    postQueryRaw(channelTimeList) {
      if (channelTimeList.length === 0) {
        // return promise faking an not ok fetch response
        return RSVP__default.hash({
          ok: false
        });
      } else {
        const fetchInit = defaultFetchInitObj(MINISEED_MIME);
        fetchInit.method = "POST";
        fetchInit.body = this.createPostBody(channelTimeList);
        return doFetchWithTimeout(this.formURL(), fetchInit, this._timeoutSec * 1000);
      }
    }

    createPostBody(channelTimeList) {
      let out = "";

      for (let ct of channelTimeList) {
        if (isDef(ct.channel)) {
          let channel = ct.channel;
          let sta = channel.station;
          let net = sta.network;
          out += "".concat(net.networkCode, " ").concat(sta.stationCode, " ").concat(channel.locationCode, " ").concat(channel.channelCode, " ").concat(ct.startTime.toISOString(), " ").concat(ct.endTime.toISOString());
          out += '\n';
        } else {
          throw new Error("Channel in missing in createPostBody");
        }
      }

      return out;
    }

    formBaseURL() {
      let colon = ":";

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      return this._protocol + colon + "//" + this._host + (this._port === 80 ? "" : ":" + this._port) + "/fdsnws/dataselect/" + this._specVersion;
    }

    formVersionURL() {
      return this.formBaseURL() + "/version";
    }
    /**
     * Queries the remote web service to get its version
     *
     * @returns Promise to version string
     */


    queryVersion() {
      let url = this.formVersionURL();
      const fetchInit = defaultFetchInitObj(TEXT_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      });
    }

    formURL() {
      let url = this.formBaseURL() + "/query?";

      if (this._networkCode) {
        url = url + makeParam("net", this.networkCode());
      }

      if (this._stationCode) {
        url = url + makeParam("sta", this.stationCode());
      }

      if (this._locationCode) {
        url = url + makeParam("loc", this.locationCode());
      }

      if (this._channelCode) {
        url = url + makeParam("cha", this.channelCode());
      }

      if (this._startTime) {
        url = url + makeParam("starttime", toIsoWoZ(this.startTime()));
      }

      if (this._endTime) {
        url = url + makeParam("endtime", toIsoWoZ(this.endTime()));
      }

      if (this._quality) {
        url = url + makeParam("quality", this.quality());
      }

      if (this._minimumLength) {
        url = url + makeParam("minimumlength", this.minimumLength());
      }

      if (this._repository) {
        url = url + makeParam("repository", this.repository());
      }

      if (this._longestOnly) {
        url = url + makeParam("longestonly", this.longestOnly());
      }

      if (this._format) {
        url = url + makeParam("format", this.format());
      }

      if (this._nodata) {
        url = url + makeParam("nodata", this.nodata());
      }

      if (url.endsWith('&') || url.endsWith('?')) {
        url = url.substr(0, url.length - 1); // zap last & or ?
      }

      return url;
    }

  }
  function createDataSelectQuery(params) {
    if (!params || typeof params !== 'object') {
      throw new Error("params null or not an object");
    }

    let out = new DataSelectQuery();

    if (params.net) {
      out.networkCode(params.net);
    }

    if (params.network) {
      out.networkCode(params.network);
    }

    if (params.networkCode) {
      out.networkCode(params.networkCode);
    }

    if (params.sta) {
      out.stationCode(params.sta);
    }

    if (params.station) {
      out.stationCode(params.station);
    }

    if (params.stationCode) {
      out.stationCode(params.stationCode);
    }

    if (params.loc) {
      out.locationCode(params.loc);
    }

    if (params.location) {
      out.locationCode(params.location);
    }

    if (params.locationCode) {
      out.locationCode(params.locationCode);
    }

    if (params.chan) {
      out.channelCode(params.chan);
    }

    if (params.channel) {
      out.channelCode(params.channel);
    }

    if (params.channelCode) {
      out.channelCode(params.channelCode);
    }

    if (params.start) {
      out.startTime(params.start);
    }

    if (params.starttime) {
      out.startTime(params.starttime);
    }

    if (params.end) {
      out.endTime(params.end);
    }

    if (params.endtime) {
      out.endTime(params.endtime);
    }

    if (params.quality) {
      out.quality(params.quality);
    }

    if (params.minimumlength) {
      out.minimumLength(params.minimumlength);
    }

    if (params.repository) {
      out.repository(params.repository);
    }

    if (params.longestonly) {
      out.longestOnly(params.longestonly);
    }

    if (params.format) {
      out.format(params.format);
    }

    if (params.nodata) {
      out.nodata(params.nodata);
    }

    if (params.host) {
      out.host(params.host);
    }

    if (params.port) {
      out.port(params.port);
    }

    if (params.specVersion) {
      out.specVersion(params.specVersion);
    }

    return out;
  }

  var fdsndataselect = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FORMAT_MINISEED: FORMAT_MINISEED,
    SERVICE_VERSION: SERVICE_VERSION$1,
    SERVICE_NAME: SERVICE_NAME$1,
    IRIS_HOST: IRIS_HOST$1,
    DataSelectQuery: DataSelectQuery,
    createDataSelectQuery: createDataSelectQuery
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * Major version of the FDSN spec supported here.
   * Currently is 1.
   */

  const SERVICE_VERSION$2 = 1;
  /**
   * Service name as used in the FDSN DataCenters registry,
   * http://www.fdsn.org/datacenters
   */

  const SERVICE_NAME$2 = "fdsnws-event-".concat(SERVICE_VERSION$2);
  const FAKE_EMPTY_XML = '<?xml version="1.0"?><q:quakeml xmlns="http://quakeml.org/xmlns/bed/1.2" xmlns:q="http://quakeml.org/xmlns/quakeml/1.2"><eventParameters publicID="quakeml:fake/empty"></eventParameters></q:quakeml>';
  /**
   * Query to a FDSN Event web service.
   *
   * @see http://www.fdsn.org/webservices/
   *
   * @param host optional host to connect to, defaults to USGS
   */

  class EventQuery {
    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */
    constructor(host) {
      this._specVersion = 1;
      this._protocol = checkProtocol();
      this.host(host);

      if (!isNonEmptyStringArg(host)) {
        this._host = USGS_HOST;
      }

      this._port = 80;
      this._timeoutSec = 30;
    }
    /**
     * Gets/Sets the version of the fdsnws spec, 1 is currently the only value.
     *  Setting this is probably a bad idea as the code may not be compatible with
     *  the web service.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    specVersion(value) {
      if (hasArgs(value)) {
        this._specVersion = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._specVersion;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the protocol, http or https. This should match the protocol
     *  of the page loaded, but is autocalculated and generally need not be set.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    protocol(value) {
      if (isStringArg(value)) {
        this._protocol = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._protocol;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the remote host to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    host(value) {
      if (isStringArg(value)) {
        this._host = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._host;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the remote port to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    port(value) {
      if (hasNoArgs(value)) {
        return this._port;
      } else if (isNumArg(value)) {
        this._port = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the nodata parameter, usually 404 or 204 (default), controlling
     * the status code when no matching data is found by the service.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    nodata(value) {
      if (hasNoArgs(value)) {
        return this._nodata;
      } else if (hasArgs(value)) {
        this._nodata = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the eventid query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    eventId(value) {
      if (hasNoArgs(value)) {
        return this._eventId;
      } else if (isStringArg(value)) {
        this._eventId = value;
        return this;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the starttime query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    startTime(value) {
      if (hasNoArgs(value)) {
        return this._startTime;
      } else if (hasArgs(value)) {
        this._startTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the endtime query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    endTime(value) {
      if (hasNoArgs(value)) {
        return this._endTime;
      } else if (hasArgs(value)) {
        this._endTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Sets startTime and endTime using the given time window
     *
     * @param   se time window
     * @returns     this
     */


    timeWindow(se) {
      this.startTime(se.startTime);
      this.endTime(se.endTime);
      return this;
    }
    /**
     * Get/Set the updatedafter query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    updatedAfter(value) {
      if (hasNoArgs(value)) {
        return this._updatedAfter;
      } else if (hasArgs(value)) {
        this._updatedAfter = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the minmag query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minMag(value) {
      if (hasNoArgs(value)) {
        return this._minMag;
      } else if (isNumArg(value)) {
        this._minMag = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the maxmag query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxMag(value) {
      if (hasNoArgs(value)) {
        return this._maxMag;
      } else if (isNumArg(value)) {
        this._maxMag = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the magnitudetype query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    magnitudeType(value) {
      if (hasNoArgs(value)) {
        return this._magnitudeType;
      } else if (isStringArg(value)) {
        this._magnitudeType = value;
        return this;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the mindepth query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minDepth(value) {
      if (hasNoArgs(value)) {
        return this._minDepth;
      } else if (isNumArg(value)) {
        this._minDepth = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the maxdepth query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxDepth(value) {
      if (hasNoArgs(value)) {
        return this._maxDepth;
      } else if (isNumArg(value)) {
        this._maxDepth = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the minlat query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minLat(value) {
      if (hasNoArgs(value)) {
        return this._minLat;
      } else if (isNumArg(value)) {
        this._minLat = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the maxlat query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxLat(value) {
      if (hasNoArgs(value)) {
        return this._maxLat;
      } else if (isNumArg(value)) {
        this._maxLat = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the minlon query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minLon(value) {
      if (hasNoArgs(value)) {
        return this._minLon;
      } else if (isNumArg(value)) {
        this._minLon = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the maxlon query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxLon(value) {
      if (hasNoArgs(value)) {
        return this._maxLon;
      } else if (isNumArg(value)) {
        this._maxLon = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the latitude query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    latitude(value) {
      if (hasNoArgs(value)) {
        return this._latitude;
      } else if (isNumArg(value)) {
        this._latitude = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the longitude query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    longitude(value) {
      if (hasNoArgs(value)) {
        return this._longitude;
      } else if (isNumArg(value)) {
        this._longitude = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the minradius query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minRadius(value) {
      if (hasNoArgs(value)) {
        return this._minRadius;
      } else if (isNumArg(value)) {
        this._minRadius = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the maxradius query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxRadius(value) {
      if (hasNoArgs(value)) {
        return this._maxRadius;
      } else if (isNumArg(value)) {
        this._maxRadius = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the includearrivals query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    includeArrivals(value) {
      if (hasNoArgs(value)) {
        return this._includeArrivals;
      } else if (hasArgs(value)) {
        this._includeArrivals = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the includeallorigins query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    includeAllOrigins(value) {
      if (hasNoArgs(value)) {
        return this._includeAllOrigins;
      } else if (hasArgs(value)) {
        this._includeAllOrigins = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the includeallmagnitudes query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    includeAllMagnitudes(value) {
      if (hasNoArgs(value)) {
        return this._includeAllMagnitudes;
      } else if (hasArgs(value)) {
        this._includeAllMagnitudes = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the format query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    format(value) {
      if (hasNoArgs(value)) {
        return this._format;
      } else if (isStringArg(value)) {
        this._format = value;
        return this;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the limit query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    limit(value) {
      if (hasNoArgs(value)) {
        return this._limit;
      } else if (isNumArg(value)) {
        this._limit = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the offset query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    offset(value) {
      if (hasNoArgs(value)) {
        return this._offset;
      } else if (isNumArg(value)) {
        this._offset = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the orderby query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    orderBy(value) {
      if (hasNoArgs(value)) {
        return this._orderBy;
      } else if (isStringArg(value)) {
        this._orderBy = value;
        return this;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the catalog query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    catalog(value) {
      if (hasNoArgs(value)) {
        return this._catalog;
      } else if (isStringArg(value)) {
        this._catalog = value;
        return this;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the contributor query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    contributor(value) {
      if (hasNoArgs(value)) {
        return this._contributor;
      } else if (isStringArg(value)) {
        this._contributor = value;
        return this;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the timeout in seconds for the request. Default is 30.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    timeout(value) {
      if (hasNoArgs(value)) {
        return this._timeoutSec;
      } else if (isNumArg(value)) {
        this._timeoutSec = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Checks to see if any parameter that would limit the data
     * returned is set. This is a crude, coarse check to make sure
     * the client doesn't ask for EVERYTHING the server has.
     *
     * @returns true is some parameter is set
     */


    isSomeParameterSet() {
      return isDef(this._eventId) || isDef(this._startTime) || isDef(this._endTime) || isDef(this._minLat) || isDef(this._maxLat) || isDef(this._minLon) || isDef(this._maxLon) || isDef(this._latitude) || isDef(this._longitude) || isDef(this._minRadius) || isDef(this._maxRadius) || isDef(this.minDepth) || isDef(this.maxDepth) || isDef(this.limit) || isDef(this.minMag) || isDef(this.maxMag) || isDef(this.updatedAfter) || isDef(this.catalog) || isDef(this.contributor);
    }
    /**
     * Queries the remote service and parses the returned xml.
     *
     *  @returns Promise to an Array of Quake objects.
     */


    query() {
      return this.queryRawXml().then(rawXml => {
        return parseQuakeML(rawXml, this._host);
      });
    }
    /**
     * Queries the remote server, to get QuakeML xml.
     *
     * @returns xml Document
     */


    queryRawXml() {
      let mythis = this;
      const url = this.formURL();
      const fetchInit = defaultFetchInitObj(XML_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else if (response.status === 204 || mythis.nodata() && response.status === mythis.nodata()) {
          // 204 is nodata, so successful but empty
          return FAKE_EMPTY_XML;
        } else {
          throw new Error("Status not successful: ".concat(response.status));
        }
      }).then(function (rawXmlText) {
        return new DOMParser().parseFromString(rawXmlText, XML_MIME);
      });
    }
    /**
     * Forms the basic URL to contact the web service, without any query paramters
     *
     * @returns the url
     */


    formBaseURL() {
      let colon = ":";

      if (!this.host || this._host === USGS_HOST) {
        this._host = USGS_HOST; // usgs does 301 moved permanently to https

        this._protocol = 'https:';
      }

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      return this._protocol + colon + "//" + this._host + (this._port === 80 ? "" : ":" + this._port) + "/fdsnws/event/" + this._specVersion;
    }
    /**
     * Forms the URL to get catalogs from the web service, without any query paramters
     *
     * @returns the url
     */


    formCatalogsURL() {
      return this.formBaseURL() + "/catalogs";
    }
    /**
     * Queries the remote web service to get known catalogs
     *
     * @returns Promise to Array of catalog names
     */


    queryCatalogs() {
      let mythis = this;
      let url = mythis.formCatalogsURL();
      const fetchInit = defaultFetchInitObj(XML_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      }).then(function (rawXmlText) {
        return new DOMParser().parseFromString(rawXmlText, XML_MIME);
      }).then(function (rawXml) {
        // for flow
        if (!rawXml) {
          throw new Error("raw xml from DOMParser is null.");
        }

        let top = rawXml.documentElement; // for flow

        if (!top) {
          throw new Error("documentElement in xml from DOMParser is null.");
        }

        let catalogArray = top.getElementsByTagName("Catalog");
        let out = [];

        if (catalogArray) {
          for (let i = 0; i < catalogArray.length; i++) {
            // for flow
            let item = catalogArray.item(i);

            if (item) {
              out.push(item.textContent);
            }
          }
        }

        return out;
      });
    }
    /**
     * Forms the URL to get contributors from the web service, without any query paramters
     *
     * @returns the url
     */


    formContributorsURL() {
      return this.formBaseURL() + "/contributors";
    }
    /**
     * Queries the remote web service to get known contributors
     *
     * @returns Promise to Array of contributor names
     */


    queryContributors() {
      let url = this.formContributorsURL();
      const fetchInit = defaultFetchInitObj(XML_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      }).then(function (rawXmlText) {
        return new DOMParser().parseFromString(rawXmlText, XML_MIME);
      }).then(function (rawXml) {
        let top = rawXml.documentElement; // for flow

        if (!top) {
          throw new Error("documentElement in xml from DOMParser is null.");
        }

        let contributorArray = top.getElementsByTagName("Contributor");
        let out = [];

        if (contributorArray) {
          for (let i = 0; i < contributorArray.length; i++) {
            // for flow
            let item = contributorArray.item(i);

            if (item) {
              out.push(item.textContent);
            }
          }
        }

        return out;
      });
    }
    /**
     * Forms the URL to get version from the web service, without any query paramters
     *
     * @returns the url
     */


    formVersionURL() {
      return this.formBaseURL() + "/version";
    }
    /**
     * Queries the remote web service to get its version
     *
     * @returns Promise to version string
     */


    queryVersion() {
      let url = this.formVersionURL();
      const fetchInit = defaultFetchInitObj(TEXT_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      });
    }
    /**
     * Form URL to query the remote web service, encoding the query parameters.
     *
     * @returns url
     */


    formURL() {
      let colon = ":";

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      let url = this.formBaseURL() + "/query?";

      if (this._eventId) {
        url = url + makeParam("eventid", this.eventId());
      }

      if (this._startTime) {
        url = url + makeParam("starttime", toIsoWoZ(this.startTime()));
      }

      if (this._endTime) {
        url = url + makeParam("endtime", toIsoWoZ(this.endTime()));
      }

      if (isNumArg(this._minMag)) {
        url = url + makeParam("minmag", this.minMag());
      }

      if (isNumArg(this._maxMag)) {
        url = url + makeParam("maxmag", this.maxMag());
      }

      if (isStringArg(this._magnitudeType)) {
        url = url + makeParam("magnitudetype", this.magnitudeType());
      }

      if (isNumArg(this._minDepth)) {
        url = url + makeParam("mindepth", this.minDepth());
      }

      if (isNumArg(this._maxDepth)) {
        url = url + makeParam("maxdepth", this.maxDepth());
      }

      if (isNumArg(this._minLat)) {
        url = url + makeParam("minlat", this.minLat());
      }

      if (isNumArg(this._maxLat)) {
        url = url + makeParam("maxlat", this.maxLat());
      }

      if (isNumArg(this._minLon)) {
        url = url + makeParam("minlon", this.minLon());
      }

      if (isNumArg(this._maxLon)) {
        url = url + makeParam("maxlon", this.maxLon());
      }

      if (isNumArg(this._minRadius) || isNumArg(this._maxRadius)) {
        if (isNumArg(this._latitude) && isNumArg(this._longitude)) {
          url = url + makeParam("latitude", this.latitude()) + makeParam("longitude", this.longitude());

          if (isNumArg(this._minRadius)) {
            url = url + makeParam("minradius", this.minRadius());
          }

          if (isNumArg(this._maxRadius)) {
            url = url + makeParam("maxradius", this.maxRadius());
          }
        } else {
          throw new Error("Cannot use minRadius or maxRadius without latitude and longitude: lat=" + this._latitude + " lon=" + this._longitude);
        }
      }

      if (this._includeArrivals) {
        if (this._host !== USGS_HOST) {
          url = url + "includearrivals=true&";
        } else {
          // USGS does not support includearrivals, but does actually
          // include the arrivals for an eventid= style query
          if (this._eventId) ; else {
            throw new Error("USGS host, earthquake.usgs.gov, does not support includearrivals parameter.");
          }
        }
      }

      if (isObject(this._updatedAfter)) {
        url = url + makeParam("updatedafter", this.updatedAfter());
      }

      if (isDef(this._includeAllOrigins)) {
        url = url + makeParam("includeallorigins", this.includeAllOrigins());
      }

      if (isDef(this._includeAllMagnitudes)) {
        url = url + makeParam("includeallmagnitudes", this.includeAllMagnitudes());
      }

      if (isStringArg(this._format)) {
        url = url + makeParam("format", this.format());
      }

      if (isNumArg(this._limit)) {
        url = url + makeParam("limit", this.limit());
      }

      if (isNumArg(this._offset)) {
        url = url + makeParam("offset", this.offset());
      }

      if (isStringArg(this._orderBy)) {
        url = url + makeParam("orderby", this.orderBy());
      }

      if (isStringArg(this._catalog)) {
        url = url + makeParam("catalog", this.catalog());
      }

      if (isStringArg(this._contributor)) {
        url = url + makeParam("contributor", this.contributor());
      }

      if (isDef(this._nodata)) {
        url = url + makeParam("nodata", this.nodata());
      }

      if (url.endsWith('&') || url.endsWith('?')) {
        url = url.substr(0, url.length - 1); // zap last & or ?
      }

      return url;
    }

  }

  var fdsnevent = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SERVICE_VERSION: SERVICE_VERSION$2,
    SERVICE_NAME: SERVICE_NAME$2,
    USGS_HOST: USGS_HOST,
    FAKE_EMPTY_XML: FAKE_EMPTY_XML,
    EventQuery: EventQuery
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const LEVEL_NETWORK = 'network';
  const LEVEL_STATION = 'station';
  const LEVEL_CHANNEL = 'channel';
  const LEVEL_RESPONSE = 'response';
  const LEVELS = [LEVEL_NETWORK, LEVEL_STATION, LEVEL_CHANNEL, LEVEL_RESPONSE];
  /**
   * Major version of the FDSN spec supported here.
   * Currently is 1.
   */

  const SERVICE_VERSION$3 = 1;
  /**
   * Service name as used in the FDSN DataCenters registry,
   * http://www.fdsn.org/datacenters
   */

  const SERVICE_NAME$3 = "fdsnws-station-".concat(SERVICE_VERSION$3);
  const IRIS_HOST$2 = "service.iris.edu";
  /** a fake, completely empty stationxml document in case of no data. */

  const FAKE_EMPTY_XML$1 = '<?xml version="1.0" encoding="ISO-8859-1"?> <FDSNStationXML xmlns="http://www.fdsn.org/xml/station/1" schemaVersion="1.0" xsi:schemaLocation="http://www.fdsn.org/xml/station/1 http://www.fdsn.org/xml/station/fdsn-station-1.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:iris="http://www.fdsn.org/xml/station/1/iris"> </FDSNStationXML>';
  /**
   * Query to a FDSN Station web service.
   *
   * @see http://www.fdsn.org/webservices/
   *
   * @param host optional host to connect to, defaults to IRIS
   */

  class StationQuery {
    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** Construct a query
     *
     * @param host the host to connect to , defaults to service.iris.edu
     */
    constructor(host) {
      this._specVersion = 1;
      this._protocol = checkProtocol();
      this.host(host);

      if (!isNonEmptyStringArg(host)) {
        this._host = IRIS_HOST$2;
      }

      this._port = 80;
      this._timeoutSec = 30;
    }
    /** Gets/Sets the version of the fdsnws spec, 1 is currently the only value.
     *  Setting this is probably a bad idea as the code may not be compatible with
     *  the web service.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    specVersion(value) {
      if (hasArgs(value)) {
        this._specVersion = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._specVersion;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Gets/Sets the protocol, http or https. This should match the protocol
     *  of the page loaded, but is autocalculated and generally need not be set.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    protocol(value) {
      if (isStringArg(value)) {
        this._protocol = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._protocol;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /** Gets/Sets the remote host to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    host(value) {
      if (isStringArg(value)) {
        this._host = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._host;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /** Gets/Sets the remote port to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    port(value) {
      if (hasNoArgs(value)) {
        return this._port;
      } else if (isNumArg(value)) {
        this._port = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Gets/Sets the nodata parameter, usually 404 or 204 (default), controlling
     * the status code when no matching data is found by the service.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    nodata(value) {
      if (hasNoArgs(value)) {
        return this._nodata;
      } else if (hasArgs(value)) {
        this._nodata = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the network query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    networkCode(value) {
      if (isStringArg(value)) {
        this._networkCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._networkCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the station query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    stationCode(value) {
      if (isStringArg(value)) {
        this._stationCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._stationCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the location code query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    locationCode(value) {
      if (isStringArg(value)) {
        this._locationCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._locationCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the channel query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    channelCode(value) {
      if (isStringArg(value)) {
        this._channelCode = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._channelCode;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the starttime query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    startTime(value) {
      if (hasNoArgs(value)) {
        return this._startTime;
      } else if (hasArgs(value)) {
        this._startTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the endtime query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    endTime(value) {
      if (hasNoArgs(value)) {
        return this._endTime;
      } else if (hasArgs(value)) {
        this._endTime = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /**
     * Sets startTime and endTime using the given time window
     *
     * @param   se time window
     * @returns     this
     */


    timeWindow(se) {
      this.startTime(se.startTime);
      this.endTime(se.endTime);
      return this;
    }
    /** Get/Set the startbefore query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    startBefore(value) {
      if (hasNoArgs(value)) {
        return this._startBefore;
      } else if (hasArgs(value)) {
        this._startBefore = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the endbefore query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    endBefore(value) {
      if (hasNoArgs(value)) {
        return this._endBefore;
      } else if (hasArgs(value)) {
        this._endBefore = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the startafter query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    startAfter(value) {
      if (hasNoArgs(value)) {
        return this._startAfter;
      } else if (hasArgs(value)) {
        this._startAfter = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the endafter query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    endAfter(value) {
      if (hasNoArgs(value)) {
        return this._endAfter;
      } else if (hasArgs(value)) {
        this._endAfter = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the minlat query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minLat(value) {
      if (hasNoArgs(value)) {
        return this._minLat;
      } else if (isNumArg(value)) {
        this._minLat = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the maxlon query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxLat(value) {
      if (hasNoArgs(value)) {
        return this._maxLat;
      } else if (isNumArg(value)) {
        this._maxLat = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the minlon query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minLon(value) {
      if (hasNoArgs(value)) {
        return this._minLon;
      } else if (isNumArg(value)) {
        this._minLon = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the maxlon query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxLon(value) {
      if (hasNoArgs(value)) {
        return this._maxLon;
      } else if (isNumArg(value)) {
        this._maxLon = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the latitude query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    latitude(value) {
      if (hasNoArgs(value)) {
        return this._latitude;
      } else if (isNumArg(value)) {
        this._latitude = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the longitude query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    longitude(value) {
      if (hasNoArgs(value)) {
        return this._longitude;
      } else if (isNumArg(value)) {
        this._longitude = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the minradius query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    minRadius(value) {
      if (hasNoArgs(value)) {
        return this._minRadius;
      } else if (isNumArg(value)) {
        this._minRadius = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the maxradius query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    maxRadius(value) {
      if (hasNoArgs(value)) {
        return this._maxRadius;
      } else if (isNumArg(value)) {
        this._maxRadius = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Get/Set the includerestricted query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    includeRestricted(value) {
      if (hasNoArgs(value)) {
        return this._includeRestricted;
      } else if (hasArgs(value)) {
        this._includeRestricted = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /** Get/Set the includeavailability query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    includeAvailability(value) {
      if (hasNoArgs(value)) {
        return this._includeAvailability;
      } else if (hasArgs(value)) {
        this._includeAvailability = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /** Get/Set the format query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    format(value) {
      if (isStringArg(value)) {
        this._format = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._format;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /** Get/Set the updatedafter query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    updatedAfter(value) {
      if (hasNoArgs(value)) {
        return this._updatedAfter;
      } else if (hasArgs(value)) {
        this._updatedAfter = checkStringOrDate(value);
        return this;
      } else {
        throw new Error('value argument is optional or moment or string, but was ' + typeof value);
      }
    }
    /** Get/Set the matchtimeseries query parameter.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    matchTimeseries(value) {
      if (hasNoArgs(value)) {
        return this._matchTimeseries;
      } else if (hasArgs(value)) {
        this._matchTimeseries = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /** Get/Set the timeout in seconds for the request. Default is 30.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    timeout(value) {
      if (hasNoArgs(value)) {
        return this._timeoutSec;
      } else if (isNumArg(value)) {
        this._timeoutSec = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Checks to see if any parameter that would limit the data
     * returned is set. This is a crude, coarse check to make sure
     * the client doesn't ask for EVERYTHING the server has.
     *
     * @returns true if some parameter set
     * */


    isSomeParameterSet() {
      return isDef(this._networkCode) || isDef(this._stationCode) || isDef(this._locationCode) || isDef(this._channelCode) || isDef(this._startTime) || isDef(this._endTime) || isDef(this._startBefore) || isDef(this._endBefore) || isDef(this._startAfter) || isDef(this._endAfter) || isDef(this._minLat) || isDef(this._maxLat) || isDef(this._minLon) || isDef(this._maxLon) || isDef(this._latitude) || isDef(this._longitude) || isDef(this._minRadius) || isDef(this._maxRadius) || isDef(this._updatedAfter);
    }
    /**
     * Queries the remote web service for networks.
     *
     * @returns a Promise to an Array of Network objects.
     */


    queryNetworks() {
      return this.query(LEVEL_NETWORK);
    }
    /**
     * Queries the remote web service for stations. The stations
     * are contained within their respective Networks.
     *
     * @returns a Promise to an Array of Network objects.
     */


    queryStations() {
      return this.query(LEVEL_STATION);
    }
    /**
     * Queries the remote web service for channels. The Channels
     * are contained within their respective Stations which are in Networks.
     *
     * @returns a Promise to an Array of Network objects.
     */


    queryChannels() {
      return this.query(LEVEL_CHANNEL);
    }
    /**
     * Queries the remote web service for responses. The Responses
     * are contained within their respective Channels,
     * which are in Stations which are in Networks.
     *
     * @returns a Promise to an Array of Network objects.
     */


    queryResponses() {
      return this.query(LEVEL_RESPONSE);
    }
    /**
     * Queries the remote web service at the given level.
     *
     * @param level the level to query at, networ, station, channel or response.
     * @returns a Promise to an Array of Network objects.
     */


    query(level) {
      if (!LEVELS.includes(level)) {
        throw new Error("Unknown level: '" + level + "'");
      }

      return this.queryRawXml(level).then(function (rawXml) {
        return parseStationXml(rawXml);
      });
    }
    /**
     * Queries the remote web service at the given level for raw xml.
     *
     * @param level the level to query at, network, station, channel or response.
     * @returns a Promise to an xml Document.
     */


    queryRawXml(level) {
      const mythis = this;
      const url = this.formURL(level);
      const fetchInit = defaultFetchInitObj(XML_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else if (response.status === 204 || mythis.nodata() && response.status === mythis.nodata()) {
          // 204 is nodata, so successful but empty
          return FAKE_EMPTY_XML$1;
        } else {
          throw new Error("Status not successful: ".concat(response.status));
        }
      }).then(function (rawXmlText) {
        return new DOMParser().parseFromString(rawXmlText, "text/xml");
      });
    }
    /**
     * Forms the URL to get version from the web service, without any query paramters
     *
     * @returns the url
     */


    formVersionURL() {
      return this.formBaseURL() + "/version";
    }
    /**
     * Queries the remote web service to get its version
     *
     * @returns Promise to version string
     */


    queryVersion() {
      let url = this.formVersionURL();
      const fetchInit = defaultFetchInitObj(TEXT_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      });
    }
    /**
     * Forms the basic URL to contact the web service, without any query paramters
     *
     * @returns the url
     */


    formBaseURL() {
      let colon = ":";

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      return this._protocol + colon + "//" + this._host + (this._port === 80 ? "" : ":" + this._port) + "/fdsnws/station/" + this._specVersion;
    }
    /**
     * Form URL to query the remote web service, encoding the query parameters.
     *
     * @param level network, station, channel or response
     * @returns url
     */


    formURL(level) {
      let url = this.formBaseURL() + "/query?";

      if (!isStringArg(level)) {
        throw new Error("level not specified, should be one of network, station, channel, response.");
      }

      url = url + makeParam("level", level);

      if (isStringArg(this._networkCode)) {
        url = url + makeParam("net", this.networkCode());
      }

      if (isStringArg(this._stationCode)) {
        url = url + makeParam("sta", this.stationCode());
      }

      if (isStringArg(this._locationCode)) {
        url = url + makeParam("loc", this.locationCode());
      }

      if (isStringArg(this._channelCode)) {
        url = url + makeParam("cha", this.channelCode());
      }

      if (isObject(this._startTime)) {
        url = url + makeParam("starttime", toIsoWoZ(this.startTime()));
      }

      if (isObject(this._endTime)) {
        url = url + makeParam("endtime", toIsoWoZ(this.endTime()));
      }

      if (isObject(this._startBefore)) {
        url = url + makeParam("startbefore", toIsoWoZ(this.startBefore()));
      }

      if (isObject(this._startAfter)) {
        url = url + makeParam("startafter", toIsoWoZ(this.startAfter()));
      }

      if (isObject(this._endBefore)) {
        url = url + makeParam("endbefore", toIsoWoZ(this.endBefore()));
      }

      if (isObject(this._endAfter)) {
        url = url + makeParam("endafter", toIsoWoZ(this.endAfter()));
      }

      if (isNumArg(this._minLat)) {
        url = url + makeParam("minlat", this.minLat());
      }

      if (isNumArg(this._maxLat)) {
        url = url + makeParam("maxlat", this.maxLat());
      }

      if (isNumArg(this._minLon)) {
        url = url + makeParam("minlon", this.minLon());
      }

      if (isNumArg(this._maxLon)) {
        url = url + makeParam("maxlon", this.maxLon());
      }

      if (isNumArg(this._latitude)) {
        url = url + makeParam("lat", this.latitude());
      }

      if (isNumArg(this._longitude)) {
        url = url + makeParam("lon", this.longitude());
      }

      if (isNumArg(this._minRadius)) {
        url = url + makeParam("minradius", this.minRadius());
      }

      if (isNumArg(this._maxRadius)) {
        url = url + makeParam("maxradius", this.maxRadius());
      }

      if (isDef(this._includeRestricted)) {
        url = url + makeParam("includerestricted", this.includeRestricted());
      }

      if (isDef(this._includeAvailability)) {
        url = url + makeParam("includeavailability", this.includeAvailability());
      }

      if (isObject(this._updatedAfter)) {
        url = url + makeParam("updatedafter", toIsoWoZ(this.updatedAfter()));
      }

      if (isDef(this._matchTimeseries)) {
        url = url + makeParam("matchtimeseries", this.matchTimeseries());
      }

      if (isStringArg(this._format)) {
        url = url + makeParam("format", this.format());
      }

      if (isNumArg(this._nodata)) {
        url = url + makeParam("nodata", this.nodata());
      }

      if (url.endsWith('&') || url.endsWith('?')) {
        url = url.substr(0, url.length - 1); // zap last & or ?
      }

      return url;
    }

  }

  var fdsnstation = /*#__PURE__*/Object.freeze({
    __proto__: null,
    LEVEL_NETWORK: LEVEL_NETWORK,
    LEVEL_STATION: LEVEL_STATION,
    LEVEL_CHANNEL: LEVEL_CHANNEL,
    LEVEL_RESPONSE: LEVEL_RESPONSE,
    LEVELS: LEVELS,
    SERVICE_VERSION: SERVICE_VERSION$3,
    SERVICE_NAME: SERVICE_NAME$3,
    IRIS_HOST: IRIS_HOST$2,
    FAKE_EMPTY_XML: FAKE_EMPTY_XML$1,
    StationQuery: StationQuery
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** const for fdsn web service host, www.fdsn.org */

  const FDSN_HOST = "www.fdsn.org";
  /**
   * Query to a FDSN Data Centers Registry web service.
   *
   * @see http://www.fdsn.org/webservices/
   *
   * @param host optional host to connect to, defaults to FDSN
   */

  class DataCentersQuery {
    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */
    constructor(host) {
      this._specVersion = 1;
      this._protocol = checkProtocol();

      if (isNonEmptyStringArg(host)) {
        this._host = host;
      } else {
        this._host = FDSN_HOST;
      }

      this._port = 80;
      this._timeoutSec = 30;
    }
    /** Gets/Sets the version of the fdsnws spec, 1 is currently the only value.
     *  Setting this is probably a bad idea as the code may not be compatible with
     *  the web service.
     *
     * @param value optional new value if setting
     * @returns the query when setting, the current value os services if no arguments
     */


    specVersion(value) {
      if (hasArgs(value)) {
        this._specVersion = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._specVersion;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /** Gets/Sets the protocol, http or https. This should match the protocol
     *  of the page loaded, but is autocalculated and generally need not be set.
     *
     * @param value optional new value if setting
     * @returns the query when setting, the current value os services if no arguments
     */


    protocol(value) {
      if (isStringArg(value)) {
        this._protocol = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._protocol;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /** Gets/Sets the remote host to connect to. This defaults to
     * www.fdsn.org and generally should not be set.
     *
     * @param value optional new value if setting
     * @returns the query when setting, the current value os services if no arguments
     */


    host(value) {
      if (isStringArg(value)) {
        this._host = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._host;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /** Gets/Sets the remote port to connect to. This defaults to
     * the standard port for the protocol and generally should not be set.
     *
     * @param value optional new value if setting
     * @returns the query when setting, the current value os services if no arguments
     */


    port(value) {
      if (hasNoArgs(value)) {
        return this._port;
      } else if (hasArgs(value)) {
        this._port = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * limits results to the named data center, default is all data centers
     *
     * @param   value names to search for
     * @returns the query when setting, the current value os services if no arguments
     */


    name(value) {
      if (isStringArg(value)) {
        this._name = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._name;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * limits results to services that match the glob style pattern
     *
     * @param  value glob style pattern to match against
     * @returns the query when setting, the current value os services if no arguments
     */


    services(value) {
      if (isStringArg(value)) {
        this._services = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._services;
      } else {
        throw new Error('value argument is optional or string, but was ' + value);
      }
    }
    /**
     * whether the results include detailed information about
     * the data sets offered by each center, default is false
     *
     * @param  value true to include datasets
     * @returns the query when setting, the current value os services if no arguments
     */


    includeDataSets(value) {
      if (hasNoArgs(value)) {
        return this._includedatasets;
      } else if (hasArgs(value)) {
        this._includedatasets = value;
        return this;
      } else {
        throw new Error('value argument is optional or boolean, but was ' + typeof value);
      }
    }
    /** Get/Set the timeout in seconds for the request. Default is 30.
     *
     * @param  value timeout seconds
     * @returns the query when setting, the current value os services if no arguments
     */


    timeout(value) {
      if (hasNoArgs(value)) {
        return this._timeoutSec;
      } else if (isNumArg(value)) {
        this._timeoutSec = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * queries the fdsn registry web service, returning the result as a parsed json object.
     *
     * @returns Promise to the json object.
     */


    queryJson() {
      const url = this.formURL();
      const fetchInit = defaultFetchInitObj(JSON_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(function (response) {
        let contentType = response.headers.get('content-type');

        if (isNonEmptyStringArg(contentType) && contentType.includes(JSON_MIME)) {
          return response.json();
        } // $FlowFixMe


        throw new TypeError("Oops, we did not get JSON! ".concat(contentType));
      });
    }
    /**
     * queries the registry to find fdsn availability compatible web services within
     * a datacenter of the given name, optionally within the repository with
     * the repo name.
     *
     * @param   name     datacenter name
     * @param   repoName optional repository name
     * @returns           Promise to Array of fdsnavailability.AvailabilityQuery objects
     */


    findFdsnAvailability(name, repoName) {
      if (name && name.length > 0) {
        this.name(name);
      }

      this.services(SERVICE_NAME);
      return this.queryJson().then(json => {
        let out = this.extractCompatibleServices(json, SERVICE_NAME, repoName);
        return out.map(service => {
          let url = new URL(service.url);
          let q = new AvailabilityQuery(url.hostname);

          if (url.port && url.port.length > 0) {
            q.port(Number.parseInt(url.port));
          }

          return q;
        });
      });
    }
    /**
     * queries the registry to find fdsn dataselect compatible web services within
     * a datacenter of the given name, optionally within the repository with
     * the repo name.
     *
     * @param   name     datacenter name
     * @param   repoName optional repository name
     * @returns           Promise to Array of fdsndataselect.DataSelectQuery objects
     */


    findFdsnDataSelect(name, repoName) {
      if (name && name.length > 0) {
        this.name(name);
      }

      this.services(SERVICE_NAME$1);
      return this.queryJson().then(json => {
        let out = this.extractCompatibleServices(json, SERVICE_NAME$1, repoName);
        return out.map(service => {
          let url = new URL(service.url);
          let q = new DataSelectQuery(url.hostname);

          if (url.port && url.port.length > 0) {
            q.port(Number.parseInt(url.port));
          }

          return q;
        });
      });
    }
    /**
     * queries the registry to find a fdsn event compatible web services within
     * a datacenter of the given name, optionally within the repository with
     * the repo name.
     *
     * @param   dcname     datacenter name
     * @param   repoName optional repository name
     * @returns           Promise to Array of fdsnevent.EventQuery objects
     */


    findFdsnEvent(dcname, repoName) {
      if (dcname && dcname.length > 0) {
        this.name(dcname);
      }

      this.services(SERVICE_NAME$2);
      return this.queryJson().then(json => {
        let out = this.extractCompatibleServices(json, SERVICE_NAME$2, repoName);
        return out.map(service => {
          let url = new URL(service.url);
          let q = new EventQuery(url.hostname);

          if (url.port && url.port.length > 0) {
            q.port(Number.parseInt(url.port));
          }

          return q;
        });
      });
    }
    /**
     * queries the registry to find a fdsn station compatible web services within
     * a datacenter of the given name, optionally within the repository with
     * the repo name.
     *
     * @param   dcname     datacenter name
     * @param   repoName optional repository name
     * @returns           Promise to Array of fdsnstation.StationQuery objects
     */


    findFdsnStation(dcname, repoName) {
      if (dcname && dcname.length > 0) {
        this.name(dcname);
      }

      this.services(SERVICE_NAME$3);
      return this.queryJson().then(json => {
        let out = this.extractCompatibleServices(json, SERVICE_NAME$3, repoName);
        return out.map(service => {
          let url = new URL(service.url);
          let q = new StationQuery(url.hostname);

          if (url.port && url.port.length > 0) {
            q.port(Number.parseInt(url.port));
          }

          return q;
        });
      });
    }
    /**
     * Extracts services comaptible with the given service name, optionally within
     * the given repository, from the json.
     *
     * @param   json           json containing services
     * @param   compatibleName service name to be compatible with
     * @param   repoName       optional repository within the json to search
     * @returns                array of services found
     */


    extractCompatibleServices(json, compatibleName, repoName) {
      let out = [];
      json.datacenters.forEach(dc => {
        dc.repositories.forEach(repo => {
          if (!isDef(repoName) || repoName === repo.name) {
            repo.services.forEach(service => {
              if (service.name === compatibleName || isDef(service.compatibleWith) && service.compatibleWith.includes(compatibleName)) {
                out.push(service);
              }
            });
          }
        });
      });
      return out;
    }
    /**
     * Forms the base of the url for accessing the datacenters service.
     *
     * @returns         URL
     */


    formBaseURL() {
      let colon = ":";

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      return this._protocol + colon + "//" + this._host + (this._port === 80 ? "" : ":" + this._port) + "/ws/datacenters/" + this._specVersion;
    }
    /**
     * Forms version url, not part of spec and so may not be supported.
     *
     * @returns         version
     */


    formVersionURL() {
      return this.formBaseURL() + "/version";
    }
    /** Queries the remote web service to get its version
     *
     * @returns Promise to version string
     */


    queryVersion() {
      let url = this.formVersionURL();
      const fetchInit = defaultFetchInitObj(TEXT_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      });
    }
    /**
     * forms a url to the fdsn registry based on the configured parameters.
     *
     * @returns the url
     */


    formURL() {
      const method = "query";
      let url = this.formBaseURL() + "/".concat(method, "?");

      if (this._name) {
        url = url + makeParam("name", this.name());
      }

      if (this._services) {
        url = url + makeParam("services", this.services());
      }

      if (this._includedatasets) {
        url = url + makeParam("includedatasets", this.includeDataSets());
      }

      if (url.endsWith('&') || url.endsWith('?')) {
        url = url.substr(0, url.length - 1); // zap last & or ?
      }

      return url;
    }

  }
  /* original json schema from
  https://github.com/FDSN/datacenter-registry

  {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "id": "http://www.fdsn.org/schemas/FDSN-datacenter-registry-1.0.schema.json",
      "description": "Data center registry exchange format",
      "definitions": {
          "services": {
              "type": "array",
              "items": {
                  "type": "object",
                  "additionalProperties": false,
                  "required": ["name"],
                  "properties": {
                      "name": {
                          "description": "Service name (no white space)",
                          "type": "string",
                          "pattern": "^[-_a-zA-Z0-9]+$"
                      },
                      "description": {
                          "description": "Description of service",
                          "type": "string"
                      },
                      "url": {
                          "description": "URL to web service, ideally with documentation",
                          "type": "string",
                          "format": "uri"
                      },
                      "compatibleWith": {
                          "description": "Description of service compatibility with a standard or alternate service (e.g. fdsnws-dataselect, fdsnws-station, fdsnws-event)",
                          "type": "string"
                      }
                  }
              }
          }
      },
      "type": "object",
      "required": ["version", "datacenters"],
      "properties": {
          "version": {
              "description": "Data center registry message format version",
              "const": 1.0
          },
          "datacenters": {
              "type": "array",
              "items": {
                  "type": "object",
                  "additionalProperties": false,
                  "required": [
                      "name",
                      "website"
                  ],
                  "properties": {
                      "name": {
                          "description": "Data center name (no white space)",
                          "type": "string",
                          "pattern": "^[-_a-zA-Z0-9]+$"
                      },
                      "website": {
                          "description": "URL to data center website",
                          "type": "string",
                          "format": "uri"
                      },
                      "fullName": {
                          "description": "Full name of data center",
                          "type": "string"
                      },
                      "summary": {
                          "description": "Summary of data center",
                          "type": "string"
                      },
                      "repositories": {
                          "description": "Repositories of data center",
                          "type": "array",
                          "items": {
                              "type": "object",
                              "additionalProperties": false,
                              "required": ["name"],
                              "properties": {
                                  "name": {
                                      "description": "Repository name (no white space)",
                                      "type": "string",
                                      "pattern": "^[-_a-zA-Z0-9]+$"
                                  },
                                  "description": {
                                      "description": "Description of repository",
                                      "type": "string"
                                  },
                                  "website": {
                                      "description": "URL to repository website",
                                      "type": "string",
                                      "format": "uri"
                                  },
                                  "services": {"$ref": "#/definitions/services"},
                                  "datasets": {
                                      "description": "Data sets offered by the data center",
                                      "type": "array",
                                      "items": {
                                          "type": "object",
                                          "additionalProperties": false,
                                          "properties": {
                                              "network": {"type": "string"},
                                              "station": {"type": "string"},
                                              "location": {"type": "string"},
                                              "channel": {"type": "string"},
                                              "starttime": {
                                                  "type": "string",
                                                  "format": "date-time"
                                              },
                                              "endtime": {
                                                  "type": "string",
                                                  "format": "date-time"
                                              },
                                              "priority": {
                                                  "description": "Priority of data center for this data set, with 1 being highest",
                                                  "type": "integer"
                                              },
                                              "description": {
                                                  "description": "Description of data set",
                                                  "type": "string"
                                              },
                                              "url": {
                                                  "description": "URL to data set or summary page",
                                                  "type": "string",
                                                  "format": "uri"
                                              },
                                              "services": {
                                                  "description": "Services for this data set, overriding repository service declarations",
                                                  "$ref": "#/definitions/services"
                                              }
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
  }

   */

  /* The below are slighly modified from json schema to flow autogenerator.
  *
  * */

  /**
   * Root type of fdsn datacenters json query.
   */

  var fdsndatacenters = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FDSN_HOST: FDSN_HOST,
    DataCentersQuery: DataCentersQuery
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const CenteredHilbertTransform = OregonDSP.filter.fir.equiripple.CenteredHilbertTransform;
  /**
   * Constant for bandpass OregonDSP filter creation.
   */

  const BAND_PASS = OregonDSP.filter.iir.PassbandType.BANDPASS;
  /**
   * Constant for lowpass OregonDSP filter creation.
   */

  const LOW_PASS = OregonDSP.filter.iir.PassbandType.LOWPASS;
  /**
   * Constant for highpass OregonDSP filter creation.
   */

  const HIGH_PASS = OregonDSP.filter.iir.PassbandType.HIGHPASS;
  function amplitude(real, imag) {
    return Math.hypot(real, imag);
  }
  /**
   * Remove the mean from a seismogram. Subtract the mean from each data point.
   *
   * @param   seis input seismogram
   * @returns       seismogram with mean of zero
   */

  function rMean(seis) {
    if (seis instanceof Seismogram) {
      let meanVal = seis.mean();
      let rmeanSeismogram = new Seismogram(seis.segments.map(s => {
        let demeanY = s.y.map(function (d) {
          return d - meanVal;
        });
        let out = s.cloneWithNewData(demeanY);
        return out;
      }));
      return rmeanSeismogram;
    } else {
      throw new Error("rMean arg not a Seismogram");
    }
  }
  /**
   * Apply the frequency independent overall gain to a seismogram. This does not
   * do a full transfer using poles and zero, this only applies the scalar conversion
   * factor to convert counts back to original real world units and update the units.
   *
   * @param   seis                  the seismogram to correct
   * @param   instrumentSensitivity overall gain object, usually pulled from stationxml
   * @returns                        new seismogram with original units, like m/s and gain applied.
   */

  function gainCorrect(seis, instrumentSensitivity) {
    if (seis instanceof Seismogram) {
      let gain = instrumentSensitivity.sensitivity;
      let gainSeismogram = new Seismogram(seis.segments.map(s => {
        let gainY;

        if (s.y instanceof Int32Array || s.y instanceof Float32Array) {
          gainY = Float32Array.from(s.y);
        } else {
          gainY = Float64Array.from(s.y);
        }

        gainY = gainY.map(function (d) {
          return d / gain;
        });
        let outS = s.cloneWithNewData(gainY);
        outS.yUnit = instrumentSensitivity.inputUnits;
        return outS;
      }));
      return gainSeismogram;
    } else {
      throw new Error("Expected Seismogram but was ".concat(typeof seis));
    }
  }

  /**
   * Creates a Butterworth IIR filter using the OregonDSP library.
   *
   * @param   numPoles       number of poles
   * @param   passband       type, use constants of BAND_PASS, LOW_PASS, HIGH_PASS
   * @param   lowFreqCorner  low corner frequency
   * @param   highFreqCorner high corner frequency
   * @param   delta          delta, period, of timeseries
   * @returns                 Butterworth IIR filter
   */
  function createButterworth(numPoles, passband, lowFreqCorner, highFreqCorner, delta) {
    return new OregonDSP.filter.iir.Butterworth(numPoles, passband, lowFreqCorner, highFreqCorner, delta);
  }
  /**
   * Creates a Chebyshev I IIR filter using the OregonDSP library.
   *
   * @param   numPoles       number of poles
   * @param   epsilon        Chebyshev epsilon value
   * @param   passband       type, use constants of BAND_PASS, LOW_PASS, HIGH_PASS
   * @param   lowFreqCorner  low corner frequency
   * @param   highFreqCorner high corner frequency
   * @param   delta          delta, period, of timeseries
   * @returns                 Chebyshev I IIR filter
   */

  function createChebyshevI(numPoles, epsilon, passband, lowFreqCorner, highFreqCorner, delta) {
    return new OregonDSP.filter.iir.ChebyshevI(numPoles, epsilon, passband, lowFreqCorner, highFreqCorner, delta);
  }
  /**
   * Creates a Chebyshev II IIR filter using the OregonDSP library.
   *
   * @param   numPoles       number of poles
   * @param   epsilon        Chebyshev epsilon value
   * @param   passband       type, use constants of BAND_PASS, LOW_PASS, HIGH_PASS
   * @param   lowFreqCorner  low corner frequency
   * @param   highFreqCorner high corner frequency
   * @param   delta          delta, period, of timeseries
   * @returns                 Chebyshev II IIR filter
   */

  function createChebyshevII(numPoles, epsilon, passband, lowFreqCorner, highFreqCorner, delta) {
    return new OregonDSP.filter.iir.ChebyshevII(numPoles, epsilon, passband, lowFreqCorner, highFreqCorner, delta);
  }
  /**
   * Applies the filter to the given seismogram.
   *
   * @param   iirFilter filter to apply
   * @param   seis      seismogram to apply filter to
   * @returns            filtered seismogram
   */

  function applyFilter(iirFilter, seis) {
    let filteredSegments = [];

    for (let i = 0; i < seis.segments.length; i++) {
      let outData = Float32Array.from(seis.segments[i].y);
      iirFilter.filterInPlace(outData);
      filteredSegments.push(seis.segments[i].cloneWithNewData(outData));
    }

    return new Seismogram(filteredSegments);
  }
  /**
   * Calculates the envelope, y_i = sqrt( y_i * y_i + h_i * h_i)
   *  where h is the hilber transform of y. The default configuration
   *  for the hilbet transform is n=100, lowEdge=.05 and highEdge = 0.95
   *
   * @param seis seismogram to apply envelope to
   * @returns seismogram cloned but with data as the envelope
   */

  function envelope(seis) {
    if (seis.isContiguous()) {
      let seisY = seis.y;
      let s = hilbert(seis);
      let hilbertY = s.y;
      let outY;

      if (seis.y instanceof Int32Array || seis.y instanceof Float32Array) {
        outY = new Float32Array(seisY.length);
      } else {
        outY = new Float64Array(seisY.length);
      }

      for (let n = 0; n < seisY.length; n++) {
        outY[n] = Math.sqrt(hilbertY[n] * hilbertY[n] + seisY[n] * seisY[n]);
      }

      return seis.cloneWithNewData(outY);
    } else {
      throw new Error("Cannot take envelope of non-contiguous seismogram");
    }
  }
  /**
   * Calculates the hilbert transform using the OregonDSP library
   *  with default number of points, n=10 (to yield a 21 pt FIR transform)
   *  and default low and high edge of 0.05 and 0.95. Low and high edge are
   *  given normalized 0 to 1.
   *
   * @param seis seismogram to calculate from
   * @param n optional number of points in transform, default is 10
   * @param lowEdge low edge of filter, normailized to 0-1, default is 0.05
   * @param highEdge high edge of filter, normailized to 0-1, default is 0.95
   * @returns hilbert transformed data
   *
   */

  function hilbert(seis, n, lowEdge, highEdge) {
    if (seis.isContiguous()) {
      let seisY = seis.y;

      if (!isDef(n)) {
        n = 10;
      }

      if (!isDef(lowEdge)) {
        lowEdge = .05;
      }

      if (!isDef(highEdge)) {
        highEdge = .95;
      }

      let hilbert = new CenteredHilbertTransform(n, lowEdge, highEdge);
      let coeff = hilbert.getCoefficients();

      for (let c of coeff) {
        if (Number.isNaN(c)) {
          throw new Error("Hilbert FIR coeff includes NaN: ".concat(coeff.join()));
        }
      }

      let hilbertY = hilbert.filter(seisY);
      let s = seis.cloneWithNewData(hilbertY);
      return s;
    } else {
      throw new Error("Cannot take hilbert of non-contiguous seismogram");
    }
  }

  var filter = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BAND_PASS: BAND_PASS,
    LOW_PASS: LOW_PASS,
    HIGH_PASS: HIGH_PASS,
    amplitude: amplitude,
    rMean: rMean,
    gainCorrect: gainCorrect,
    createButterworth: createButterworth,
    createChebyshevI: createChebyshevI,
    createChebyshevII: createChebyshevII,
    applyFilter: applyFilter,
    envelope: envelope,
    hilbert: hilbert
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** A higher level function to calculate DFT. Returns a
   * FFTResult for easier access to the result as
   * complex, amp, phase arrays. Calls calcDFT internally.
   * Inverse FFT is available as FFTResult.fftInverse().
   *
   * @param seis seismogram to transform
   * @returns fft of seismogram
   */

  function fftForward(seis) {
    if (seis.isContiguous()) {
      let result = FFTResult.createFromPackedFreq(calcDFT(seis.y), seis.numPoints, seis.sampleRate);
      return result;
    } else {
      throw new Error("Can only take FFT is seismogram is contiguous.");
    }
  }
  /**
   * Calculates the discrete fourier transform using the OregonDSP library.
   *
   * @param   timeseries timeseries array
   * @returns           DFT as packed array Float32Array
   */

  function calcDFT(timeseries) {
    let log2N = 4;
    let npts = timeseries.length;
    let N = 16;

    while (N < npts) {
      log2N += 1;
      N = 2 * N;
    }

    let dft = new OregonDSP.fft.RDFT(log2N);
    let inArray = new Float32Array(N);
    inArray.fill(0);

    for (let i = 0; i < timeseries.length; i++) {
      inArray[i] = timeseries[i];
    }

    let out = new Float32Array(N).fill(0);
    dft.evaluate(inArray, out);
    return out;
  }
  /**
   * Calculates the inverse discrete fourier transform using the OregonDSP library.
   *
   * @param   packedFreq DFT as packed array Float32Array
   * @param   numPoints     number of points in original timeseries array.
   * @returns           inverse of DFT as a timeseries array
   */

  function inverseDFT(packedFreq, numPoints) {
    if (numPoints > packedFreq.length) {
      throw new Error("Not enough points in packed freq array for " + numPoints + ", only " + packedFreq.length);
    }

    let log2N = 4;
    let N = 16;

    while (N < packedFreq.length) {
      log2N += 1;
      N = 2 * N;
    }

    if (N !== packedFreq.length) {
      throw new Error("power of two check fails: " + N + " " + packedFreq.length);
    }

    let dft = new OregonDSP.fft.RDFT(log2N);
    let out = new Float32Array(N).fill(0);
    dft.evaluateInverse(packedFreq, out);
    return out.slice(0, numPoints);
  }
  /**
   * Results of FFT calculateion. Allows convertion of the packed real/imag array output from calcDFT into
   * amplitude and phase.
   */

  class FFTResult {
    /** number of points in the original timeseries, may be less than fft size. */

    /** number of points in the fft, usually power of 2 larger than origLength. */

    /** sample rate of the original time series, maybe be null. */
    constructor(origLength, sampleRate) {
      this.origLength = origLength;
      this.sampleRate = sampleRate;
    }
    /**
     * Factory method to create FFTResult from packed array.
     *
     * @param   packedFreq real and imag values in packed format
     * @param   origLength length of the original timeseries before padding.
     * @param   sampleRate sample rate of original data
     * @returns            FFTResult
     */


    static createFromPackedFreq(packedFreq, origLength, sampleRate) {
      let fftResult = new FFTResult(origLength, sampleRate);
      fftResult.packedFreq = packedFreq;
      fftResult.recalcFromPackedFreq();
      return fftResult;
    }
    /**
     * Factory method to create from array of complex numbers.
     *
     * @param   complexArray real and imag values as array of Complex objects.
     * @param   origLength   length of the original timeseries before padding.
     * @param   sampleRate sample rate of original data
     * @returns               FFTResult
     */


    static createFromComplex(complexArray, origLength, sampleRate) {
      let fftResult = new FFTResult(origLength, sampleRate);
      fftResult.complex = complexArray;
      fftResult.recalcFromComplex();
      return fftResult;
    }
    /**
     * Factory method to create from amp and phase arrays
     *
     * @param   amp        amplitude values
     * @param   phase      phase values
     * @param   origLength length of the original timeseries before padding.
     * @param   sampleRate sample rate of original data
     * @returns             FFTResult
     */


    static createFromAmpPhase(amp, phase, origLength, sampleRate) {
      let fftResult = new FFTResult(origLength, sampleRate);

      if (amp.length !== phase.length) {
        throw new Error("amp and phase must be same length: ".concat(amp.length, " ").concat(phase.length));
      }

      fftResult.amp = amp;
      fftResult.phase = phase;
      fftResult.recalcFromAmpPhase();
      return fftResult;
    }
    /**
     * The minimum non-zero frequency in the fft
     *
     * @returns fundamental frequency
     */


    get fundamentalFrequency() {
      if (this.sampleRate) {
        return this.sampleRate / this.numPoints;
      } else {
        throw new Error("sample rate not set on FFTResult, needed to calc min frequency");
      }
    }

    recalcFromPackedFreq() {
      this.complex = [];
      this.amp = new Float32Array(this.packedFreq.length / 2 + 1);
      this.phase = new Float32Array(this.packedFreq.length / 2 + 1);
      this.numPoints = this.packedFreq.length;
      let c = createComplex(this.packedFreq[0], 0);
      this.complex.push(c);
      this.amp[0] = c.abs();
      this.phase[0] = c.angle();
      const L = this.packedFreq.length;

      for (let i = 1; i < this.packedFreq.length / 2; i++) {
        c = createComplex(this.packedFreq[i], this.packedFreq[L - i]);
        this.complex.push(c);
        this.amp[i] = c.abs();
        this.phase[i] = c.angle();
      }

      c = createComplex(this.packedFreq[L / 2], 0);
      this.complex.push(c);
      this.amp[this.packedFreq.length / 2] = c.abs();
      this.phase[this.packedFreq.length / 2] = c.angle();
    }
    /**
     * recalculate the packedFreq array after modifications
     * to the complex array.
     * */


    recalcFromComplex() {
      const N = this.complex.length;
      let modFreq = new Float32Array(N).fill(0);
      modFreq[0] = this.complex[0].real;

      for (let i = 1; i < this.complex.length - 1; i++) {
        modFreq[i] = this.complex[i].real;
        modFreq[N - i] = this.complex[i].imag;
      }

      modFreq[N / 2] = this.complex[N - 1].real;
      this.packedFreq = modFreq;
      this.numPoints = this.packedFreq.length;
    }
    /**
     * recalculate the packedFreq array after modifications
     * to the amp and/or phase arrays.
     */


    recalcFromAmpPhase() {
      let modComplex = new Array(this.amp.length);

      for (let i = 0; i < this.amp.length; i++) {
        modComplex[i] = OregonDSP.filter.iir.Complex.Companion.ComplexFromPolar(this.amp[i], this.phase[i]);
      }

      this.complex = modComplex;
      this.recalcFromComplex();
    }
    /**
     * calculates the inverse fft of this.packedFreq
     *
     * @returns time domain representation
     */


    fftInverse() {
      return inverseDFT(this.packedFreq, this.origLength);
    }

    clone() {
      return FFTResult.createFromPackedFreq(this.packedFreq.slice(), this.origLength, this.sampleRate);
    }

  }

  var fft = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fftForward: fftForward,
    calcDFT: calcDFT,
    inverseDFT: inverseDFT,
    FFTResult: FFTResult
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */

  /** Constant for drawing seismogram using svg. */
  const DRAW_SVG = "svg";
  /** Constant for drawing seismogram using canvas, axies are still svg. */

  const DRAW_CANVAS = "canvas";
  /** Constant for drawing seismogram using both canvas and svg, for testing. */

  const DRAW_BOTH = "both"; // for testing

  /** Constant for drawing seismogram using both canvas and svg plus alignment markers, for testing. */

  const DRAW_BOTH_ALIGN = "alignment"; // for testing

  /**
   * Configuration object for Seismograph display.
   * 
   */

  class SeismographConfig {
    //below this draw all points, above draw minmax
    // no zoom in past point of sample
    // separated by pixels
    constructor() {
      this.drawingType = DRAW_CANVAS;
      this.isXAxis = true;
      this.isXAxisTop = false;
      this.isYAxisNice = true;
      this.isYAxis = true;
      this.isYAxisRight = false;
      this.xScaleFormat = multiFormatHour;
      this.yScaleFormat = formatCountOrAmp;
      this._title = [];
      this.xLabel = "Time";
      this.xLabelOrientation = "horizontal";
      this.xSublabel = "";
      this.yLabel = "Amplitude";
      this.yLabelRight = "";
      this.yLabelOrientation = "vertical";
      this.ySublabel = "";
      this.ySublabelTrans = 15;
      this.ySublabelIsUnits = true;
      this.doRMean = true;
      this.doGain = true;
      this.windowAmp = true;
      this.fixedYScale = null;
      this.fixedTimeScale = null;
      this.doMarkers = true;
      this.markerTextOffset = .85;
      this.markerTextAngle = 45;
      this.markerFlagpoleBase = "bottom"; // bottom or center

      this.minHeight = 0;
      this.margin = {
        top: 20,
        right: 20,
        bottom: 42,
        left: 85,
        toString: function toString() {
          return "t:" + this.top + " l:" + this.left + " b:" + this.bottom + " r:" + this.right;
        }
      };
      this.segmentDrawCompressedCutoff = 10; //below this draw all points, above draw minmax

      this.maxZoomPixelPerSample = 20; // no zoom in past point of sample
      // separated by pixels

      this.wheelZoom = true;
      this.connectSegments = false;
      this.lineColors = ["skyblue", "olivedrab", "goldenrod", "firebrick", "darkcyan", "orange", "darkmagenta", "mediumvioletred", "sienna", "black"];
      this.lineWidth = 1;
    }
    /**
     * gets the current title
     *
     * @returns        title as an array of strings
     */


    get title() {
      return this._title;
    }
    /**
     * Sets the title as simple string or array of strings. If an array
     * then each item will be in a separate tspan for easier formatting.
     *
     * @param value string or array of strings to be the title
     */


    set title(value) {
      if (Array.isArray(value)) {
        this._title = value;
      } else {
        this._title = [value];
      }
    }
    /** Fake data to use to test alignment of seismograph axis and between canvas
     *  and svg drawing.
     *
     * @param   timeWindow start and end of fake data
     * @param   min        min amplitude for fake data, default is -100
     * @param   max        max amplitude for fake data, default is 100
     * @returns             fake data
     */


    createAlignmentData(timeWindow, min = -100, max = 100) {
      const mid = (max + min) / 2;
      const fakeData = Float32Array.from([max, min, max, min, mid, mid, max, mid, mid, min]);
      const fakeSampleRate = 1 / (timeWindow.duration.asSeconds() / (fakeData.length - 1));
      const fakeSeis = Seismogram.createFromContiguousData(fakeData, fakeSampleRate, timeWindow.startTime);
      const fakeSDD = SeismogramDisplayData.fromSeismogram(fakeSeis);
      return fakeSDD;
    }

    getColorForIndex(i) {
      if (isDef(this.lineColors) && this.lineColors.length > 0) {
        return this.lineColors[i % this.lineColors.length];
      } else {
        return "black";
      }
    }

    clone() {
      let out = new SeismographConfig();
      Object.getOwnPropertyNames(this).forEach(name => {
        // $FlowFixMe
        if (this[name] instanceof moment__default) {
          // $FlowFixMe
          out[name] = moment__default.utc(this[name]); // $FlowFixMe
        } else if (Array.isArray(this[name])) {
          // $FlowFixMe
          out[name] = this[name].slice();
        } else {
          // $FlowFixMe
          out[name] = this[name];
        } // handle margin separately


        out.margin = {
          top: this.margin.top,
          right: this.margin.right,
          bottom: this.margin.bottom,
          left: this.margin.left,
          toString: function toString() {
            return "t:" + this.top + " l:" + this.left + " b:" + this.bottom + " r:" + this.right;
          }
        };
      });
      return out;
    }

    toString() {
      let outS = "";
      Object.getOwnPropertyNames(this).forEach(name => {
        // $FlowFixMe
        outS += "  seisConfig.".concat(name, " = ").concat(JSON.stringify(this[name]), "\n");
      });
      return outS;
    }

  }
  const formatCount = d3.format('~s');
  const formatExp = d3.format('.2e');
  const formatCountOrAmp = function formatCountOrAmp(v) {
    return -1 < v && v < 1 && v !== 0 ? formatExp(v) : formatCount(v);
  };
  const formatMillisecond = d3.utcFormat(".%L");
  const formatSecond = d3.utcFormat(":%S");
  const formatMinute = d3.utcFormat("%H:%M");
  const formatHour = d3.utcFormat("%H:%M");
  const formatDay = d3.utcFormat("%m/%d");
  const formatMonth = d3.utcFormat("%Y/%m");
  const formatYear = d3.utcFormat("%Y");
  const multiFormatHour = function multiFormatHour(date) {
    return (d3.utcSecond(date) < date ? formatMillisecond : d3.utcMinute(date) < date ? formatSecond : d3.utcHour(date) < date ? formatMinute : d3.utcDay(date) < date ? formatHour : d3.utcMonth(date) < date ? formatDay : d3.utcYear(date) < date ? formatMonth : formatYear)(date);
  };

  var seismographconfig = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DRAW_SVG: DRAW_SVG,
    DRAW_CANVAS: DRAW_CANVAS,
    DRAW_BOTH: DRAW_BOTH,
    DRAW_BOTH_ALIGN: DRAW_BOTH_ALIGN,
    SeismographConfig: SeismographConfig,
    formatCount: formatCount,
    formatExp: formatExp,
    formatCountOrAmp: formatCountOrAmp,
    formatMillisecond: formatMillisecond,
    formatSecond: formatSecond,
    formatMinute: formatMinute,
    formatHour: formatHour,
    formatDay: formatDay,
    formatMonth: formatMonth,
    formatYear: formatYear,
    multiFormatHour: multiFormatHour
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * Create a single amplitude plot of FFT data.
   *
   * @param   cssSelector selection of the containing element, usually a div
   * @param   fftResult         data to plot
   * @param   config configuration of the plot, note not all options are supported by fft plots
   * @param   loglog      true for loglog plot, false for linlog
   * @returns             the plot
   */

  function createSimpleFFTPlot(cssSelector, fftResult, config, loglog = true) {
    let fftplot = new FFTPlot(cssSelector, config, fftResult, loglog);
    fftplot.draw();
    return fftplot;
  }
  /**
   * Create a amplitude plot of multiple FFT data.
   *
   * @param   cssSelector selection of the containing element, usually a div
   * @param   fftResults         data to plot
   * @param   config configuration of the plot, note not all options are supported by fft plots
   * @param   loglog      true for loglog plot, false for linlog
   * @returns             the plot
   */

  function createOverlayFFTPlot(cssSelector, fftResults, config = new SeismographConfig(), loglog = true) {
    let fftplot = new FFTPlot(cssSelector, config, fftResults, loglog);
    fftplot.draw();
    return fftplot;
  }
  /**
   * A amplitude plot of fft data.
   *
   * @param cssSelector selector or d3 selection
   * @param seismographConfig config of the plot, not all values are used
   * @param fftResult fft data to plot
   * @param loglog log or linear frequency
   */

  class FFTPlot {
    constructor(cssSelector, seismographConfig, fftResult, loglog = true) {
      this.svgParent = cssSelector;
      this.seismographConfig = seismographConfig;
      this.fftResults = Array.isArray(fftResult) ? fftResult : [fftResult];
      this.xScale = null;
      this.yScale = null;
      this.svg = null;
      this.loglog = loglog;

      if (typeof cssSelector === 'string') {
        this.svgParent = d3.select(cssSelector);
      } else {
        this.svgParent = cssSelector;
      }
    }

    draw() {
      const that = this;
      let ampPhaseList = [];
      let ampSliceMap = new Map();
      let maxFFTAmpLen = 0;
      let extentFFTData = null;
      let freqMinMax = [];

      for (const fftA of this.fftResults) {
        if (this.loglog) {
          freqMinMax.push(fftA.fundamentalFrequency); // min freq
        } else {
          freqMinMax.push(0);
        }

        freqMinMax.push(fftA.sampleRate / 2); // max freq

        let ap;

        if (fftA instanceof FFTResult) {
          ap = fftA;
        } else {
          throw new Error("fftResults must be array of FFTResult");
        }

        ampPhaseList.push(ap);

        if (maxFFTAmpLen < ap.amp.length) {
          maxFFTAmpLen = ap.amp.length;
        }

        let ampSlice;

        if (this.loglog) {
          // don't plot zero freq amp
          ampSlice = ap.amp.slice(1);
        } else {
          ampSlice = ap.amp;
        }

        let currExtent = d3.extent(ampSlice);

        if (currExtent[0] === 0) {
          // replace zero with smallest non-zero / 10 for loglog plot
          currExtent[0] = 0.1 * ampSlice.reduce((acc, curr) => {
            if (curr > 0 && curr < acc) {
              return curr;
            } else {
              return acc;
            }
          }, 1e-9);
        }

        ampSliceMap.set(ap, ampSlice);

        if (extentFFTData) {
          extentFFTData = d3.extent([extentFFTData[0], extentFFTData[1], currExtent[0], currExtent[1]], function (d) {
            return d;
          });
        } else {
          extentFFTData = currExtent;
        }
      }

      let svg = this.svgParent.append("svg");
      this.svg = svg;
      svg.classed("fftplot", true);
      let rect = svg.node().getBoundingClientRect();
      let width = +rect.width - this.seismographConfig.margin.left - this.seismographConfig.margin.right;
      let height = +rect.height - this.seismographConfig.margin.top - this.seismographConfig.margin.bottom;
      let g = svg.append("g").attr("transform", "translate(" + this.seismographConfig.margin.left + "," + this.seismographConfig.margin.top + ")");

      if (this.loglog) {
        this.xScale = d3.scaleLog().rangeRound([0, width]);
      } else {
        this.xScale = d3.scaleLinear().rangeRound([0, width]);
      }

      this.xScale.domain(d3.extent(freqMinMax));
      this.yScale = d3.scaleLog().rangeRound([height, 0]);
      this.yScale.domain(extentFFTData);

      if (this.yScale.domain()[0] === this.yScale.domain()[1]) {
        this.yScale.domain([this.yScale.domain()[0] / 2, this.yScale.domain()[1] * 2]);
      }

      const xAxis = d3.axisBottom(this.xScale);
      g.append("g").attr("transform", "translate(0," + height + ")").call(xAxis);
      g.append("g").attr("transform", "translate(0, ".concat(height + this.seismographConfig.margin.bottom, " )")).append("text").attr("fill", "#000").attr("y", 0).attr("x", width / 2).attr("dy", "0.71em").attr("text-anchor", "end").text("Hertz");
      const yAxis = d3.axisLeft(this.yScale);
      g.append("g").call(yAxis);
      svg.append("g").attr("transform", "translate(0, ".concat(this.seismographConfig.margin.top + height / 2, " )")).append("text").attr("fill", "#000").attr("dy", "0.71em").attr("transform", "rotate(-90)").attr("text-anchor", "end").text("Amp");
      let pathg = g.append("g").classed("allfftpaths", true);

      for (const ap of ampPhaseList) {
        let ampSlice = ampSliceMap.get(ap);
        let minFreq = ap.fundamentalFrequency;
        let line = d3.line();

        if (this.loglog) {
          line.x(function (d, i) {
            return that.xScale((i + 1) * minFreq);
          }); // minus one as slice off zero freq above
        } else {
          line.x(function (d, i) {
            return that.xScale(i * minFreq);
          });
        }

        line.y(function (d) {
          if (d !== 0.0 && !isNaN(d)) {
            return that.yScale(d);
          } else {
            return that.yScale.range()[0];
          }
        });
        pathg.append("g").append("path").classed("fftpath", true).datum(ampSlice).attr("d", line);
      }

      return this;
    }

  }
  /**
   * Defualt CSS for styling fft plots.
   */

  const fftplot_css = "\n\n\npath.fftpath {\n  stroke: skyblue;\n  fill: none;\n  stroke-width: 1px;\n}\n\nsvg.fftplot {\n  height: 100%;\n  width: 100%;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+1) path.fftpath {\n  stroke: skyblue;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+2) path.fftpath {\n  stroke: olivedrab;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+3) path.fftpath {\n  stroke: goldenrod;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+4) path.fftpath {\n  stroke: firebrick;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+5) path.fftpath {\n  stroke: darkcyan;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+6) path.fftpath {\n  stroke: orange;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+7) path.fftpath {\n  stroke: darkmagenta;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+8) path.fftpath {\n  stroke: mediumvioletred;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+9) path.fftpath {\n  stroke: sienna;\n}\n\n/* same colors for titles */\n\nsvg.fftplot g.title tspan:nth-child(9n+1)  {\n  fill: skyblue;\n}\n\nsvg.fftplot g.title text tspan:nth-child(9n+2)  {\n  stroke: olivedrab;\n}\n\nsvg.fftplot g.title text tspan:nth-child(9n+3)  {\n  stroke: goldenrod;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+4)  {\n  stroke: firebrick;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+5)  {\n  stroke: darkcyan;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+6)  {\n  stroke: orange;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+7)  {\n  stroke: darkmagenta;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+8)  {\n  stroke: mediumvioletred;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+9)  {\n  stroke: sienna;\n}\n\n\n/* links in svg */\nsvg.fftplot text a {\n  fill: #0000EE;\n  text-decoration: underline;\n}\n\n";

  if (document) {
    insertCSS(fftplot_css);
  }

  var fftplot = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createSimpleFFTPlot: createSimpleFFTPlot,
    createOverlayFFTPlot: createOverlayFFTPlot,
    FFTPlot: FFTPlot,
    fftplot_css: fftplot_css
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const CLIP_PREFIX = "seismographclip";

  /* A seismogram plot, using d3. The actual waveform can be drawn
    * with a separate Canvas (default) or with SVG.
    * Note that for SVG you must have
    * stroke and fill set in css like:<br>
    * path.seispath {
    *   stroke: skyblue;
    *   fill: none;
    * }<br/>
    * in order to have the seismogram display.
    */
  class Seismograph {
    /** @private */
    // for drawing seismogram
    // for drawing y axis
    // holds min max of data in time window
    constructor(inSvgParent, seismographConfig, seisData) {
      if (inSvgParent === null) {
        throw new Error("inSvgParent cannot be null");
      }

      if (!isDef(seismographConfig)) {
        if (isDef(seisData) && (!Array.isArray(seisData) || seisData.length > 0)) {
          // need at least one of seismographConfig or seisData to get time window
          seismographConfig = new SeismographConfig();
        } else {
          throw new Error("seismographConfig and seisData cannot both be null");
        }
      }

      this.plotId = ++Seismograph._lastID;
      this.beforeFirstDraw = true;
      this.seismographConfig = seismographConfig;
      this.seisDataList = [];

      this._internalAppend(seisData);

      this.alignmentSeisData = [];
      this.width = 200;
      this.height = 100;

      if (typeof inSvgParent === 'string') {
        this.svgParent = d3.select(inSvgParent);
      } else {
        this.svgParent = inSvgParent;
      }

      this.canvas = null;
      this.svg = this.svgParent.append("svg").style("z-index", 100);

      if (isNumArg(this.seismographConfig.minHeight) && this.seismographConfig.minHeight > 0) {
        this.svg.style("min-height", this.seismographConfig.minHeight + 'px');
      }

      if (isNumArg(this.seismographConfig.maxHeight) && this.seismographConfig.maxHeight > 0) {
        this.svg.style("max-height", this.seismographConfig.maxHeight + 'px');
      }

      this.svg.classed("seismograph", true);
      this.svg.attr("version", "1.1");
      this.svg.attr("plotId", this.plotId);
      this.calcTimeScaleDomain();
      this.yScale = d3.scaleLinear();
      this.yScaleData = d3.scaleLinear(); // yScale for axis (not drawing) that puts mean at 0 in center

      this.yScaleRmean = d3.scaleLinear();
      this.linkedAmpScale = new LinkedAmpScale([this]);
      this.xScaleChangeListeners = [];

      if (this.seismographConfig.isXAxis) {
        this.xAxis = d3.axisBottom(this.currZoomXScale).tickFormat(this.seismographConfig.xScaleFormat);
      }

      if (this.seismographConfig.isXAxisTop) {
        this.xAxisTop = d3.axisTop(this.currZoomXScale).tickFormat(this.seismographConfig.xScaleFormat);
      }

      if (this.seismographConfig.isYAxis) {
        this.yAxis = d3.axisLeft(this.yScaleRmean).tickFormat(this.seismographConfig.yScaleFormat);
      }

      if (this.seismographConfig.isYAxisRight) {
        this.yAxisRight = d3.axisRight(this.yScaleRmean).tickFormat(this.seismographConfig.yScaleFormat);
      }

      let mythis = this;
      this.g = this.svg.append("g").classed("marginTransform", true).attr("transform", "translate(" + this.seismographConfig.margin.left + "," + this.seismographConfig.margin.top + ")");
      this.g.append("g").classed("allseismograms", true);
      let z = this.svg.call(d3.zoom().on("zoom", function () {
        mythis.zoomed(mythis);
      }));

      if (!this.seismographConfig.wheelZoom) {
        z.on("wheel.zoom", null);
      }

      this.calcAmpScaleDomain(); // create marker g

      this.g.append("g").attr("class", "allmarkers").attr("style", "clip-path: url(#" + CLIP_PREFIX + this.plotId + ")");
      d3.select(window).on('resize.canvasseismograph' + mythis.plotId, function () {
        if (!mythis.beforeFirstDraw && mythis.checkResize()) {
          mythis.draw();
        }
      });
    }

    static fromSeismograms(inSvgParent, seismographConfig, seismogramList) {
      return new Seismograph(inSvgParent, seismographConfig, seismogramList.map(s => SeismogramDisplayData.fromSeismogram(s)));
    }

    checkResize() {
      let rect = this.svg.node().getBoundingClientRect();

      if (rect.width !== this.outerWidth || rect.height !== this.outerHeight) {
        return true;
      }

      return false;
    }

    draw() {
      let rect = this.svg.node().getBoundingClientRect();

      if (rect.width !== this.outerWidth || rect.height !== this.outerHeight) {
        if (rect.height < this.seismographConfig.minHeight) {
          rect.height = this.seismographConfig.minHeight;
        }

        if (rect.height > this.seismographConfig.maxHeight) {
          rect.height = this.seismographConfig.maxHeight;
        }

        this.calcWidthHeight(rect.width, rect.height);
      }

      if (this.canvas) {
        this.canvasHolder.attr("width", this.width).attr("height", this.height);
        this.canvas.attr("width", this.width).attr("height", this.height);
      } else {
        this.canvasHolder = this.svg.insert("foreignObject", ":first-child").classed("seismograph", true).attr("x", this.seismographConfig.margin.left).attr("y", this.seismographConfig.margin.top).attr("width", this.width).attr("height", this.height + 1);
        this.canvas = this.canvasHolder.append("xhtml:canvas").classed("seismograph", true).attr("xmlns", "http://www.w3.org/1999/xhtml").attr("x", 0).attr("y", 0).attr("width", this.width).attr("height", this.height + 1);
        const mythis = this;
        let z = this.canvas.call(d3.zoom().on("zoom", function () {
          mythis.zoomed(mythis);
        }));

        if (!this.seismographConfig.wheelZoom) {
          z.on("wheel.zoom", null);
        }

        let style = window.getComputedStyle(this.svg.node());
        let padTop = style.getPropertyValue('padding-top');

        if (padTop.endsWith("px")) {
          padTop = Number(padTop.replace("px", ""));
        }

        let borderTop = style.getPropertyValue('border-top-width');

        if (borderTop.endsWith("px")) {
          borderTop = Number(borderTop.replace("px", ""));
        }
      }

      this.drawSeismograms();
      this.drawAxis(this.g);
      this.drawAxisLabels();

      if (this.seismographConfig.doMarkers) {
        this.drawMarkers();
      }

      this.beforeFirstDraw = false;
      return this.svg;
    }

    printSizes() {
      let out = "";
      let rect = this.svg.node().getBoundingClientRect();
      out += "svg rect.height " + rect.height + "\n";
      out += "svg rect.width " + rect.width + "\n";
      let grect = this.svgParent.node().getBoundingClientRect();
      out += "parent rect.height " + grect.height + "\n";
      out += "parent rect.width " + grect.width + "\n";
      let crect = this.canvas.node().getBoundingClientRect();
      out += "c rect.height " + crect.height + "\n";
      out += "c rect.width " + crect.width + "\n";
      out += "c style.height " + this.canvas.style("height") + "\n";
      out += "c style.width " + this.canvas.style("width") + "\n";
      out += "this.height " + this.height + "\n";
      out += "this.width " + this.width + "\n";
      out += "canvas.height " + this.canvas.node().height + "\n";
      out += "canvas.width " + this.canvas.node().width + "\n";
      out += "this.outerHeight " + this.outerHeight + "\n";
      out += "this.outerWidth " + this.outerWidth + "\n"; // $FlowFixMe

      out += "this.margin " + this.seismographConfig.margin + "\n";
      log(out);
    }

    drawSeismograms() {
      if (this.seismographConfig.drawingType === DRAW_BOTH_ALIGN) {
        if (this.alignmentSeisData.length === 0) {
          const startenddur = new StartEndDuration(this.currZoomXScale.domain()[0], this.currZoomXScale.domain()[1]);
          const fakeSDD = this.seismographConfig.createAlignmentData(startenddur);
          this.alignmentSeisData.push(fakeSDD);
        }
      } else {
        this.alignmentSeisData = [];
      }

      if (this.seismographConfig.drawingType === DRAW_CANVAS || this.seismographConfig.drawingType === DRAW_BOTH || this.seismographConfig.drawingType === DRAW_BOTH_ALIGN) {
        this.drawSeismogramsCanvas();
      }

      if (this.seismographConfig.drawingType === DRAW_SVG || this.seismographConfig.drawingType === DRAW_BOTH || this.seismographConfig.drawingType === DRAW_BOTH_ALIGN) {
        this.drawSeismogramsSvg();
      }

      if (this.seismographConfig.drawingType === DRAW_BOTH_ALIGN) {
        this.drawCanvasAlignment();
      }
    }

    isVisible() {
      const elem = this.canvas.node();

      if (!elem) {
        return false;
      }

      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    }

    drawSeismogramsCanvas() {
      const mythis = this;

      if (!this.isVisible()) {
        // no need to draw if we are not visible
        return;
      } // get the canvas drawing context


      const canvasNode = this.canvas.node();
      const context = canvasNode.getContext("2d");
      context.save(); // clear the canvas from previous drawing

      context.clearRect(0, 0, canvasNode.width, canvasNode.height);
      context.lineWidth = this.seismographConfig.lineWidth;

      if (this.seismographConfig.drawingType === DRAW_BOTH_ALIGN) {
        context.lineWidth = this.seismographConfig.lineWidth * 2;
      }

      const plotStart = moment__default.utc(this.currZoomXScale.domain()[0]);
      const plotEnd = moment__default.utc(this.currZoomXScale.domain()[1]);
      const plotDuration = moment__default.duration(plotEnd.diff(plotStart));
      const secondsPerPixel = plotDuration.asSeconds() / (this.currZoomXScale.range()[1] - this.currZoomXScale.range()[0]);
      const sddList = this.seisDataList.concat(this.alignmentSeisData);
      sddList.forEach((t, ti) => {
        let color;

        if (this.seismographConfig.drawingType === DRAW_BOTH_ALIGN) {
          color = mythis.seismographConfig.getColorForIndex(ti + sddList.length);
        } else {
          color = mythis.seismographConfig.getColorForIndex(ti);
        }

        let firstTime = true;

        if (t.seismogram) {
          t.seismogram.segments.forEach(s => {
            if (s.startTime.isAfter(plotEnd) || s.endTime.isBefore(plotStart)) {
              // segment either totally off to left or right of visible
              return;
            }

            const samplesPerPixel = 1.0 * s.sampleRate * secondsPerPixel;
            const pixelsPerSample = 1.0 / samplesPerPixel;
            const startPixel = this.currZoomXScale(s.startTime.toDate());
            const endPixel = this.currZoomXScale(s.endTime.toDate());
            let leftVisibleSample = 0;
            let rightVisibleSample = s.y.length;
            let leftVisiblePixel = startPixel;

            if (startPixel < 0) {
              leftVisibleSample = Math.floor(-1 * startPixel * samplesPerPixel) - 1;
              leftVisiblePixel = 0;
            }

            if (endPixel > this.currZoomXScale.range()[1] + 1) {
              rightVisibleSample = leftVisibleSample + Math.ceil((this.width + 1) * samplesPerPixel) + 1;
            }

            if (firstTime || !this.seismographConfig.connectSegments) {
              context.beginPath();
              context.strokeStyle = color; //context.lineWidth = 5;

              context.moveTo(leftVisiblePixel, this.yScale(s.y[leftVisibleSample]));
              firstTime = false;
            }

            for (let i = leftVisibleSample; i < rightVisibleSample + 2 && i < s.y.length; i++) {
              context.lineTo(startPixel + i * pixelsPerSample, this.yScale(s.y[i]));
            }

            if (!this.seismographConfig.connectSegments) {
              context.stroke();
            }
          });
        } else {
          log("seisdata has no seismogram ".concat(stringify(ti)));
        }

        if (this.seismographConfig.connectSegments) {
          context.stroke();
        }
      });
      context.restore();
    }

    drawCanvasAlignment() {
      const mythis = this;
      let radius = 10; // draw corners in svg for comparison

      let minX = this.currZoomXScale.domain()[0];
      let maxX = this.currZoomXScale.domain()[1];
      let minY = this.yScale.domain()[0];
      let maxY = this.yScale.domain()[1];
      this.g.selectAll("circle").remove();
      let circles = this.g.selectAll("circle").data([[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]]);
      circles.exit().remove();
      circles.enter().append("circle").attr('fill-opacity', '0.4').attr('cx', function (d) {
        return mythis.currZoomXScale(d[0]);
      }).attr('cy', function (d) {
        return mythis.yScale(d[1]);
      }).attr('r', radius - 2);
      this.g.selectAll("path.diagonal").remove();
      this.g.append("path").attr("class", "seispath diagonal").attr("d", "M0,0L" + mythis.currZoomXScale(maxX) + ", " + mythis.yScale(minY)); // svg text color

      let textcolor = this.seismographConfig.getColorForIndex(this.seisDataList.length);
      let textcolorArr = [textcolor];
      this.g.selectAll("text").data(textcolorArr).enter().append("text").style("fill", textcolor).text("svg " + textcolor).attr("x", this.width * 3 / 4).attr("y", this.height / 4 + 20); // get the canvas drawing context

      const canvasNode = this.canvas.node(); //canvasNode.height = this.height;
      //canvasNode.width = this.width;

      const context = canvasNode.getContext("2d"); // canvas text color

      textcolor = this.seismographConfig.getColorForIndex(2 * this.seisDataList.length + this.alignmentSeisData.length);
      context.strokeStyle = textcolor;
      context.strokeText("canvas " + textcolor, this.width * 3 / 4, this.height / 4);
      context.beginPath();
      context.fillStyle = "lightblue";
      context.arc(this.currZoomXScale((minX + maxX) / 2), this.yScale((minY + maxY) / 2), radius, 0, 2 * Math.PI, true);
      context.fill();
      context.beginPath();
      context.fillStyle = "lightblue";
      context.arc(this.currZoomXScale(minX), this.yScale(minY), radius, 0, 2 * Math.PI, true);
      context.fill();
      context.beginPath();
      context.fillStyle = "red";
      context.arc(this.currZoomXScale(maxX), this.yScale(minY), radius, 0, 2 * Math.PI, true);
      context.fill();
      context.beginPath();
      context.fillStyle = "green";
      context.arc(this.currZoomXScale(minX), this.yScale(maxY), radius, 0, 2 * Math.PI, true);
      context.fill();
      context.beginPath();
      context.fillStyle = "black";
      context.arc(this.currZoomXScale(maxX), this.yScale(maxY), radius, 0, 2 * Math.PI, true);
      context.fill();
      context.beginPath();
      context.moveTo(this.currZoomXScale(this.currZoomXScale.domain()[0]), this.yScaleRmean(0));
      context.lineTo(this.currZoomXScale(this.currZoomXScale.domain()[1]), this.yScaleRmean(0));
      context.moveTo(0, 0);
      context.lineTo(this.width, this.height);
      context.stroke(); //  this.printSizes();
    }

    calcScaleAndZoom() {
      this.rescaleYAxis(); // check if clip exists, wonky d3 convention

      let container = this.svg.select("defs").select("#" + CLIP_PREFIX + this.plotId);

      if (container.empty()) {
        this.svg.append("defs").append("clipPath").attr("id", CLIP_PREFIX + this.plotId);
      }

      let clip = this.svg.select("defs").select("#" + CLIP_PREFIX + this.plotId);
      clip.selectAll("rect").remove();
      clip.append("rect").attr("width", this.width).attr("height", this.height);
    }

    drawSeismogramsSvg() {
      const sddList = this.seisDataList.concat(this.alignmentSeisData);
      const mythis = this;
      const allSegG = this.g.select("g.allseismograms");
      const traceJoin = allSegG.selectAll("g.seismogram").data(sddList).enter().append("g").attr("label", s => s ? s.label : 'none').attr("codes", s => s.seismogram && s.seismogram.hasCodes() ? s.seismogram.codes() : 'none').classed("seismogram", true);
      traceJoin.exit().remove();
      const subtraceJoin = traceJoin.selectAll('path').data(sdd => sdd.seismogram ? sdd.seismogram.segments : []);
      subtraceJoin.enter().append("path").classed("seispath", true).classed(DRAW_BOTH_ALIGN, this.seismographConfig.drawingType === DRAW_BOTH_ALIGN).attr("style", "clip-path: url(#" + CLIP_PREFIX + mythis.plotId + ")").attr("shape-rendering", "crispEdges").attr("d", function (seg) {
        return mythis.segmentDrawLine(seg, mythis.currZoomXScale);
      });
      subtraceJoin.exit().remove();
    }

    calcSecondsPerPixel(xScale) {
      let domain = xScale.domain(); // time so milliseconds

      let range = xScale.range(); // pixels

      return (domain[1].getTime() - domain[0].getTime()) / 1000 / (range[1] - range[0]);
    }

    segmentDrawLine(seg, xScale) {
      const mythis = this;
      let secondsPerPixel = this.calcSecondsPerPixel(xScale);
      let samplesPerPixel = seg.sampleRate * secondsPerPixel;
      let lineFunc = d3.line().curve(d3.curveLinear).x(function (d) {
        return xScale(d.time);
      }).y(function (d) {
        return mythis.yScale(d.y);
      });

      if (samplesPerPixel < this.seismographConfig.segmentDrawCompressedCutoff) {
        if (!seg.y) {
          // $FlowFixMe
          log("canvasSeis seg.y not defined: " + typeof seg + " " + (seg instanceof Seismogram));
          return;
        }

        return lineFunc(Array.from(seg.y, function (d, i) {
          return {
            time: seg.timeOfSample(i).toDate(),
            y: d
          };
        }));
      } else {
        // lots of points per pixel so use high/low lines
        if (!seg._highlow || seg._highlow.secondsPerPixel !== secondsPerPixel || seg._highlow.xScaleDomain[1] !== xScale.domain()[1]) {
          let highlow = [];
          let numHL = 2 * Math.ceil(seg.y.length / samplesPerPixel);

          for (let i = 0; i < numHL; i++) {
            let snippet = seg.y.slice(i * samplesPerPixel, (i + 1) * samplesPerPixel);

            if (snippet.length !== 0) {
              highlow[2 * i] = snippet.reduce(function (acc, val) {
                return Math.min(acc, val);
              }, snippet[0]);
              highlow[2 * i + 1] = snippet.reduce(function (acc, val) {
                return Math.max(acc, val);
              }, snippet[0]);
            }
          }

          seg._highlow = {
            xScaleDomain: xScale.domain(),
            xScaleRange: xScale.range(),
            secondsPerPixel: secondsPerPixel,
            samplesPerPixel: samplesPerPixel,
            highlowArray: highlow
          };
        }

        return lineFunc(seg._highlow.highlowArray.map(function (d, i) {
          return {
            time: new Date(seg.startTime.valueOf() + 1000 * ((Math.floor(i / 2) + .5) * secondsPerPixel)),
            y: d
          };
        }));
      }
    }

    drawAxis(svgG) {
      svgG.selectAll("g.axis").remove();

      if (this.seismographConfig.isXAxis) {
        this.xAxis.scale(this.currZoomXScale);
        this.xAxis.tickFormat(this.seismographConfig.xScaleFormat);
        svgG.append("g").attr("class", "axis axis--x").attr("transform", "translate(0," + this.height + ")").call(this.xAxis);
      }

      if (this.seismographConfig.isXAxisTop) {
        this.xAxisTop.scale(this.currZoomXScale);
        this.xAxisTop.tickFormat(this.seismographConfig.xScaleFormat);
        svgG.append("g").attr("class", "axis axis--x").call(this.xAxisTop);
      }

      if (this.seismographConfig.isYAxis) {
        this.yAxis.scale(this.yScaleRmean);
        this.yAxis.ticks(8, this.seismographConfig.yScaleFormat);
        svgG.append("g").attr("class", "axis axis--y").call(this.yAxis);
      }

      if (this.seismographConfig.isYAxisRight) {
        this.yAxisRight.scale(this.yScaleRmean);
        this.yAxisRight.ticks(8, this.seismographConfig.yScaleFormat);
        svgG.append("g").attr("class", "axis axis--y-right").attr("transform", "translate(" + this.width + ",0)").call(this.yAxisRight);
      }
    }

    rescaleYAxis() {
      if (!this.beforeFirstDraw) {
        let delay = 500;
        let myThis = this;

        if (this.throttleRescale) {
          window.clearTimeout(this.throttleRescale);
        }

        this.throttleRescale = window.setTimeout(function () {
          if (myThis.seismographConfig.isYAxis) {
            myThis.g.select(".axis--y").transition().duration(delay / 2).call(myThis.yAxis);
          }

          if (myThis.seismographConfig.isYAxisRight) {
            myThis.g.select(".axis--y-right").transition().duration(delay / 2).call(myThis.yAxisRight);
          }

          myThis.throttleRescale = null;
        }, delay);
      }
    }

    drawAxisLabels() {
      this.drawTitle();
      this.drawXLabel();
      this.drawXSublabel();
      this.drawYLabel();
      this.drawYSublabel();
    }

    cloneXScale(scale) {
      let outxScale = d3.scaleUtc();
      outxScale.domain([scale.domain()[0], scale.domain()[1]]);
      outxScale.range([scale.range()[0], scale.range()[1]]);
      return outxScale;
    }

    resetZoom() {
      this.redrawWithXScale(this.cloneXScale(this.origXScale));
    }

    zoomed(mythis) {
      let t = d3.event.transform;
      let xt = t.rescaleX(this.origXScale);
      mythis.redrawWithXScale(xt);
    }

    redrawWithXScale(xt) {
      if (xt.range()[0] === this.currZoomXScale.range()[0] && xt.range()[1] === this.currZoomXScale.range()[1] && xt.domain()[0].getTime() === this.currZoomXScale.domain()[0].getTime() && xt.domain()[1].getTime() === this.currZoomXScale.domain()[1].getTime()) {
        return;
      }

      let prevZoomXScale = this.currZoomXScale;
      this.currZoomXScale = xt;
      let mythis = this;

      if (!this.beforeFirstDraw) {
        this.g.select("g.allseismograms").selectAll("g.seismogram").remove();

        if (this.seismographConfig.windowAmp) {
          this.calcAmpScaleDomain();
        }

        this.drawSeismograms();
        this.g.select("g.allmarkers").selectAll("g.marker").attr("transform", function (marker) {
          let textx = xt(marker.time.toDate());
          return "translate(" + textx + "," + 0 + ")";
        });
        this.g.select("g.allmarkers").selectAll("g.markertext").attr("transform", function () {
          // shift up by this.seismographConfig.markerTextOffset percentage
          let maxY = mythis.yScale.range()[0];
          let deltaY = mythis.yScale.range()[0] - mythis.yScale.range()[1];
          let texty = maxY - mythis.seismographConfig.markerTextOffset * deltaY;
          return "translate(" + 0 + "," + texty + ") rotate(" + mythis.seismographConfig.markerTextAngle + ")";
        });
        this.g.select("g.allmarkers").selectAll("path.markerpath").attr("d", () => {
          return d3.line().x(function () {
            return 0; // g is translated so marker time is zero
          }).y(function (d, i) {
            return i === 0 ? 0 : mythis.yScale.range()[0];
          }).curve(d3.curveLinear)([mythis.yScale.domain()[0], mythis.yScale.domain()[1]]); // call the d3 function created by line with data
        });
        let startEnd = new StartEndDuration(prevZoomXScale.domain()[0], prevZoomXScale.domain()[1]);
        let undrawnMarkers = this.seisDataList.reduce((acc, sdd) => {
          sdd.markerList.forEach(m => acc.push(m));
          return acc;
        }, []).filter(m => !startEnd.contains(m.time));

        if (undrawnMarkers.length !== 0) {
          this.drawMarkers();
        }

        if (this.seismographConfig.isXAxis) {
          this.g.select(".axis--x").call(this.xAxis.scale(xt));
        }

        if (this.seismographConfig.isXAxisTop) {
          this.g.select(".axis--x-top").call(this.xAxisTop.scale(xt));
        }
      }

      this.xScaleChangeListeners.forEach(l => l.notifyScaleChange(xt));
    }

    drawMarkers() {
      let startEnd = new StartEndDuration(this.currZoomXScale.domain()[0], this.currZoomXScale.domain()[1]);
      let allMarkers = this.seisDataList.reduce((acc, sdd) => {
        sdd.markerList.forEach(m => acc.push(m));
        return acc;
      }, []).filter(m => startEnd.contains(m.time)); // marker overlay

      let mythis = this;
      let markerG = this.g.select("g.allmarkers");
      markerG.selectAll("g.marker").remove();
      let labelSelection = markerG.selectAll("g.marker").data(allMarkers, function (d) {
        // key for data
        return "".concat(d.name, "_").concat(d.time.toISOString());
      });
      labelSelection.exit().remove();
      let radianTextAngle = this.seismographConfig.markerTextAngle * Math.PI / 180;
      labelSelection.enter().append("g").classed("marker", true) // translate so marker time is zero
      .attr("transform", function (marker) {
        let textx = mythis.currZoomXScale(marker.time.toDate());
        return "translate(" + textx + "," + 0 + ")";
      }).each(function (marker) {
        let drawG = d3.select(this);
        drawG.classed(marker.name, true).classed(marker.type, true);
        let innerTextG = drawG.append("g").attr("class", "markertext").attr("transform", () => {
          // shift up by this.seismographConfig.markerTextOffset percentage
          let maxY = mythis.yScale.range()[0];
          let deltaY = mythis.yScale.range()[0] - mythis.yScale.range()[1];
          let texty = maxY - mythis.seismographConfig.markerTextOffset * deltaY;
          return "translate(" + 0 + "," + texty + ") rotate(" + mythis.seismographConfig.markerTextAngle + ")";
        });
        innerTextG.append("title").text(marker => {
          if (marker.description) {
            return marker.description;
          } else {
            return marker.name + " " + marker.time.toISOString();
          }
        });
        let textSel = innerTextG.append("text");

        if (marker.link && marker.link.length > 0) {
          // if marker has link, make it clickable
          textSel.append("svg:a").attr("xlink:href", function (marker) {
            return marker.link;
          }).text(function (marker) {
            return marker.name;
          });
        } else {
          textSel.text(function (marker) {
            return marker.name;
          });
        }

        textSel.attr("dy", "-0.35em").call(function (selection) {
          // this stores the BBox of the text in the bbox field for later use
          selection.each(function (t) {
            // set a default just in case
            t.bbox = {
              height: 15,
              width: 20
            };

            try {
              t.bbox = this.getBBox();
            } catch (error) {
              // eslint-disable-next-line no-console
              console.warn(error); // this happens if the text is not yet in the DOM, I think
              //  https://bugzilla.mozilla.org/show_bug.cgi?id=612118
            }
          });
        }); // draw/insert flag behind/before text

        innerTextG.insert("polygon", "text").attr("points", function (marker) {
          let bboxH = marker.bbox.height + 5;
          let bboxW = marker.bbox.width;
          return "0,0 " + -1 * bboxH * Math.tan(radianTextAngle) + ",-" + bboxH + " " + bboxW + ",-" + bboxH + " " + bboxW + ",0";
        }); // let style be in css?
        //              .style("fill", "rgba(220,220,220,.4)");

        drawG.append("path").classed("markerpath", true).attr("d", () => {
          return d3.line().x(0) // g is translated so marker time is zero
          .y(function (d, i) {
            let out = 0;

            if (mythis.seismographConfig.markerFlagpoleBase === 'center') {
              out = i === 0 ? 0 : (mythis.yScale.range()[0] + mythis.yScale.range()[1]) / 2;
            } else {
              // mythis.seismographConfig.markerFlagpoleBase === 'bottom'
              out = i === 0 ? 0 : mythis.yScale.range()[0];
            }

            return out;
          }).curve(d3.curveLinear)([mythis.yScale.domain()[0], mythis.yScale.domain()[1]]); // call the d3 function created by line with data
        });
      });
    }

    calcWidthHeight(nOuterWidth, nOuterHeight) {
      if (nOuterWidth < this.seismographConfig.margin.left + this.seismographConfig.margin.right) {
        throw new Error("width too small for margin: ".concat(nOuterWidth, " < ").concat(this.seismographConfig.margin.left, " + ").concat(this.seismographConfig.margin.right));
      }

      if (nOuterHeight < this.seismographConfig.margin.top + this.seismographConfig.margin.bottom) {
        throw new Error("height too small for margin: ".concat(nOuterWidth, " < ").concat(this.seismographConfig.margin.top, " + ").concat(this.seismographConfig.margin.bottom));
      }

      this.outerWidth = nOuterWidth;
      this.outerHeight = nOuterHeight;
      this.height = this.outerHeight - this.seismographConfig.margin.top - this.seismographConfig.margin.bottom;
      this.width = this.outerWidth - this.seismographConfig.margin.left - this.seismographConfig.margin.right;
      this.origXScale.range([0, this.width]);
      this.yScale.range([this.height, 0]);
      this.yScaleRmean.range([this.height, 0]);

      if (this.seismographConfig.isYAxis) {
        this.yAxis.scale(this.yScaleRmean);
      }

      if (this.seismographConfig.isYAxisRight) {
        this.yAxisRight.scale(this.yScaleRmean);
      }

      this.calcScaleAndZoom();

      if (this.canvas) {
        this.canvasHolder.attr("width", this.width).attr("height", this.height + 1);
        this.canvas.attr("width", this.width).attr("height", this.height + 1);
      }

      const resizeXScale = this.cloneXScale(this.currZoomXScale); // keep same time window
      // but use new pixel range

      resizeXScale.range([0, this.width]); // this updates currZoomXScale

      this.redrawWithXScale(resizeXScale);
    } // see http://blog.kevinchisholm.com/javascript/javascript-function-throttling/


    throttle(func, delay) {
      if (this.throttleResize) {
        window.clearTimeout(this.throttleResize);
      }

      this.throttleResize = window.setTimeout(func, delay);
    }

    resizeNeeded() {
      let myThis = this;
      this.throttle(function () {
        myThis.draw();
      }, 250);
    }

    setMargin(value) {
      this.seismographConfig.margin = value;

      if (!this.beforeFirstDraw) {
        this.calcWidthHeight(this.outerWidth, this.outerHeight);
        this.g.attr("transform", "translate(" + this.seismographConfig.margin.left + "," + this.seismographConfig.margin.top + ")");
      }

      return this;
    }

    drawTitle() {
      this.svg.selectAll("g.title").remove();
      let titleSVGText = this.svg.append("g").classed("title", true).attr("transform", "translate(" + (this.seismographConfig.margin.left + this.width / 2) + ", " + 0 + ")").append("text").classed("title label", true).attr("x", 0).attr("y", 0).attr("text-anchor", "middle");

      if (Array.isArray(this.seismographConfig.title)) {
        this.seismographConfig.title.forEach(function (s) {
          titleSVGText.append("tspan").text(s + " ");
        });
      } else {
        titleSVGText.text(this.seismographConfig.title);
      }
    }

    drawXLabel() {
      this.svg.selectAll("g.xLabel").remove();

      if (this.seismographConfig.xLabel && this.seismographConfig.xLabel.length > 0) {
        this.svg.append("g").classed("xLabel", true).attr("transform", "translate(" + (this.seismographConfig.margin.left + this.width / 2) + ", " + (this.outerHeight - this.seismographConfig.margin.bottom / 3) + ")").append("text").classed("x label", true).attr("text-anchor", "middle").text(this.seismographConfig.xLabel);
      }

      return this;
    }

    drawYLabel() {
      this.svg.selectAll('g.yLabel').remove();

      for (let side of ['left', 'right']) {
        let hTranslate = side === "left" ? 0 : this.seismographConfig.margin.left + this.width + 1;
        let svgText = this.svg.append("g").classed("yLabel", true).classed(side, true).attr("x", 0).attr("transform", "translate(".concat(hTranslate, ", ").concat(this.seismographConfig.margin.top + this.height / 2, ")")).append("text");
        svgText.classed("y label", true);

        if (this.seismographConfig.yLabelOrientation === "vertical") {
          // vertical
          svgText.attr("text-anchor", "middle").attr("dy", ".75em").attr("transform", "rotate(-90, 0, 0)");
        } else {
          // horizontal
          svgText.attr("text-anchor", "start").attr("dominant-baseline", "central");
        }

        if (side === "left") {
          svgText.text(this.seismographConfig.yLabel);
        } else {
          svgText.text(this.seismographConfig.yLabelRight);
        }
      }

      return this;
    }

    drawXSublabel() {
      this.svg.selectAll('g.xSublabel').remove();
      this.svg.append("g").classed("xSublabel", true).attr("transform", "translate(" + (this.seismographConfig.margin.left + this.width / 2) + ", " + this.outerHeight + ")").append("text").classed("x label sublabel", true).attr("text-anchor", "middle").text(this.seismographConfig.xSublabel);
      return this;
    }

    drawYSublabel() {
      this.svg.selectAll('g.ySublabel').remove();
      let svgText = this.svg.append("g").classed("ySublabel", true).attr("x", 0).attr("transform", "translate( " + this.seismographConfig.ySublabelTrans + " , " + (this.seismographConfig.margin.top + this.height / 2) + ")").append("text").classed("y label sublabel", true);

      if (this.seismographConfig.yLabelOrientation === "vertical") {
        // vertical
        svgText.attr("text-anchor", "middle").attr("dy", ".75em").attr("transform", "rotate(-90, 0, 0)");
      } else {
        // horizontal
        svgText.attr("text-anchor", "start").attr("dominant-baseline", "central");
      }

      svgText.text(this.seismographConfig.ySublabel);
      return this;
    }

    calcTimeScaleDomain() {
      let timeWindow;

      if (this.seismographConfig.fixedTimeScale) {
        timeWindow = this.seismographConfig.fixedTimeScale;
      } else {
        timeWindow = findStartEnd(this.seisDataList);
      }

      if (!isDef(this.origXScale)) {
        this.origXScale = d3.scaleUtc();
      }

      this.origXScale.domain([timeWindow.startTime.toDate(), timeWindow.endTime.toDate()]); // force to be same but not to share same array

      this.currZoomXScale = this.cloneXScale(this.origXScale);
    }

    calcAmpScaleDomain() {
      const oldMinMax = this.yScaleData.domain();

      if (this.seismographConfig.fixedYScale) {
        this.yScaleData.domain(this.seismographConfig.fixedYScale);
        this.yScale.domain(this.seismographConfig.fixedYScale);
      } else {
        let minMax;

        if (this.seismographConfig.windowAmp) {
          let timeWindow = new StartEndDuration(this.currZoomXScale.domain()[0], this.currZoomXScale.domain()[1]);
          minMax = findMinMaxOverTimeRange(this.seisDataList, timeWindow);
        } else {
          minMax = findMinMax(this.seisDataList);
        }

        if (minMax[0] === minMax[1]) {
          // flatlined data, use -1, +1
          minMax = [minMax[0] - 1, minMax[1] + 1];
        }

        this.yScaleData.domain(minMax);

        if (this.linkedAmpScale) {
          if (oldMinMax[0] !== minMax[0] || oldMinMax[1] !== minMax[1]) {
            this.linkedAmpScale.recalculate(); // sets yScale.domain
          }
        } else {
          this.yScale.domain(minMax);

          if (this.seismographConfig.isYAxisNice) {
            this.yScale.nice();
          }

          this.redoDisplayYScale();
        }
      }
    }

    redoDisplayYScale() {
      let niceMinMax = this.yScale.domain();

      if (this.seismographConfig.doGain && this.seisDataList.length > 0 && this.seisDataList.every(sdd => sdd.hasSensitivity()) && this.seisDataList.every(sdd => sdd.seismogram.yUnit === COUNT_UNIT)) {
        // each has seisitivity
        const firstSensitivity = this.seisDataList[0].sensitivity;

        if (isDef(firstSensitivity) && this.seisDataList.every(sdd => isDef(firstSensitivity) && sdd.sensitivity && firstSensitivity.sensitivity === sdd.sensitivity.sensitivity && firstSensitivity.inputUnits === sdd.sensitivity.inputUnits && firstSensitivity.outputUnits === sdd.sensitivity.outputUnits)) {
          niceMinMax[0] = niceMinMax[0] / firstSensitivity.sensitivity;
          niceMinMax[1] = niceMinMax[1] / firstSensitivity.sensitivity;

          if (this.seismographConfig.ySublabelIsUnits) {
            this.seismographConfig.ySublabel = firstSensitivity.inputUnits;
          }
        } else {
          throw new Error("doGain with different seisitivities not yet implemented.");
        }
      } else {
        if (this.seismographConfig.ySublabelIsUnits) {
          this.seismographConfig.ySublabel = "";
          let allUnits = [];

          for (let t of this.seisDataList) {
            if (t.seismogram) {
              let u = t.seismogram.yUnit;
              allUnits.push(u);
              this.seismographConfig.ySublabel += "".concat(u, " ");
            }
          }

          if (allUnits.length === 0) {
            allUnits.push("Count");
          }

          this.seismographConfig.ySublabel = allUnits.join(' ');
        }
      }

      if (this.seismographConfig.doRMean) {
        this.seismographConfig.ySublabel = "centered ".concat(this.seismographConfig.ySublabel);
        this.yScaleRmean.domain([(niceMinMax[0] - niceMinMax[1]) / 2, (niceMinMax[1] - niceMinMax[0]) / 2]);
      } else {
        this.yScaleRmean.domain(niceMinMax);
      }

      this.rescaleYAxis();
      this.drawYSublabel();
    }

    getSeismogramData() {
      return this.seisDataList;
    }
    /**
     * can append single seismogram segment or an array of segments.
     *
     * @param sddList array or single SeismogramDisplayData or Seismogram
     * @private
     */


    _internalAppend(sddList) {
      if (!sddList) ; else if (Array.isArray(sddList)) {
        for (let s of sddList) {
          if (s instanceof SeismogramDisplayData) {
            this.seisDataList.push(s);
          } else {
            this.seisDataList.push(SeismogramDisplayData.fromSeismogram(s));
          }
        }
      } else {
        if (sddList instanceof SeismogramDisplayData) {
          this.seisDataList.push(sddList);
        } else {
          this.seisDataList.push(SeismogramDisplayData.fromSeismogram(sddList));
        }
      }
    }
    /**
     * appends the seismogram(s) or SeismogramDisplayData as separate time series.
     *
     * @param seismogram data to append
     * @returns this Seismograph
     */


    append(seismogram) {
      if (seismogram instanceof SeismogramDisplayData) {
        this._internalAppend(seismogram);
      } else if (Array.isArray(seismogram)) {
        let sdd = seismogram.map(s => SeismogramDisplayData.fromSeismogram(s));

        this._internalAppend(sdd);
      } else if (seismogram instanceof Seismogram) {
        this._internalAppend(SeismogramDisplayData.fromSeismogram(seismogram));
      } else {
        throw new Error("Unable to append, doesn't look like Array of Seismogram, Seismogram or SeismogramDisplayData: ".concat(seismogram.constructor.name));
      }

      this.calcAmpScaleDomain();

      if (!this.beforeFirstDraw) {
        // only trigger a draw if appending after already drawn on screen
        // otherwise, just append the data and wait for outside to call first draw()
        this.drawSeismograms();
      }

      return this;
    }
    /**
     * Finds the SeismogramDisplayData within the display containing the given
     * Seismogram.
     *
     * @param   seis seismogram to search for
     * @returns       SeismogramDisplayData if found or null if not
     */


    getDisplayDataForSeismogram(seis) {
      let out = this.seisDataList.find(sd => sd.seismogram === seis);

      if (out) {
        return out;
      } else {
        return null;
      }
    }
    /**
     * Removes a seismogram from the display.
     *
     * @param   seisData seis data to remove
     */


    remove(seisData) {
      this.seisDataList = this.seisDataList.filter(sd => sd !== seisData);
    }
    /**
     * Removes seismograms that do not overlap the window.
     *
     * @param   timeWindow overlap data to keep
     */


    trim(timeWindow) {
      if (this.seisDataList) {
        this.seisDataList = this.seisDataList.filter(function (d) {
          return d.timeWindow.overlaps(timeWindow);
        });

        if (this.seisDataList.length > 0) {
          this.calcAmpScaleDomain();
          this.drawSeismograms();
        }
      }
    }

    linkXScaleTo(seismograph) {
      this.origXScale.domain(seismograph.origXScale.domain());
      this.currZoomXScale.domain(seismograph.currZoomXScale.domain());

      if (!this.beforeFirstDraw && seismograph.currZoomXScale.range()[1] !== 1) {
        // default range is 0,1, so don't draw then.
        this.redrawWithXScale(seismograph.currZoomXScale);
      }

      if (!this.xScaleChangeListeners.find(l => l.destinationKey === seismograph)) {
        this.xScaleChangeListeners.push({
          destinationKey: seismograph,
          notifyScaleChange: function notifyScaleChange(xScale) {
            if (!seismograph.beforeFirstDraw) {
              seismograph.redrawWithXScale(xScale);
            }
          }
        });
      }

      if (!seismograph.xScaleChangeListeners.find(l => l.destinationKey === this)) {
        seismograph.linkXScaleTo(this);
      }
    }

    unlinkXScaleTo(seismograph) {
      this.xScaleChangeListeners = this.xScaleChangeListeners.filter(l => l.destinationKey !== seismograph);

      if (seismograph.xScaleChangeListeners.find(l => l.destinationKey === this)) {
        seismograph.unlinkXScaleTo(this);
      }
    }

  }
  /**
   * Links amplitude scales across multiple seismographs, respecting doRmean.
   *
   * @param graphList optional list of Seismographs to link
   */

  class LinkedAmpScale {
    /**
     * @private
     */
    constructor(graphList) {
      const glist = graphList ? graphList : []; // in case null

      this._graphSet = new Set(glist);

      this._graphSet.forEach(g => {
        g.linkedAmpScale = this;
      });
    }
    /**
     * Link new Seismograph with this amplitude scale.
     *
     * @param   graph Seismograph to link
     */


    link(graph) {
      this._graphSet.add(graph);

      graph.linkedAmpScale = this;
      this.recalculate();
    }
    /**
     * Unlink Seismograph with this amplitude scale.
     *
     * @param   graph Seismograph to unlink
     */


    unlink(graph) {
      this._graphSet.delete(graph);

      this.recalculate();
    }
    /**
     * Recalculate the best amplitude scale for all Seismographs. Causes a redraw.
     */


    recalculate() {
      const graphList = Array.from(this._graphSet.values());
      const maxRange = graphList.reduce((acc, cur) => {
        let graphMaxRange = cur.yScaleData.domain()[1] - cur.yScaleData.domain()[0];
        return acc > graphMaxRange ? acc : graphMaxRange;
      }, 0);
      const min = graphList.reduce((acc, cur) => {
        let graphMin = cur.yScaleData.domain()[0];
        return acc < graphMin ? acc : graphMin;
      }, Number.MAX_SAFE_INTEGER);
      const max = graphList.reduce((acc, cur) => {
        let graphMax = cur.yScaleData.domain()[1];
        return acc > graphMax ? acc : graphMax;
      }, -1 * Number.MAX_SAFE_INTEGER);
      graphList.forEach(g => {
        if (g.seismographConfig.doRMean) {
          const mean = (g.yScaleData.domain()[1] + g.yScaleData.domain()[0]) / 2;
          g.yScale.domain([mean - maxRange / 2, mean + maxRange / 2]);
          g.yScaleRmean.domain([-1 * maxRange / 2, maxRange / 2]);
        } else {
          g.yScale.domain([min, max]);
          g.yScaleRmean.domain([min, max]);
        }

        g.redoDisplayYScale();

        if (!g.beforeFirstDraw) {
          // only trigger a draw if appending after already drawn on screen
          // otherwise, just append the data and wait for outside to call first draw()
          g.draw();
        }
      });
    }

  } // static ID for seismogram

  Seismograph._lastID = 0;
  /**
   * Creates Markers for all of the arrivals in ttime.arrivals, relative
   * to the given Quake.
   *
   * @param   quake quake the travel times are relative to
   * @param   ttime travel times json object as returned from the
   * IRIS traveltime web service, or the json output of TauP
   * @returns        array of Markers suitable for adding to a seismograph
   */

  function createMarkersForTravelTimes(quake, ttime) {
    return ttime.arrivals.map(a => {
      return {
        type: 'predicted',
        name: a.phase,
        time: moment__default.utc(quake.time).add(a.time, 'seconds')
      };
    });
  }
  const seismograph_css = "\n\n\n.marker .markerpath {\n  fill: none;\n  stroke: black;\n  stroke-width: 1px;\n}\n\n.marker polygon {\n  fill: rgba(150,220,150,.4);\n}\n\n.marker.predicted polygon {\n  fill: rgba(220,220,220,.4);\n}\n\n.marker.pick polygon {\n  fill: rgba(255,100,100,.4);\n}\n\npath.seispath {\n  stroke: skyblue;\n  fill: none;\n  stroke-width: 1px;\n}\n\npath.orientZ {\n  stroke: seagreen;\n}\n\npath.orientN {\n  stroke: cornflowerblue;\n}\n\npath.orientE {\n  stroke: orange;\n}\n\npath.alignment {\n  stroke-dasharray: 8;\n  stroke-width: 2px;\n}\n\nsvg.seismograph {\n  height: 100%;\n  width: 100%;\n  min-height: 25px;\n  min-width: 25px;\n}\n\nsvg.seismograph g.ySublabel text {\n  font-size: smaller;\n}\n\nsvg.seismograph g.xSublabel text {\n  font-size: smaller;\n}\n\nsvg.seismograph text.title {\n  font-size: larger;\n  font-weight: bold;\n  fill: black;\n  color: black;\n  dominant-baseline: hanging;\n}\n\nsvg.realtimePlot g.allseismograms path.seispath {\n  stroke: skyblue;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+1) path.seispath {\n  stroke: skyblue;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+2) path.seispath {\n  stroke: olivedrab;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+3) path.seispath {\n  stroke: goldenrod;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+4) path.seispath {\n  stroke: firebrick;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+5) path.seispath {\n  stroke: darkcyan;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+6) path.seispath {\n  stroke: orange;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+7) path.seispath {\n  stroke: darkmagenta;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+8) path.seispath {\n  stroke: mediumvioletred;\n}\n\nsvg.seismograph g.allseismograms g:nth-child(9n+9) path.seispath {\n  stroke: sienna;\n}\n\n/* same colors for titles */\n\nsvg.seismograph g.title text tspan:nth-child(9n+1)  {\n  fill: skyblue;\n}\n\nsvg.seismograph g.title text tspan:nth-child(9n+2)  {\n  stroke: olivedrab;\n}\n\nsvg.seismograph g.title text tspan:nth-child(9n+3)  {\n  stroke: goldenrod;\n}\n\nsvg.seismograph g.title tspan:nth-child(9n+4)  {\n  stroke: firebrick;\n}\n\nsvg.seismograph g.title tspan:nth-child(9n+5)  {\n  stroke: darkcyan;\n}\n\nsvg.seismograph g.title tspan:nth-child(9n+6)  {\n  stroke: orange;\n}\n\nsvg.seismograph g.title tspan:nth-child(9n+7)  {\n  stroke: darkmagenta;\n}\n\nsvg.seismograph g.title tspan:nth-child(9n+8)  {\n  stroke: mediumvioletred;\n}\n\nsvg.seismograph g.title tspan:nth-child(9n+9)  {\n  stroke: sienna;\n}\n\n\n/* links in svg */\nsvg.seismograph text a {\n  fill: #0000EE;\n  text-decoration: underline;\n}\n\n";

  if (document) {
    insertCSS(seismograph_css);
  }

  var seismograph = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Seismograph: Seismograph,
    LinkedAmpScale: LinkedAmpScale,
    createMarkersForTravelTimes: createMarkersForTravelTimes,
    seismograph_css: seismograph_css
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * A helicorder-like multi-line seismogram display usually covering 24 hours
   * 
   * @param inSvgParent the parent element, usually a div tag
   * @param heliConfig configuration object
   * @param seisData the data to display
   */

  class Helicorder {
    constructor(inSvgParent, heliConfig, seisData) {
      this.seismographArray = [];
      this.seisData = seisData;

      if (typeof inSvgParent === 'string') {
        this.svgParent = d3.select(inSvgParent);
      } else {
        this.svgParent = inSvgParent;
      }

      this.svgParent = this.svgParent.append('div').classed('helicorder', true);
      this.heliConfig = heliConfig;
    }
    /**
     * draws, or redraws, the helicorder.
     */


    draw() {
      this.heliConfig.lineSeisConfig.doRMean = this.heliConfig.doRMean;
      this.drawSeismograms();
    }
    /**
     * draws or redraws the seismograms in the helicorder
     *
     * @private
     */


    drawSeismograms() {
      if (!this.seisData) {
        // no data
        return;
      }

      const timeWindow = this.heliConfig.fixedTimeScale;

      if (!isDef(timeWindow)) {
        throw new Error("Helicorder config must have fixedTimeScale set");
      }

      let maxVariation = 1;

      if (this.seisData.seismogram) {
        const seis = this.seisData.seismogram; // for flow

        if (!this.heliConfig.fixedYScale) {
          if (this.heliConfig.maxVariation === 0) {
            let cutSeis = seis.cut(timeWindow);

            if (cutSeis) {
              let [min, max] = cutSeis.findMinMax();
              let mean = cutSeis.mean();
              let posOffset = max - mean;
              let negOffset = mean - min;
              maxVariation = Math.max(posOffset, negOffset);
            }
          } else {
            maxVariation = this.heliConfig.maxVariation;
          }
        }
      }

      let startTime = moment__default.utc(timeWindow.startTime);
      this.seismographArray = [];
      const secondsPerLine = timeWindow.duration.asSeconds() / this.heliConfig.numLines;
      this.svgParent.selectAll("div.heliLine").remove();
      let lineTimes = this.calcTimesForLines(startTime, secondsPerLine, this.heliConfig.numLines);
      const margin = this.heliConfig.margin;
      const nl = this.heliConfig.numLines;
      const baseHeight = (this.heliConfig.maxHeight - margin.top - margin.bottom) / (nl - (nl - 1) * this.heliConfig.overlap);

      for (let lineTime of lineTimes) {
        let startTime = lineTime.startTime;
        let endTime = lineTime.endTime;
        let height = baseHeight;
        let marginTop = lineTime.lineNumber === 0 ? 0 : Math.round(-1.0 * height * this.heliConfig.overlap);
        let lineSeisConfig = this.heliConfig.lineSeisConfig.clone();

        if (lineTime.lineNumber === 0) {
          lineSeisConfig.title = this.heliConfig.title;
          lineSeisConfig.isXAxisTop = this.heliConfig.isXAxisTop;
          lineSeisConfig.margin.top += this.heliConfig.margin.top;
          height += this.heliConfig.margin.top;
        } else if (lineTime.lineNumber === nl - 1) {
          lineSeisConfig.isXAxis = this.heliConfig.isXAxis;
          lineSeisConfig.margin.bottom += this.heliConfig.margin.bottom;
          height += this.heliConfig.margin.bottom;
        }

        let seisDiv = this.svgParent.append('div').classed('heliLine', true).style('height', height + 'px').style('margin-top', marginTop + 'px');
        lineSeisConfig.fixedTimeScale = lineTime;
        lineSeisConfig.yLabel = "".concat(startTime.format("HH:mm"));
        lineSeisConfig.yLabelRight = "".concat(endTime.format("HH:mm"));
        lineSeisConfig.lineColors = [seisDiv.style("color")];
        let lineCutSeis = null;
        let lineSeisData;
        let lineMean = 0;

        if (this.seisData.seismogram) {
          lineCutSeis = this.seisData.seismogram.cut(lineTime);
          lineSeisData = this.seisData.cloneWithNewSeismogram(lineCutSeis);
          lineMean = lineSeisData.mean;
        } else {
          // no data in window, but keep seisData in case of markers, etc
          lineSeisData = this.seisData.clone();
        }

        lineSeisData.timeWindow = lineTime;

        if (this.heliConfig.fixedYScale) {
          lineSeisConfig.fixedYScale = this.heliConfig.fixedYScale;
        } else {
          if (this.heliConfig.doRMean) {
            lineSeisConfig.fixedYScale = [lineMean - maxVariation, lineMean + maxVariation];
          } else {
            lineSeisConfig.fixedYScale = [lineMean - maxVariation, lineMean + maxVariation];
          }
        }

        let seismograph = new Seismograph(seisDiv, lineSeisConfig, lineSeisData);
        seismograph.draw();

        if (lineTime.lineNumber === 0) {
          // add UTC to top left
          seismograph.svg.append("g").classed("yLabel", true).classed("utcLabel", true).append("text").attr("x", 0).attr("y", 0).attr("text-anchor", "start").attr("dy", ".75em").text("UTC");
        }

        this.seismographArray.push(seismograph);
        startTime = endTime;
      }
    }
    /**
     * Calculates the time range covered by each line of the display
     *
     * @param   startTime      start of display
     * @param   secondsPerLine seconds covered by each line
     * @param   numberOfLines  number of lines
     * @returns Array of HeliTimeRange, one per line
     */


    calcTimesForLines(startTime, secondsPerLine, numberOfLines) {
      let out = [];
      let s = moment__default.utc(startTime);

      for (let lineNum = 0; lineNum < numberOfLines; lineNum++) {
        let startEnd = new HeliTimeRange(s, null, secondsPerLine);
        startEnd.lineNumber = lineNum;
        out.push(startEnd);
        s = moment__default.utc(startEnd.endTime);
      }

      return out;
    }

  }
  /**
   * Configuration of the helicorder
   *
   * @param timeWindow the time range covered by the helicorder, required
   */

  class HelicorderConfig extends SeismographConfig {
    constructor(timeWindow) {
      super();

      if (!isDef(timeWindow)) {
        throw new Error("Helicorder config must have fixedTimeScale set");
      }

      this.fixedTimeScale = timeWindow;
      this.maxVariation = 0;
      this.maxHeight = 600;
      this.xLabel = '';
      this.yLabel = '';
      this.xSublabel = '';
      this.ySublabel = ' ';
      this.ySublabelIsUnits = false;
      this.isXAxis = true;
      this.isXAxisTop = true;
      this.isYAxis = false;
      this.overlap = 0.5;
      this.numLines = 12;
      this.margin.left = 20;
      this.margin.right = 20;
      this.margin.top = 40;
      this.lineSeisConfig = new SeismographConfig();
      this.lineSeisConfig.ySublabel = " ";
      this.lineSeisConfig.xLabel = ' ';
      this.lineSeisConfig.yLabel = ''; // replace later with `${startTime.format("HH:mm")}`;

      this.lineSeisConfig.yLabelOrientation = 'horizontal';
      this.lineSeisConfig.ySublabelIsUnits = false;
      this.lineSeisConfig.isXAxis = false;
      this.lineSeisConfig.isYAxis = false;
      this.lineSeisConfig.margin.top = 0;
      this.lineSeisConfig.margin.bottom = 0;
      this.lineSeisConfig.margin.left = 37;
      this.lineSeisConfig.margin.right = 37;
      this.lineSeisConfig.wheelZoom = false;
      this.lineSeisConfig.doRMean = true;
    }

  }
  /**
   * Time range for a single line of the helicorder, extends StartEndDuration
   * to add the line number
   */

  class HeliTimeRange extends StartEndDuration {
    constructor(startTime, endTime, duration = null, clockOffset = 0) {
      super(startTime, endTime, duration, clockOffset);
    }

  }
  /** default styling for helicorder plots. */

  const helicorder_css = "\n\ndiv.helicorder {\n  height: 100%;\n  width: 100%;\n}\n\ndiv.helicorder div.heliLine .yLabel text {\n  font-size: smaller;\n}\n\ndiv.helicorder div.heliLine:nth-child(3n+1) {\n  color: skyblue;\n}\ndiv.helicorder div.heliLine:nth-child(3n+1) path.seispath {\n  stroke: skyblue;\n}\ndiv.helicorder div.heliLine:nth-child(3n+2) {\n  color: olivedrab;\n}\ndiv.helicorder div.heliLine:nth-child(3n+2) path.seispath {\n  stroke: olivedrab;\n}\ndiv.helicorder div.heliLine:nth-child(3n) {\n  color: goldenrod;\n}\ndiv.helicorder div.heliLine:nth-child(3n) path.seispath {\n  stroke: goldenrod;\n}\ndiv.helicorder div.heliLine:nth-child(3n+1) .yLabel text {\n  fill: skyblue;\n}\ndiv.helicorder div.heliLine:nth-child(3n+2) .yLabel text {\n  fill: olivedrab;\n}\ndiv.helicorder div.heliLine:nth-child(3n) .yLabel text {\n  fill: goldenrod;\n}\n\n";

  if (document) {
    insertCSS(helicorder_css);
  }

  var helicorder = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Helicorder: Helicorder,
    HelicorderConfig: HelicorderConfig,
    HeliTimeRange: HeliTimeRange,
    helicorder_css: helicorder_css
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  //import type { moment as momentType } from 'moment';

  const DS = "fdsnws-dataselect";
  const EV = "fdsn-event";
  const ST = "fdsn-station";
  const RS = "ringserver";
  const BestDCIdMap = new Map();

  function initBestDCIdMap() {
    BestDCIdMap.set(knownDataCenters.DS, "IRIS");
    BestDCIdMap.set(ST, "IRIS");
    BestDCIdMap.set(RS, "IRIS");
    BestDCIdMap.set(EV, "USGS");
  }

  let knownDCs = null;
  /**
   * Lookup system for FDSN web services, predates the new FDSN DataCenters
   * web service, which is now the preferred method, as this may be out of date.
   * 
   */

  const knownDataCenters = {
    knownDataCentersJsonURL: checkProtocol() + "//www.seis.sc.edu/fdsnServiceCheck/fdsnDataCenters.json",
    DS: DS,
    EV: EV,
    ST: ST,
    RS: RS,
    allDCTypes: [DS, EV, ST, RS],

    getDefaultDC(type) {
      return this.getDataCenter(BestDCIdMap.get(type));
    },

    /**
     * Loads all known data centers. JSON top level has:
     *  created - modification date,
     *  datacenters - array of objects, each with
     *  id, name, website, email, host, region and
     *  and supports that is an array of type and version.
     *
     *  @returns a Promise that resolves to the returned json.
     */
    getKnownDataCenters() {
      if (!knownDCs) {
        knownDCs = fetch(this.knownDataCentersJsonURL).then(response => {
          return response.json();
        }).then(function (json) {
          json.accesstime = moment__default.utc();
          return json;
        });
      }

      return knownDCs;
    },

    /**
     * Forces a reload of the remote json. In general, because the data
     *  is updated infrequently, this is unlikely to be needed. However,
     *  a very long running instance may wish to update this periodically,
     *  likely at most daily.
     *
     *  @returns a Promise to known datacenters.
     */
    updateKnownDataCenters() {
      knownDCs = null;
      return this.getKnownDataCenters();
    },

    /**
     * Gets the data center associated with the id.
     *
     * @param id string id
     * @returns a Promise to data center
     */
    getDataCenter(id) {
      return this.getKnownDataCenters().then(kdcs => {
        for (const dc of kdcs.datacenters) {
          if (dc.id === id) {
            return dc;
          }
        }

        return null;
      });
    },

    /**
     *
     * @param dc data center
     * @param type type of service
     * @returns true is the dc datacenter supports type web service,
     * false otherwise.
     */
    doesSupport(dc, type) {
      let out = dc.supports.find(function (s) {
        return s.type === type;
      });
      return typeof out !== 'undefined';
    },

    /**
     * returns the hostname for type web service. In many cases this
     *  is the same as the host for the overall datacenter, but sometimes
     *  not all web services are hosted on the same machine. For example
     *  all fdsn web services at IRIS are hosted at service.iris.edu
     *  but the ringserver is hosted at rtserve.iris.edu
     *
     * @param dc data center
     * @param type type of service
     * @returns host
     */
    serviceHost(dc, type) {
      let does = this.doesSupport(dc, type);

      if (does) {
        return does.host ? does.host : dc.host;
      }

      throw new Error(dc.id + " does not support " + type);
    },

    /**
     * returns the port for type web service. In many cases this
     *  is 80, but sometimes web services are hosted on alternative
     *  ports.
     *
     * @param dc data center
     * @param type type of service
     * @returns port number
     */
    servicePort(dc, type) {
      let does = this.doesSupport(dc, type);

      if (does) {
        return does.port ? does.port : 80;
      }

      throw new Error(dc.id + " does not support " + type);
    }

  };
  initBestDCIdMap();

  var knowndatacenters = /*#__PURE__*/Object.freeze({
    __proto__: null,
    knownDataCenters: knownDataCenters
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const Allowed_Flags = ['n', 's', 'l', 'c', 'Y', 'j', 'H'];
  /**
   * A web based connection to an archive of miniseed files
   * arranged based on a pattern using n, s, l, c, Y, j, H
   * for network, station, locid, channel, year, day of year
   * and hour. This is a subset of the options available within
   * the IRIS Ringserver MSeedArchive option, on which this
   * is based. Retrieved seismograms are cut from the larger
   * miniseed files retrieved via http(s), and so there is
   * wasted bandwidth to the server. On the other hand this
   * requires no extra software on the server side beyond
   * a directory structure with suitably small miniseed files.
   * Generally we find channel-hour is a reasonable size for
   * most seismic channels. The URL to needed files is
   * constructed by concatenating the rootUrl with the pattern
   * using a time range large enough to get all overlaps
   * based on the smallest sample rate per channel band code
   * and record size, which defaults to 512.
   *
   */

  class MSeedArchive {
    constructor(rootUrl, pattern) {
      this._rootUrl = rootUrl;
      this._pattern = pattern;
      this._recordSize = 512;
      this._timeoutSec = 30;
      this.checkPattern(this._pattern);
    }

    get rootUrl() {
      return this._rootUrl;
    }

    get pattern() {
      return this._pattern;
    }

    get recordSize() {
      return this._recordSize;
    }
    /**
     * checks pattern for allowed flags as not all that are supported
     * by ringserver are supported here. Must only include:
     * * n network code, white space removed
     * * s station code, white space removed
     * * l  location code, white space removed
     * * c  channel code, white space removed
     * * Y  year, 4 digits
     * * j  day of year, 3 digits zero padded
     * * H  hour, 2 digits zero padded
     *
     * @param p mseed archive pattern string
     * @returns true if all flags are allowed
     */


    checkPattern(p) {
      let regexp = /%[a-zA-Z]/g;
      let allFlags = p.match(regexp);

      if (!allFlags) {
        return false;
      } else {
        for (let f of allFlags) {
          if (Allowed_Flags.indexOf(f.slice(1)) === -1) {
            throw new Error("".concat(f, " not allowed in pattern"));
          }
        }
      }

      return true;
    }
    /**
     * Loads seismograms from the remote miniseed archive via
     * http(s). Files downloaded include all that might overlap
     * the given time window based on record size,
     * the minimum sample rate
     * for the channel band code and the given time window.
     *
     * @param   channelTimeList requst channels and time windows
     * @returns Promise to the same SeismogramDisplayData array, but with seismograms populated
     */


    loadSeismograms(channelTimeList) {
      let promiseArray = channelTimeList.map(ct => {
        if (isDef(ct.channel)) {
          const channel = ct.channel;
          return RSVP.hash({
            "request": ct,
            "dataRecords": this.loadDataForChannel(channel, ct.startTime, ct.endTime)
          });
        } else {
          throw new Error("channel is missing in loadSeismograms ");
        }
      });
      return RSVP.all(promiseArray).then(pArray => {
        let out = [];
        pArray.forEach(p => {
          let seisArray = seismogramPerChannel(p.dataRecords); // should only be one

          for (let seis of seisArray) {
            let cutSeis = seis.cut(new StartEndDuration(p.request.startTime, p.request.endTime));
            p.request.seismogram = cutSeis;
            out.push(p.request);
          }
        });
        return out;
      });
    }
    /**
     * Loads miniseed records based on channel and time window.
     *
     * @param   channel   channel to request
     * @param   startTime start time
     * @param   endTime   end time
     * @returns Promise to array of miniseed records
     */


    loadDataForChannel(channel, startTime, endTime) {
      return this.loadData(channel.station.network.networkCode, channel.station.stationCode, channel.locationCode, channel.channelCode, startTime, endTime, channel.sampleRate);
    }
    /**
     * Loads miniseed records based on string channel codes.
     *
     * @param   net        network code
     * @param   sta        station code
     * @param   loc        location code
     * @param   chan       channel code
     * @param   startTime  start time
     * @param   endTime    end time
     * @param   sampleRate known sample rate for this channel
     * @returns             Promise to array of miniseed records
     */


    loadData(net, sta, loc, chan, startTime, endTime, sampleRate) {
      let basePattern = this.fillBasePattern(net, sta, loc, chan);

      if (!isDef(sampleRate)) {
        sampleRate = minSampleRate(chan);
      }

      let recordTime = maxTimeForRecord(this._recordSize, sampleRate);
      let t = moment__default.utc(startTime).subtract(recordTime, 'seconds');
      let urlList = [];

      while (t.isBefore(endTime)) {
        let url = this.rootUrl + '/' + this.fillTimePattern(basePattern, t);
        t.add(1, 'hour');
        urlList.push(url);
      }

      if (moment__default.utc(t).add(recordTime, 'seconds').isAfter(endTime)) {
        let url = this.rootUrl + '/' + this.fillTimePattern(basePattern, t);
        urlList.push(url);
      }

      return loadDataRecords(urlList).then(dataRecords => {
        if (dataRecords) {
          dataRecords = dataRecords.filter(dr => dr.header.endTime.isSameOrAfter(startTime) && dr.header.startTime.isSameOrBefore(endTime));
        } else {
          dataRecords = []; // for flow
        }

        return dataRecords;
      });
    }
    /**
     * Replaces codes from channel in base pattern.
     *
     * @param   net  string to replace '%n'
     * @param   sta  string to replace '%s'
     * @param   loc  string to replace '%l'
     * @param   chan string to replace '%c'
     * @returns       new string with channel replacements made
     */


    fillBasePattern(net, sta, loc, chan) {
      return this.pattern.replace(/%n/g, net).replace(/%s/g, sta).replace(/%l/g, loc).replace(/%c/g, chan);
    }
    /**
     * Replaces time entries ( %Y, %j, %H ) in pattern.
     *
     * @param   basePattern pattern to replace in
     * @param   t           moment in time
     * @returns              string with time replaces
     */


    fillTimePattern(basePattern, t) {
      return basePattern.replace(/%Y/g, t.format('YYYY')).replace(/%j/g, t.format('DDDD')).replace(/%H/g, t.format('HH'));
    }

  }
  function loadDataRecords(urlList, fetchInit, timeoutSec) {
    let promiseArray = urlList.map(url => {
      return doFetchWithTimeout(url, fetchInit, timeoutSec).then(fetchResponse => {
        if (fetchResponse.ok) {
          if (fetchResponse.status === 200 || fetchResponse.status === 304) {
            return fetchResponse.arrayBuffer().then(ab => {
              let dataRecords = [];

              if (ab.byteLength > 0) {
                dataRecords = parseDataRecords(ab);
              }

              return dataRecords;
            });
          } else if (fetchResponse.status === 404) {
            return []; // empty array means no data
          } else {
            log("no data: status=" + fetchResponse.status + " " + fetchResponse.url);
            return [];
          }
        } else if (fetchResponse.status === 404) {
          return []; // empty array means no data
        } else {
          // $FlowFixMe
          throw new Error("fetch error: " + fetchResponse.ok + " " + fetchResponse.status + " " + fetchResponse.url);
        }
      }).catch(err => {
        log("caught fetch err, continuing with empty: " + err);
        return [];
      });
    });
    return RSVP.all(promiseArray).then(pArray => {
      let dataRecords = [];
      pArray.forEach(p => {
        dataRecords = dataRecords.concat(p);
      });
      return dataRecords;
    });
  }
  /**
   * Gives the maximum sample rate for the channel, based on the
   * band code, first char, of the channel code.
   *
   * @param chan channel code like BHZ, only the first letter is used
   * @returns mimumum sample rate this could be
   */

  function maxSampleRate(chan) {
    let f = chan.slice(0, 1);

    switch (f) {
      case 'F':
      case 'G':
        return 5000;

      case 'D':
      case 'C':
        return 1000;

      case 'E':
      case 'H':
        return 250;

      case 'S':
      case 'B':
        return 80;

      case 'M':
        return 10;

      case 'L':
        return 1;

      case 'V':
        return .1;

      case 'U':
        return .01;

      case 'R':
        return .001;

      case 'P':
        return .0001;

      case 'Q':
        return .000001;

      default:
        throw new Error("Unknown band code " + f + " in " + chan);
    }
  }
  /**
   * Gives the minimum sample rate for the channel, based on the
   * band code, first char, of the channel code.
   *
   * @param chan channel code like BHZ, only the first letter is used
   * @returns mimumum sample rate this could be
   **/

  function minSampleRate(chan) {
    let f = chan.slice(0, 1);

    switch (f) {
      case 'F':
      case 'G':
        return 1000;

      case 'D':
      case 'C':
        return 2500;

      case 'E':
      case 'H':
        return 80;

      case 'S':
      case 'B':
        return 10;

      case 'M':
        return 1;

      case 'L':
        return 1;
      // maybe wrong, seed manual not clear

      case 'V':
        return .1;
      // maybe wrong, seed manual not clear

      case 'U':
        return .01;
      // maybe wrong, seed manual not clear

      case 'R':
        return .0001;

      case 'P':
        return .00001;

      case 'Q':
        return .0000001;

      default:
        throw new Error("Unknown band code " + f + " in " + chan);
    }
  }
  /** Calculates the maximum time coverage for a single miniseed record
   * given the record size (usually 512 or 4096) and the sample rate (Hertz).
   * This assumes 40 bytes of header and maximum compression of 2 samples
   * per byte (4 bit per sample) which is the best Steim2.
   *
   * @param recordSize record size (usually 512 or 4096)
   * @param sampleRate sample rate of record
   * @returns maximum interval of time that a full record could cover when
   * compression is at its most efficient
   */

  function maxTimeForRecord(recordSize, sampleRate) {
    return (recordSize - 40) * 2 / sampleRate;
  }

  var mseedarchive = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Allowed_Flags: Allowed_Flags,
    MSeedArchive: MSeedArchive,
    loadDataRecords: loadDataRecords,
    maxSampleRate: maxSampleRate,
    minSampleRate: minSampleRate,
    maxTimeForRecord: maxTimeForRecord
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */

  /**
   * Returns an array of Promises, one per selected element. This assumes each
   * element has some combination of start, end, duration, net, sta, loc, and chan
   * attributes sufficient to form the data query. Or an href to a miniseed file.
   *
   * @param selector css selector
   * @returns promise to array of plot data types
   */
  function createPlotsBySelectorPromise(selector) {
    let out = [];
    d3.selectAll(selector).each(function () {
      let svgParent = d3.select(this);
      let url;
      let startAttr = svgParent.attr("start") ? svgParent.attr("start") : null;
      let endAttr = svgParent.attr("end") ? svgParent.attr("end") : null;
      let duration = svgParent.attr("duration");
      let timeWindow = null;

      if (isDef(startAttr) || isDef(endAttr) || isDef(duration)) {
        timeWindow = new StartEndDuration(startAttr, endAttr, duration);
      } else {
        throw new Error("Need at least one of start, end, duration.");
      }

      if (svgParent.attr("href")) {
        // url to miniseed file
        url = svgParent.attr("href");
        out.push(fetch(url).then(response => {
          if (response.ok) {
            return response.arrayBuffer();
          } else {
            throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
          }
        }).then(ab => {
          let seismograms = seismogramPerChannel(parseDataRecords(ab));
          let sddList = seismograms.map(s => {
            let sdd = SeismogramDisplayData.fromSeismogram(s);

            if (timeWindow) {
              sdd.timeWindow = timeWindow;
            }

            return sdd;
          });
          return {
            "sddList": sddList,
            "svgParent": svgParent
          };
        }));
      } else {
        let net = svgParent.attr("net");
        let sta = svgParent.attr("sta");
        let loc = svgParent.attr("loc");
        let chan = svgParent.attr("chan");

        if (!(net && sta && loc && chan)) {
          throw new Error("Must set all of net, sta, loc, chan, but got ".concat(net, ", ").concat(sta, ", ").concat(loc, ", ").concat(chan));
        }

        let host = svgParent.attr("host");

        if (!host) {
          host = "service.iris.edu";
        } // $FlowFixMe


        let request = new DataSelectQuery().timeWindow(timeWindow);

        if (host) {
          request.host(host);
        }

        if (net) {
          request.networkCode(net);
        }

        if (sta) {
          request.stationCode(sta);
        }

        if (loc) {
          request.locationCode(loc);
        }

        if (chan) {
          request.channelCode(chan);
        }

        out.push(request.querySeismograms().then(seismograms => {
          let sddList = seismograms.map(s => {
            let sdd = SeismogramDisplayData.fromSeismogram(s);

            if (isDef(timeWindow)) {
              sdd.timeWindow = timeWindow;
            }

            return sdd;
          });
          return {
            "sddList": sddList,
            "svgParent": svgParent
          };
        }));
      }
    });
    return RSVP__default.all(out);
  }
  function createPlotsBySelector(selector) {
    return createPlotsBySelectorPromise(selector).then(function (resultArray) {
      resultArray.forEach(function (result) {
        result.svgParent.append("p").text("Build plot");

        if (result.sddList.length > 0) {
          let svgDiv = result.svgParent.append("div");
          svgDiv.classed("svg-container-wide", true);
          let seisConfig = new SeismographConfig();
          let seismogram = new Seismograph(svgDiv, seisConfig, result.sddList);
          seismogram.draw();
        } else {
          result.svgParent.append("p").text("No Data");
        }
      });
      return resultArray;
    });
  }
  function alphabeticalSort(traceA, traceB) {
    if (traceA.codes() < traceB.codes()) {
      return -1;
    } else {
      return 1;
    }
  }

  var plotutil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dataselect: fdsndataselect,
    miniseed: miniseed,
    d3: d3,
    RSVP: RSVP__default,
    moment: moment__default,
    createPlotsBySelectorPromise: createPlotsBySelectorPromise,
    createPlotsBySelector: createPlotsBySelector,
    alphabeticalSort: alphabeticalSort
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * Creates particle motion plots, for each selected element. This assumes each
   * element has some combination of start, end, duration, net, sta, loc, and chan
   * attributes sufficient to form the data query to return all components of
   * motion. Or an href to a miniseed file.
   *
   * @param selector css selector
   */

  function createParticleMotionBySelector(selector) {
    createPlotsBySelectorPromise(selector).then(function (resultArray) {
      resultArray.forEach(function (result) {
        result.svgParent.append("p").text("Build plot");
        const sddList = result.sddList;

        if (sddList.length > 1) {
          addDivForParticleMotion(result.svgParent, sddList[0], sddList[1]);

          if (sddList.length > 2) {
            addDivForParticleMotion(result.svgParent, sddList[0], sddList[2]);
            addDivForParticleMotion(result.svgParent, sddList[1], sddList[2]);
          }
        } else {
          result.svgParent.append("p").text("Not Enough Data: ".concat(sddList.length));
        }
      });
    });
  }
  function addDivForParticleMotion(svgParent, xSeisData, ySeisData, timeWindow) {
    let svgDiv = svgParent.append("div");

    if (!isDef(xSeisData)) {
      throw new Error("xSeisData cannot be null");
    }

    if (!isDef(ySeisData)) {
      throw new Error("ySeisData cannot be null");
    }

    const xSeis = xSeisData.seismogram;
    const ySeis = ySeisData.seismogram;
    const xLabel = xSeis ? xSeis.channelCode : "unknown";
    const yLabel = ySeis ? ySeis.channelCode : "unknown";
    svgDiv.classed(xLabel + " " + yLabel, true);
    svgDiv.classed("particleMotionContainer", true);
    return addParticleMotion(svgDiv, xSeisData, ySeisData, timeWindow);
  }
  function addParticleMotion(svgParent, xSeisData, ySeisData, timeWindow) {
    if (!isDef(xSeisData.seismogram) || !isDef(ySeisData.seismogram)) {
      // $FlowFixMe
      throw new Error("Seismogram has no data: ".concat(xSeisData.seismogram, " ").concat(ySeisData.seismogram));
    }

    const xSeis = xSeisData.seismogram;
    const ySeis = ySeisData.seismogram;
    let seisConfig = new SeismographConfig();

    if (isDef(timeWindow)) {
      seisConfig.fixedTimeScale = timeWindow;
    }

    seisConfig.title = xSeis.channelCode + " " + ySeis.channelCode;
    seisConfig.xLabel = xSeis.channelCode;
    seisConfig.yLabel = ySeis.channelCode;
    seisConfig.margin.top = seisConfig.margin.bottom;
    seisConfig.margin.right = seisConfig.margin.left;
    let pmp = new ParticleMotion(svgParent, seisConfig, xSeisData, ySeisData);
    pmp.draw();
    return pmp;
  }
  /**
   * Particle motion plot.
   *
   * @param inSvgParent parent element, often a div
   * @param seismographConfig config, not all parameters are used in
   * particle motion plots. Can be null for defaults.
   * @param xSeisData x axis seismogram
   * @param ySeisData y axis seismogram
   */

  class ParticleMotion {
    constructor(inSvgParent, seismographConfig, xSeisData, ySeisData) {
      if (!isDef(inSvgParent)) {
        throw new Error("inSvgParent cannot be null");
      }

      if (!isDef(xSeisData)) {
        throw new Error("xSeisData cannot be null");
      }

      if (!isDef(ySeisData)) {
        throw new Error("ySeisData cannot be null");
      }

      this.plotId = ++ParticleMotion._lastID;

      if (xSeisData instanceof Seismogram) {
        this.xSeisData = SeismogramDisplayData.fromSeismogram(xSeisData);
      } else if (xSeisData instanceof SeismogramDisplayData) {
        this.xSeisData = xSeisData;
      }

      if (ySeisData instanceof Seismogram) {
        this.ySeisData = SeismogramDisplayData.fromSeismogram(ySeisData);
      } else if (ySeisData instanceof SeismogramDisplayData) {
        this.ySeisData = ySeisData;
      }

      if (isDef(seismographConfig)) {
        this.seismographConfig = seismographConfig;
      } else {
        this.seismographConfig = new SeismographConfig();
        this.seismographConfig.xLabel = this.xSeisData.channelCode;
        this.seismographConfig.yLabel = this.ySeisData.channelCode;
        this.seismographConfig.margin.left = 40;
        this.seismographConfig.margin.top = this.seismographConfig.margin.bottom;
        this.seismographConfig.margin.right = this.seismographConfig.margin.left;
      }

      this.calcTimeWindow();
      this.svg = inSvgParent.append("svg");
      this.svg.attr("version", "1.1");
      this.svg.classed("particleMotion", true);
      this.svg.attr("plotId", this.plotId);
      this.xScale = d3.scaleLinear(); // yScale for axis (not drawing) that puts mean at 0 in center

      this.xScaleRmean = d3.scaleLinear();
      this.yScale = d3.scaleLinear(); // yScale for axis (not drawing) that puts mean at 0 in center

      this.yScaleRmean = d3.scaleLinear();
      this.svgParent = inSvgParent;
      this.xAxis = d3.axisBottom(this.xScaleRmean).tickFormat(this.seismographConfig.yScaleFormat);
      this.yAxis = d3.axisLeft(this.yScaleRmean).tickFormat(this.seismographConfig.yScaleFormat);
      this.width = 100;
      this.height = 100;
      let mythis = this;
      this.g = this.svg.append("g").attr("transform", "translate(" + this.seismographConfig.margin.left + "," + this.seismographConfig.margin.top + ")");
      this.calcScaleDomain();
      d3.select(window).on('resize.particleMotion' + this.plotId, function () {
        if (mythis.checkResize()) {
          mythis.draw();
        }
      });
    }

    draw() {
      this.checkResize();
      this.drawAxis();
      this.drawAxisLabels();
      this.drawParticleMotion();
      return this;
    }

    checkResize() {
      let rect = this.svgParent.node().getBoundingClientRect();

      if (rect.width !== this.outerWidth || rect.height !== this.outerHeight) {
        this.calcWidthHeight(rect.width, rect.height);
        return true;
      }

      return false;
    }

    drawParticleMotion() {
      this.g.selectAll("g.particleMotion").remove();
      let lineG = this.g.append("g");
      lineG.classed("particleMotion", true).classed("seispath", true).classed(this.xSeisData.codes(), true).classed("orient" + this.xSeisData.channelCode.charAt(2) + "_" + this.ySeisData.channelCode.charAt(2), true); // for flow

      let xSegments = this.xSeisData.seismogram ? this.xSeisData.seismogram.segments : [];
      let ySegments = this.ySeisData.seismogram ? this.ySeisData.seismogram.segments : [];
      xSegments.forEach(segX => {
        ySegments.forEach(segY => {
          this.drawParticleMotionForSegment(lineG, segX, segY);
        });
      });
    }

    drawParticleMotionForSegment(lineG, segA, segB) {
      const mythis = this;
      const timeWindow = segA.timeWindow.intersect(segB.timeWindow);

      if (!isDef(timeWindow)) {
        // no overlap
        return;
      }

      const idxA = segA.indexOfTime(timeWindow.startTime);
      const lastIdxA = segA.indexOfTime(timeWindow.endTime);
      const idxB = segB.indexOfTime(timeWindow.startTime);
      const lastIdxB = segB.indexOfTime(timeWindow.endTime);

      if (idxA === -1 || lastIdxA === -1 || idxB === -1 || lastIdxB === -1) {
        return;
      }

      const numPts = Math.min(lastIdxA - idxA, lastIdxB - idxB) + 1;
      let segmentG = lineG.append("g").classed("segment", true);
      let path = segmentG.selectAll("path").data([segA.y.slice(idxA, numPts)]);
      path.exit().remove();
      path.enter().append("path").classed("seispath", true).attr("d", d3.line().curve(d3.curveLinear).x(d => mythis.xScale(d)).y((d, i) => mythis.yScale(segB.yAtIndex(idxB + i))));
    }

    drawAxis() {
      let svgG = this.g;
      svgG.selectAll("g.axis").remove();
      svgG.append("g").attr("class", "axis axis--x").attr("transform", "translate(0," + this.height + ")").call(this.xAxis);
      svgG.append("g").attr("class", "axis axis--y").call(this.yAxis);
    }

    drawAxisLabels() {
      this.drawTitle();
      this.drawXLabel();
      this.drawXSublabel();
      this.drawYLabel();
      this.drawYSublabel();
      return this;
    }

    rescaleAxis() {
      let delay = 500;
      this.g.select(".axis--y").transition().duration(delay / 2).call(this.yAxis);
      this.g.select(".axis--x").transition().duration(delay / 2).call(this.xAxis);
      return this;
    }

    calcScaleDomain() {
      let halfDomainDelta = 1;

      if (this.seismographConfig.fixedYScale) {
        halfDomainDelta = (this.seismographConfig.fixedYScale[1] - this.seismographConfig.fixedYScale[0]) / 2;
        this.xScale.domain(this.seismographConfig.fixedYScale).nice();
        this.yScale.domain(this.seismographConfig.fixedYScale).nice();
      } else {
        let xMinMax = [this.xSeisData.min, this.xSeisData.max];
        let yMinMax = [this.ySeisData.min, this.ySeisData.max];
        halfDomainDelta = (xMinMax[1] - xMinMax[0]) / 2;

        if (yMinMax[1] - yMinMax[0] > xMinMax[1] - xMinMax[0]) {
          halfDomainDelta = (yMinMax[1] - yMinMax[0]) / 2;
        }

        let xMid = (xMinMax[1] + xMinMax[0]) / 2;
        let yMid = (yMinMax[1] + yMinMax[0]) / 2;
        xMinMax = [xMid - halfDomainDelta, xMid + halfDomainDelta];
        yMinMax = [yMid - halfDomainDelta, yMid + halfDomainDelta];
        this.xScale.domain(xMinMax).nice();
        this.yScale.domain(yMinMax).nice();
      }

      let xNiceMinMax = this.xScale.domain();
      let xHalfNice = (xNiceMinMax[1] - xNiceMinMax[0]) / 2;
      this.xScaleRmean.domain([-1 * xHalfNice, xHalfNice]);
      let yNiceMinMax = this.yScale.domain();
      let yHalfNice = (yNiceMinMax[1] - yNiceMinMax[0]) / 2;
      this.yScaleRmean.domain([-1 * yHalfNice, yHalfNice]);
      this.rescaleAxis();
      return this;
    }

    calcTimeWindow() {
      let tw = null;

      if (this.seismographConfig.fixedTimeScale) {
        tw = this.seismographConfig.fixedTimeScale;
      } else {
        tw = this.xSeisData.timeWindow.intersect(this.ySeisData.timeWindow);
      }

      if (!tw) {
        // intersection might be null
        throw new Error("Seismograms do not overlap: ".concat(this.xSeisData.timeWindow.toString(), " ").concat(this.ySeisData.timeWindow.toString()));
      }

      this.timeWindow = tw;
    }

    calcWidthHeight(nOuterWidth, nOuterHeight) {
      this.outerWidth = nOuterWidth ? Math.max(100, nOuterWidth) : 100;
      this.outerHeight = nOuterHeight ? Math.max(100, nOuterHeight) : 100;
      this.height = this.outerHeight - this.seismographConfig.margin.top - this.seismographConfig.margin.bottom;
      this.width = this.outerWidth - this.seismographConfig.margin.left - this.seismographConfig.margin.right;
      this.xScale.range([0, this.width]);
      this.yScale.range([this.height, 0]);
      this.xScaleRmean.range([0, this.width]);
      this.yScaleRmean.range([this.height, 0]);
      return this;
    }
    /**
     * Draws the title as simple string or array of strings. If an array
     * then each item will be in a separate tspan for easier formatting.
     *
     * @returns this
     */


    drawTitle() {
      this.svg.selectAll("g.title").remove();
      let titleSVGText = this.svg.append("g").classed("title", true).attr("transform", "translate(" + (this.seismographConfig.margin.left + this.width / 2) + ", " + this.seismographConfig.margin.bottom / 3 + ")").append("text").classed("title label", true).attr("text-anchor", "middle");

      if (Array.isArray(this.seismographConfig.title)) {
        this.seismographConfig.title.forEach(function (s) {
          titleSVGText.append("tspan").text(s + " ");
        });
      } else {
        titleSVGText.text(this.seismographConfig.title);
      }

      return this;
    }

    drawXLabel() {
      this.svg.selectAll("g.xLabel").remove();

      if (isNumArg(this.width) && isNumArg(this.outerWidth)) {
        this.svg.append("g").classed("xLabel", true).attr("transform", "translate(" + (this.seismographConfig.margin.left + this.width / 2) + ", " + (this.outerHeight - this.seismographConfig.margin.bottom / 3) + ")").append("text").classed("x label", true).attr("text-anchor", "middle").text(this.seismographConfig.xLabel);
      }

      return this;
    }

    drawYLabel() {
      this.svg.selectAll('g.yLabel').remove();

      if (this.height) {
        this.svg.append("g").classed("yLabel", true).attr("x", 0).attr("transform", "translate(0, " + (this.seismographConfig.margin.top + this.height / 2) + ")").append("text").classed("y label", true).attr("text-anchor", "middle").attr("dy", ".75em").attr("transform-origin", "center center").attr("transform", "rotate(-90)").text(this.seismographConfig.yLabel);
      }

      return this;
    }

    drawXSublabel() {
      this.svg.selectAll('g.xSublabel').remove();
      this.svg.append("g").classed("xSublabel", true).attr("transform", "translate(" + (this.seismographConfig.margin.left + this.width / 2) + ", " + this.outerHeight + ")").append("text").classed("x label sublabel", true).attr("text-anchor", "middle").text(this.seismographConfig.xSublabel);
      return this;
    }

    drawYSublabel() {
      this.svg.selectAll('g.ySublabel').remove();
      this.svg.append("g").classed("ySublabel", true).attr("x", 0).attr("transform", "translate( " + this.seismographConfig.ySublabelTrans + " , " + (this.seismographConfig.margin.top + this.height / 2) + ")").append("text").classed("y label sublabel", true).attr("text-anchor", "middle").attr("dy", ".75em").attr("transform-origin", "center center").attr("transform", "rotate(-90)").text(this.seismographConfig.ySublabel);
      return this;
    }

  }
  const particleMotion_css = "\n.particleMotionContainer {\n  height: 100%;\n  width: 100%;\n  min-height: 25px;\n  min-width: 25px;\n}\n\nsvg.particleMotion {\n  height: 100%;\n  width: 100%;\n  min-height: 25px;\n  min-width: 25px;\n}\n\nsvg.particleMotion text.title {\n  font-size: larger;\n  font-weight: bold;\n  fill: black;\n  color: black;\n  dominant-baseline: hanging;\n}\n\nsvg.particleMotion path.seispath {\n    stroke: skyblue;\n    fill: none;\n    stroke-width: 1px;\n}\n";

  if (document) {
    insertCSS(particleMotion_css);
  } // static ID for particle motion


  ParticleMotion._lastID = 0;

  var particlemotion = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createParticleMotionBySelector: createParticleMotionBySelector,
    addDivForParticleMotion: addDivForParticleMotion,
    addParticleMotion: addParticleMotion,
    ParticleMotion: ParticleMotion,
    particleMotion_css: particleMotion_css
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const IRIS_HOST$3 = 'rtserve.iris.washington.edu';
  const ORG = 'Organization: ';
  /**
   * Web connection to a Ringserver.
   *
   *
   * @param host optional host to connect to, defaults to IRIS
   * @param port optional host to connect to, defaults to 80
   */

  class RingserverConnection {
    /** @private */

    /** @private */

    /** @private */
    constructor(host, port) {
      this._host = isNonEmptyStringArg(host) ? host : IRIS_HOST$3;
      this._port = isDef(port) ? port : 80;
      this._timeoutSec = 30;
    }
    /**
     * Gets/Sets the remote host to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    host(value) {
      if (isStringArg(value)) {
        this._host = value;
        return this;
      } else if (hasNoArgs(value)) {
        return this._host;
      } else {
        throw new Error('value argument is optional or string, but was ' + typeof value);
      }
    }
    /**
     * Gets/Sets the remote port to connect to.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    port(value) {
      if (hasNoArgs(value)) {
        return this._port;
      } else if (isNumArg(value)) {
        this._port = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Get/Set the timeout in seconds for the request. Default is 30.
     *
     * @param value optional new value if setting
     * @returns new value if getting, this if setting
     */


    timeout(value) {
      if (hasNoArgs(value)) {
        return this._timeoutSec;
      } else if (isNumArg(value)) {
        this._timeoutSec = value;
        return this;
      } else {
        throw new Error('value argument is optional or number, but was ' + typeof value);
      }
    }
    /**
     * Pulls id result from ringserver /id parsed into an object with
     * 'ringserverVersion' and 'serverId' fields.
     *
     * @returns Result as an RSVP Promise.
     */


    pullId() {
      return this.pullRaw(this.formIdURL()).then(raw => {
        let lines = raw.split('\n');
        let organization = lines[1];

        if (organization.startsWith(ORG)) {
          organization = organization.substring(ORG.length);
        }

        return {
          'ringserverVersion': lines[0],
          'serverId': organization
        };
      });
    }
    /**
     *  Use numeric level (1-6) to pull just IDs from ringserver.
     *  In a default ringserver,
     *  level=1 would return all networks like
     *  CO
     *  and level=2 would return all stations like
     *  CO_JSC
     *  If level is falsy/missing, level=6 is used.
     *  The optional matchPattern is a regular expression, so for example
     *  '.+_JSC_00_HH.' would get all HH? channels from any station name JSC.
     *
     * @param level 1-6
     * @param matchPattern regular expression to match
     * @returns Result as an RSVP Promise.
     */


    pullStreamIds(level, matchPattern) {
      let queryParams = 'level=6';

      if (isNumArg(level) && level > 0) {
        queryParams = 'level=' + level;
      }

      if (matchPattern) {
        queryParams = queryParams + '&match=' + matchPattern;
      }

      const url = this.formStreamIdsURL(queryParams);
      return this.pullRaw(url).then(raw => {
        return raw.split('\n').filter(line => line.length > 0);
      });
    }
    /**
     * Pull streams, including start and end times, from the ringserver.
     * The optional matchPattern is a regular expression, so for example
     * '.+_JSC_00_HH.' would get all HH? channels from any station name JSC.
     * Result returned is an RSVP Promise.
     *
     * @param matchPattern regular expression to match
     * @returns promise to object with 'accessTime' as a moment
     * and 'streams' as an array of StreamStat objects.
     */


    pullStreams(matchPattern) {
      let queryParams = "";

      if (matchPattern) {
        queryParams = 'match=' + matchPattern;
      }

      const url = this.formStreamsURL(queryParams);
      return this.pullRaw(url).then(raw => {
        let lines = raw.split('\n');
        let out = {};
        out.accessTime = moment__default.utc();
        out.streams = [];

        for (let line of lines) {
          if (line.length === 0) {
            continue;
          }

          let vals = line.split(/\s+/);

          if (vals.length === 0) {
            // blank line, skip
            continue;
          } else if (vals.length >= 2) {
            out.streams.push(new StreamStat(vals[0], vals[1], vals[2]));
          } else {
            log("Bad /streams line, skipping: '" + line + "'");
          }
        }

        return out;
      });
    }
    /**
     * Utility method to pull raw result from ringserver url.
     * Result returned is an RSVP Promise.
     *
     * @param url the url
     * @returns promise to string result
     */


    pullRaw(url) {
      const fetchInit = defaultFetchInitObj(TEXT_MIME);
      return doFetchWithTimeout(url, fetchInit, this._timeoutSec * 1000).then(response => {
        if (response.status === 200) {
          return response.text();
        } else {
          throw new Error("Status not 200: ".concat(response.status));
        }
      });
    }
    /**
     * Forms base url from protocol, host and port.
     *
     * @returns the string url
     */


    formBaseURL() {
      return checkProtocol() + '//' + this._host + (this._port === 80 ? '' : ':' + this._port);
    }
    /**
     * Forms the ringserver id url.
     *
     * @returns the id url
     */


    formIdURL() {
      return this.formBaseURL() + '/id';
    }
    /**
     * Forms the ringserver streams url using the query parameters.
     *
     * @param queryParams optional string of query parameters
     * @returns the streams url
     */


    formStreamsURL(queryParams) {
      return this.formBaseURL() + '/streams' + (isNonEmptyStringArg(queryParams) && queryParams.length > 0 ? '?' + queryParams : '');
    }
    /**
     * Forms the ringserver stream ids url using the query parameters.
     *
     * @param queryParams optional string of query parameters
     * @returns the stream ids url
     */


    formStreamIdsURL(queryParams) {
      return this.formBaseURL() + '/streamids' + (queryParams && queryParams.length > 0 ? '?' + queryParams : '');
    }

  }
  /**
   * Extract one StreamStat per station from an array of channel level
   * StreamStats. The start and end times are the min and max times for all
   * the channels within the station. Can be used to get most time of most
   * recent packet from the stations to give an idea of current latency.
   *
   * @param   streams array of channel level StreamStats
   * @returns array of station level StreamStats
   */

  function stationsFromStreams(streams) {
    let out = new Map();

    for (const s of streams) {
      const nslc = nslcSplit(s.key);
      const staKey = nslc.networkCode + "." + nslc.stationCode;
      let stat = out.get(staKey);

      if (!isDef(stat)) {
        stat = new StreamStat(staKey, s.startRaw, s.endRaw);
        out.set(staKey, stat);
      } else {
        if (stat.start.isAfter(s.start)) {
          stat.start = s.start;
          stat.startRaw = s.startRaw;
        }

        if (stat.end.isBefore(s.end)) {
          stat.end = s.end;
          stat.endRaw = s.endRaw;
        }
      }
    }

    return Array.from(out.values());
  }

  /**
   * Split type, networkCode, stationCode, locationCode and channelCode
   * from a ringserver id formatted like net_sta_loc_chan/type
   *
   * @param   id id string to split
   * @returns  object with the split fields
   */
  function nslcSplit(id) {
    let split = id.split('/');
    let out = {};
    out.type = split[1];
    let nslc = split[0].split('_');

    if (nslc.length === 4) {
      // assume net, station, loc, chan
      out.networkCode = nslc[0];
      out.stationCode = nslc[1];
      out.locationCode = nslc[2];
      out.channelCode = nslc[3];
    } else {
      throw new Error("tried to split, did not find 4 elements in array: " + id);
    }

    return out;
  }
  /**
   * Object to hold start and end times for a key, usually channel or station.
   *
   * @param key id, usually station or channel
   * @param start start time
   * @param end end time
   */

  class StreamStat {
    constructor(key, start, end) {
      this.key = key;
      this.startRaw = start;
      this.endRaw = end;

      if (this.startRaw.indexOf('.') !== -1 && this.startRaw.indexOf('.') < this.startRaw.length - 4) {
        this.startRaw = this.startRaw.substring(0, this.startRaw.indexOf('.') + 4);
      }

      if (this.startRaw.charAt(this.startRaw.length - 1) !== 'Z') {
        this.startRaw = this.startRaw + 'Z';
      }

      if (this.endRaw.indexOf('.') !== -1 && this.endRaw.indexOf('.') < this.endRaw.length - 4) {
        this.endRaw = this.endRaw.substring(0, this.endRaw.indexOf('.') + 4);
      }

      if (this.endRaw.charAt(this.endRaw.length - 1) !== 'Z') {
        this.endRaw = this.endRaw + 'Z';
      }

      this.start = moment__default.utc(this.startRaw);
      this.end = moment__default.utc(this.endRaw);
      this.startRaw = start; // reset to unchanged strings

      this.endRaw = end;
    }
    /**
     * Calculates latency time difference between last packet and current time.
     *
     * @param accessTime time latency is calculated relative to
     * @returns latency
     */


    calcLatency(accessTime) {
      return this.end.from(accessTime);
    }

  }

  var ringserverweb = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IRIS_HOST: IRIS_HOST$3,
    RingserverConnection: RingserverConnection,
    stationsFromStreams: stationsFromStreams,
    nslcSplit: nslcSplit,
    StreamStat: StreamStat
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * SAC style response file. This contains poles and zeros to represent the
   * analog stage, plus a constant for the overall gain. See
   * seisplotjs.transfer.convertToSacPoleZero() for conversion from a
   * StationXML response to SacPoleZero.
   */

  class SacPoleZero {
    /**
     * Complex poles
     */

    /**
     * Complex zeros
     */

    /**
     * Scalar overall gain
     */

    /** number of zeros added to convert to displacement, for debugging */

    /** hertz/radian factor, for debugging */

    /** sensitivity accounting for gamma, for debugging */

    /** normalization factor for poles and zeros accounting for gamma, for debugging */
    constructor(poles, zeros, constant) {
      this.poles = poles;
      this.zeros = zeros;
      this.constant = constant;
    }

    toString() {
      let s = ["sacPoleZero:"];
      s.push("ZEROS " + this.zeros.length);

      for (let i = 0; i < this.zeros.length; i++) {
        s.push("    " + this.zeros[i].real() + " " + this.zeros[i].imag());
      }

      s.push("POLES " + this.poles.length);

      for (let i = 0; i < this.poles.length; i++) {
        s.push("    " + this.poles[i].real() + " " + this.poles[i].imag());
      }

      s.push("CONSTANT " + this.constant);

      if (isNumArg(this.gamma) && isNumArg(this.mulFactor) && isNumArg(this.sd) && isNumArg(this.A0)) {
        s.push("*    gamma: " + this.gamma);
        s.push("*    mulFactor: " + this.mulFactor);
        s.push("*    sd: " + this.sd);
        s.push("*    A0: " + this.A0);
      }

      return s.join('\n');
    }

    toText() {
      let s = [];
      s.push("ZEROS " + this.zeros.length);

      for (let i = 0; i < this.zeros.length; i++) {
        s.push("    " + this.zeros[i].real() + " " + this.zeros[i].imag());
      }

      s.push("POLES " + this.poles.length);

      for (let i = 0; i < this.poles.length; i++) {
        s.push("    " + this.poles[i].real() + " " + this.poles[i].imag());
      }

      s.push("CONSTANT " + this.constant);
      return s.join('\n');
    }
    /**
     * Parses a string in sac polezero format into a SacPoleZero.
     *
     * @param data string to parse
     * @returns SacPoleZero instance
     */


    static parse(data) {
      let pz = {
        zeros: [],
        poles: [],
        constant: 1
      };
      let lines = data.split('\n');
      let numZeros = 0;
      let numPoles = 0;
      let i = 0;

      while (i < lines.length) {
        let l = lines[i];
        let items = l.trim().split(/ +/);

        if (items[0] === 'ZEROS') {
          numZeros = parseInt(items[1]);
          i++;
          l = lines[i];
          items = l.trim().split(/ +/);

          while (i < lines.length && pz.zeros.length < numZeros) {
            if (items[0] === 'POLES') {
              // no more zeros, fill array with 0
              for (let z = pz.zeros.length; z < numZeros; z++) {
                pz.zeros.push(createComplex(0, 0));
              }

              break;
            } else {
              let real = parseFloat(items[0]);
              let imag = parseFloat(items[1]);
              pz.zeros.push(createComplex(real, imag));
            }

            i++;
            l = lines[i];
            items = l.trim().split(/ +/);
          }
        }

        if (items[0] === 'POLES') {
          numPoles = parseInt(items[1]);
          i++;
          l = lines[i];
          items = l.trim().split(/ +/);

          while (i < lines.length && pz.poles.length < numPoles) {
            if (items[0] === 'CONSTANT') {
              // no more poles, fill array with 0
              for (let z = pz.poles.length; z < numPoles; z++) {
                pz.poles.push(createComplex(0, 0));
              }

              break;
            } else {
              let real = parseFloat(items[0]);
              let imag = parseFloat(items[1]);
              pz.poles.push(createComplex(real, imag));
            }

            i++;
            l = lines[i];
            items = l.trim().split(/ +/);
          }
        }

        if (items[0] === 'CONSTANT') {
          pz.constant = parseFloat(items[1]);
        }

        i++;
      }

      return new SacPoleZero(pz.poles, pz.zeros, pz.constant);
    }

  }

  var sacpolezero = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SacPoleZero: SacPoleZero
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  const SEEDLINK_PROTOCOL = "SeedLink3.1";

  /**
   * A seedlink websocket connection to the given url.
   * The connection is not made until the connect() method is called.
   * Note this cannot connect directly to a native TCP socket, instead it
   * sends the seedlink protocol over a websocket. Currently only the IRIS
   * ringserver, https://github.com/iris-edu/ringserver,
   * supports websockets, but it may be possible to use thrid party
   * tools to proxy the websocket to a TCP seedlink socket.
   *
   * @param url websocket URL to connect to
   * @param requestConfig an array of seedlink commands
   * like:<pre><code>
   *   [ 'STATION JSC CO',
   *     'SELECT 00BHZ.D' ]
   *     </pre></code>
   * @param receiveMiniseedFn the callback function that
   * will be invoked for each seedlink packet received
   * which contains 'sequence', a sequence number
   * and 'miniseed', a single miniseed record.
   */
  class SeedlinkConnection {
    constructor(url, requestConfig, receiveMiniseedFn, errorFn) {
      this.url = url;
      this.requestConfig = requestConfig;
      this.receiveMiniseedFn = receiveMiniseedFn;
      this.errorFn = errorFn;
      this.closeFn = null;
      this.command = 'DATA';
    }

    setTimeCommand(startTime) {
      this.command = "TIME " + moment__default.utc(startTime).format("YYYY,MM,DD,HH,mm,ss");
    }

    setOnError(errorFn) {
      this.errorFn = errorFn;
    }

    setOnClose(closeFn) {
      this.closeFn = closeFn;
    }

    connect() {
      if (this.webSocket) {
        this.webSocket.close();
        this.webSocket = null;
      }

      try {
        const webSocket = new WebSocket(this.url, SEEDLINK_PROTOCOL);
        this.webSocket = webSocket;
        webSocket.binaryType = 'arraybuffer';
        const that = this;

        webSocket.onopen = function () {
          that.sendHello().then(function () {
            return that.sendCmdArray(that.requestConfig);
          }).then(function () {
            return that.sendCmdArray([that.command]);
          }).then(function (val) {
            webSocket.onmessage = function (event) {
              that.handle(event);
            };

            webSocket.send('END\r');
            return val;
          }).catch(err => {
            if (that.errorFn) {
              that.errorFn(err);
            } else {
              throw err;
            }

            that.close();
          });
        };

        webSocket.onerror = function (err) {
          if (that.errorFn) {
            that.errorFn(err);
          } else {
            throw err;
          }
        };

        webSocket.onclose = function (closeEvent) {
          if (that.closeFn) {
            that.closeFn(closeEvent);
          }

          if (that.webSocket) {
            that.webSocket = null;
          }
        };
      } catch (err) {
        if (this.errorFn) {
          this.errorFn(err);
        } else {
          throw err;
        }
      }
    }

    close() {
      if (this.webSocket) {
        this.webSocket.close();
      }
    }

    handle(event) {
      //for flow
      const data = event.data;

      if (data.byteLength < 64) ; else {
        this.handleMiniseed(event);
      }
    }

    handleMiniseed(event) {
      //for flow
      const data = event.data;

      try {
        if (data.byteLength < 64) {
          this.errorFn(new Error("message too small to be miniseed: " + data.byteLength + " " + dataViewToString(new DataView(data))));
          return;
        }

        let slHeader = new DataView(data, 0, 8); // check for 'SL' at start

        if (slHeader.getInt8(0) === 83 && slHeader.getInt8(1) === 76) {
          let seqStr = '';

          for (let i = 0; i < 6; i++) {
            seqStr = seqStr + String.fromCharCode(slHeader.getInt8(2 + i));
          }

          let dataView = new DataView(data, 8, data.byteLength - 8);
          let out = {
            rawsequence: seqStr,
            sequence: parseInt(seqStr, 16),
            miniseed: parseSingleDataRecord(dataView)
          };
          this.receiveMiniseedFn(out);
        } else {
          throw new Error("Not a seedlink packet, no starting SL: " + slHeader.getInt8(0) + ' ' + slHeader.getInt8(1));
        }
      } catch (e) {
        this.errorFn("Error, closing seedlink. " + e);
        this.close();
      }
    }

    isConnected() {
      return this.webSocket !== null;
    }
    /**
     * Sends initial HELLO to server and waits for response.
     *
     * @returns            Promise that resolves to the response from the server.
     */


    sendHello() {
      let webSocket = this.webSocket;
      let promise = new RSVP.Promise(function (resolve, reject) {
        if (webSocket) {
          webSocket.onmessage = function (event) {
            //for flow
            const data = event.data;
            let replyMsg = dataViewToString(new DataView(data));
            let lines = replyMsg.trim().split('\r');

            if (lines.length === 2) {
              resolve(lines);
            } else {
              reject("not 2 lines: " + replyMsg);
            }
          };

          webSocket.send("HELLO\r");
        } else {
          reject("webSocket has been closed");
        }
      });
      return promise;
    }
    /**
     * Sends an array of commands, each as a Promise waiting for the 'OK' response
     * before sending the next.
     *
     * @param   cmd array of commands to send
     * @returns      Promise that resolves to the 'OK' returned by the last
     *   command if successful, or rejects on the first failure.
     */


    sendCmdArray(cmd) {
      let that = this;
      return cmd.reduce(function (accum, next) {
        return accum.then(function () {
          return that.createCmdPromise(next);
        });
      }, RSVP.resolve());
    }
    /**
     * creates a Promise that sends a command and waits resolved with the result.
     *
     * @param   mycmd command string to send.
     * @returns        Promise that resolves to the reply from the server.
     */


    createCmdPromise(mycmd) {
      let webSocket = this.webSocket;
      let promise = new RSVP.Promise(function (resolve, reject) {
        if (webSocket) {
          webSocket.onmessage = function (event) {
            //for flow
            const data = event.data;
            let replyMsg = dataViewToString(new DataView(data)).trim();

            if (replyMsg === 'OK') {
              resolve(replyMsg);
            } else {
              reject("msg not OK: " + replyMsg);
            }
          };

          webSocket.send(mycmd + '\r\n');
        } else {
          reject("webSocket has been closed");
        }
      });
      return promise;
    }

  }

  var seedlink = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SEEDLINK_PROTOCOL: SEEDLINK_PROTOCOL,
    SeedlinkConnection: SeedlinkConnection
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * Applies a time domain taper of the given type.
   *
   * @param   seis      Seismogram to taper
   * @param   width     width as a fraction of seismogram length, default is 0.05
   * @param   taperType taper type, default is HANNING, others are HAMMING and COSINE
   * @returns            copy of seismogram with taper applied.
   */

  function taper(seis, width = 0.05, taperType = HANNING) {
    if (width > 0.5) {
      throw new Error("Taper width cannot be larger than 0.5, width=" + width);
    }

    if (seis.isContiguous()) {
      let data = seis.y;
      let outData = Float32Array.from(data);
      let w = Math.floor(data.length * width);
      let coeff = getCoefficients(taperType, w);
      const omega = coeff[0];
      const f0 = coeff[1];
      const f1 = coeff[2];

      for (let i = 0; i < w; i++) {
        const taperFactor = f0 - f1 * Math.cos(omega * i);
        outData[i] = outData[i] * taperFactor;
        outData[outData.length - i - 1] = outData[outData.length - i - 1] * taperFactor;
      }

      return seis.cloneWithNewData(outData);
    } else {
      throw new Error("Cannot take taper of non-contiguous seismogram");
    }
  }
  /**
   * Calculates the coefficients for tapering, [omega, f0, f1]
   *
   * @param type HANNING, HAMMING or COSINE
   * @param length number of data points
   * @returns tapering coefficients as an array of length 3
   */

  function getCoefficients(type, length) {
    let omega, f0, f1;

    if (type === HANNING) {
      omega = Math.PI / length;
      f0 = .5;
      f1 = .5;
    } else if (type === HAMMING) {
      omega = Math.PI / length;
      f0 = .54;
      f1 = .46;
    } else {
      // cosine
      omega = Math.PI / 2 / length;
      f0 = 1;
      f1 = 1;
    }

    return [omega, f0, f1];
  }
  const HANNING = "HANNING";
  const HAMMING = "HAMMING";
  const COSINE = "COSINE";

  var taper$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    taper: taper,
    getCoefficients: getCoefficients,
    HANNING: HANNING,
    HAMMING: HAMMING,
    COSINE: COSINE
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * Applies response, poles and zeros along with overall gain to the seismogram.
   * Should produce results similar to the sac command:
   * transfer from polezero to none
   *
   * @param   seis     seismogram to instrument correct
   * @param   response response to apply
   * @param   lowCut   low cut
   * @param   lowPass  low pass
   * @param   highPass high pass
   * @param   highCut  high cut
   * @returns           instrument corrected seismogram
   */

  function transfer(seis, response, lowCut, lowPass, highPass, highCut) {
    if (!response) {
      throw new Error("Response not exist???");
    }

    const sacPoleZero = convertToSacPoleZero(response);
    return transferSacPZ(seis, sacPoleZero, lowCut, lowPass, highPass, highCut);
  }
  function transferSacPZ(seis, sacPoleZero, lowCut, lowPass, highPass, highCut) {
    let outSeis = [];

    for (let i = 0; i < seis.segments.length; i++) {
      let result = transferSacPZSegment(seis.segments[i], sacPoleZero, lowCut, lowPass, highPass, highCut);
      outSeis.push(result);
    }

    return new Seismogram(outSeis);
  }
  function transferSacPZSegment(seis, sacPoleZero, lowCut, lowPass, highPass, highCut) {
    const sampFreq = seis.sampleRate;
    let values = seis.y;
    let outData = Float32Array.from(values);
    /* sac premultiplies the data by the sample period before doing the fft. Later it
     * seems to be cancled out by premultiplying the pole zeros by a similar factor.
     * I don't understand why they do this, but am reproducing it in order to be
     * compatible.
     */

    outData.forEach((d, i) => outData[i] = d / sampFreq);
    let freqValues = calcDFT(outData);
    freqValues = combine(freqValues, sampFreq, sacPoleZero, lowCut, lowPass, highPass, highCut);
    outData = inverseDFT(freqValues, values.length); // a extra factor of nfft gets in somehow???

    outData.forEach((d, i) => outData[i] = d * freqValues.length);
    let out = seis.cloneWithNewData(outData); //out.y_unit = UNITS.METER;

    out.yUnit = 'm';
    return out;
  }
  function calcResponse(response, numPoints, sampleRate, unit = "m") {
    const sacPoleZero = convertToSacPoleZero(response);
    const unitQty = new Qty(unit);
    let gamma = 0;

    if (unitQty.isCompatible(UNITS.METER)) {
      gamma = 0;
    } else if (unitQty.isCompatible(UNITS.METER_PER_SECOND)) {
      gamma = 1;
    } else if (unitQty.isCompatible(UNITS.METER_PER_SECOND_PER_SECOND)) {
      gamma = 2;
    } else {
      throw new Error("response unit is not displacement (m), velocity (m/s) or acceleration (m/s^2): " + unit);
    }

    for (let i = 0; i < gamma; i++) {
      let z = sacPoleZero.zeros[sacPoleZero.zeros.length - 1 - i];

      if (z.real() !== 0 || z.imag() !== 0) {
        throw new Error("Attempt to trim ".concat(gamma, " zeros from SacPoleZero, but zero isn't 0+i0: ").concat(z));
      }
    } // subtract gama zeros, ex 1 to get


    let trimmedZeros = sacPoleZero.zeros.slice().reverse();

    for (let i = 0; i < gamma; i++) {
      let idx = trimmedZeros.findIndex(d => d.real() === 0 && d.imag() === 0);
      trimmedZeros.splice(idx, 1);
    }

    trimmedZeros = trimmedZeros.reverse();
    sacPoleZero.zeros = trimmedZeros;
    let out = calcResponseFromSacPoleZero(sacPoleZero, numPoints, sampleRate);
    return out;
  }
  /**
   * Caclulates the frequency response from the given poles and zeros.
   *
   * @param   sacPoleZero poles and zeros
   * @param   numPoints   number of points in the output fft
   * @param   sampleRate  sample rate to compute at
   * @returns             frequency response
   */

  function calcResponseFromSacPoleZero(sacPoleZero, numPoints, sampleRate) {
    // inst response as packed frequency array
    let freqValues = new Float32Array(numPoints);
    const deltaF = sampleRate / freqValues.length; // zero freq

    freqValues[0] = 0; // nyquist

    let freq = sampleRate / 2;
    let respAtS = evalPoleZeroInverse(sacPoleZero, freq);
    respAtS = createComplex(1, 0).overComplex(respAtS);
    freqValues[freqValues.length / 2] = respAtS.real();

    for (let i = 1; i < freqValues.length / 2; i++) {
      freq = i * deltaF;
      respAtS = evalPoleZeroInverse(sacPoleZero, freq); //respAtS = respAtS.timesReal(deltaF*i);

      respAtS = createComplex(1, 0).overComplex(respAtS);

      if (respAtS.real() !== 0 && respAtS.imag() !== 0) {
        freqValues[i] = respAtS.real();
        freqValues[freqValues.length - i] = respAtS.imag();
      } else {
        freqValues[i] = 1e-10;
        freqValues[freqValues.length - i] = 0;
      }
    }

    let out = FFTResult.createFromPackedFreq(freqValues, numPoints, sampleRate);
    return out;
  }
  /**
   * Applies poles and zeros to the fft of a time series. Modifies the freqValues
   * in place.
   *
   * @param   freqValues  fft of a timeseries
   * @param   sampFreq    sampling frequency
   * @param   sacPoleZero poles and zeros
   * @param   lowCut      low cut
   * @param   lowPass     low pass
   * @param   highPass    high pass
   * @param   highCut     high cut
   * @returns             input freq values, with poles and zeros applied
   */

  function combine(freqValues, sampFreq, sacPoleZero, lowCut, lowPass, highPass, highCut) {
    const deltaF = sampFreq / freqValues.length; // handle zero freq, no imag, set real to 0

    freqValues[0] = 0; // handle nyquist

    let freq = sampFreq / 2;
    let respAtS = evalPoleZeroInverse(sacPoleZero, freq);
    respAtS = respAtS.timesReal(deltaF * calcFreqTaper(freq, lowCut, lowPass, highPass, highCut));
    freqValues[freqValues.length / 2] = respAtS.timesReal(freqValues[freqValues.length / 2]).real();

    for (let i = 1; i < freqValues.length / 2; i++) {
      freq = i * deltaF;
      respAtS = evalPoleZeroInverse(sacPoleZero, freq);
      respAtS = respAtS.timesReal(deltaF * calcFreqTaper(freq, lowCut, lowPass, highPass, highCut));
      let freqComplex = createComplex(freqValues[i], freqValues[freqValues.length - i]).timesComplex(respAtS);
      freqValues[i] = freqComplex.real();
      freqValues[freqValues.length - i] = freqComplex.imag();
    }

    return freqValues;
  }
  /**
   * Evaluates the poles and zeros at the given value. The return value is
   * 1/(pz(s) to avoid divide by zero issues. If there is a divide by zero
   * situation, then the response is set to be 0+0i.
   *
   * @param sacPoleZero SAC PoleZero response
   * @param freq frequency to evaluate
   * @returns complex frequency domain value for this frequency
   */

  function evalPoleZeroInverse(sacPoleZero, freq) {
    const s = createComplex(0, 2 * Math.PI * freq);
    let zeroOut = createComplex(1, 0);
    let poleOut = createComplex(1, 0);

    for (let i = 0; i < sacPoleZero.poles.length; i++) {
      poleOut = poleOut.timesComplex(s.minusComplex(sacPoleZero.poles[i]));
    }

    for (let i = 0; i < sacPoleZero.zeros.length; i++) {
      if (s.real() === sacPoleZero.zeros[i].real() && s.imag() === sacPoleZero.zeros[i].imag()) {
        return createComplex(0, 0);
      }

      zeroOut = zeroOut.timesComplex(s.minusComplex(sacPoleZero.zeros[i]));
    }

    let out = poleOut.overComplex(zeroOut);
    return out.overReal(sacPoleZero.constant);
  }
  /**
   * Calculates the frequency taper for the given parameters.
   *
   * @param   freq     frequency
   * @param   lowCut   low cut
   * @param   lowPass  low pass
   * @param   highPass high pass
   * @param   highCut  high cut
   * @returns           taper value at the frequency
   */

  function calcFreqTaper(freq, lowCut, lowPass, highPass, highCut) {
    if (lowCut > lowPass || lowPass > highPass || highPass > highCut) {
      throw new Error("must be lowCut > lowPass > highPass > highCut: " + lowCut + " " + lowPass + " " + highPass + " " + highCut);
    }

    if (freq <= lowCut || freq >= highCut) {
      return 0;
    }

    if (freq >= lowPass && freq <= highPass) {
      return 1;
    }

    if (freq > lowCut && freq < lowPass) {
      return 0.5 * (1.0 + Math.cos(Math.PI * (freq - lowPass) / (lowCut - lowPass)));
    } // freq > highPass && freq < highCut


    return 0.5 * (1.0 - Math.cos(Math.PI * (freq - highCut) / (highPass - highCut)));
  }
  /**
   * Applies the frequency taper to the fft of the time series.
   *
   * @param   fftResult  fft of time series
   * @param   sampleRate sample rate
   * @param   lowCut     low cut
   * @param   lowPass    low pass
   * @param   highPass   high pass
   * @param   highCut    high cut
   * @returns            fft with taper applied
   */

  function applyFreqTaper(fftResult, sampleRate, lowCut, lowPass, highPass, highCut) {
    const deltaF = sampleRate / fftResult.amp.length / 2;
    return FFTResult.createFromAmpPhase(fftResult.amp.map((v, i) => i === 0 ? 0 : v * calcFreqTaper(i * deltaF, lowCut, lowPass, highPass, highCut)), fftResult.phase, fftResult.origLength, fftResult.sampleRate);
  }
  /**
   * commonly used units as Qty
   */

  const UNITS = {
    COUNT: new Qty('count'),
    METER: new Qty('m'),
    METER_PER_SECOND: new Qty('m/s'),
    METER_PER_SECOND_PER_SECOND: new Qty('m/s2')
  };
  /**
   * Converts a StationXML response to SAC PoleZero style. This
   * converts the analog to digital stage (usually 0) along
   * with the overall gain, but does not include later FIR stages.
   * To maintain compatibility with SAC, this includes extra zeros
   * if needed to convert to displacement. The number of extra zeros
   * added is kept as gamma in the result.
   *
   * @param response stationxml Response to convert
   * @returns SAC PoleZero style version of the response
   */

  function convertToSacPoleZero(response) {
    let polesZeros;

    if (response.stages[0].filter instanceof PolesZeros) {
      polesZeros = response.stages[0].filter;
    } else {
      throw new Error("can't find PolesZeros");
    }

    let unit = response.instrumentSensitivity.inputUnits;

    if (unit === "M/S" || unit === "M/SEC") {
      unit = "m/s";
    }

    const unitQty = new Qty(unit);
    let scaleUnit = new Qty(1, unit);
    let gamma = 0;

    if (unitQty.isCompatible(UNITS.METER)) {
      gamma = 0;
      scaleUnit = scaleUnit.to(UNITS.METER);
    } else if (unitQty.isCompatible(UNITS.METER_PER_SECOND)) {
      gamma = 1;
      scaleUnit = scaleUnit.to(UNITS.METER_PER_SECOND);
    } else if (unitQty.isCompatible(UNITS.METER_PER_SECOND_PER_SECOND)) {
      gamma = 2;
      scaleUnit = scaleUnit.to(UNITS.METER_PER_SECOND_PER_SECOND);
    } else {
      throw new Error("response unit is not displacement, velocity or acceleration: " + unit);
    }

    let mulFactor = 1;

    if (polesZeros.pzTransferFunctionType === "LAPLACE (HERTZ)") {
      mulFactor = 2 * Math.PI;
    }

    let zeros = []; // extra gamma zeros are (0,0)

    for (let i = 0; i < polesZeros.zeros.length; i++) {
      zeros[i] = createComplex(polesZeros.zeros[i].real() * mulFactor, polesZeros.zeros[i].imag() * mulFactor);
    }

    for (let i = 0; i < gamma; i++) {
      zeros.push(createComplex(0, 0));
    }

    let poles = [];

    for (let i = 0; i < polesZeros.poles.length; i++) {
      poles[i] = createComplex(polesZeros.poles[i].real() * mulFactor, polesZeros.poles[i].imag() * mulFactor);
    }

    let constant = polesZeros.normalizationFactor;
    let sd = response.instrumentSensitivity.sensitivity;
    let fs = response.instrumentSensitivity.frequency;
    sd *= Math.pow(2 * Math.PI * fs, gamma);
    let A0 = polesZeros.normalizationFactor;
    let fn = polesZeros.normalizationFrequency;
    A0 = A0 / Math.pow(2 * Math.PI * fn, gamma);

    if (polesZeros.pzTransferFunctionType === "LAPLACE (HERTZ)") {
      A0 *= Math.pow(2 * Math.PI, polesZeros.poles.length - polesZeros.zeros.length);
    }

    if (poles.length === 0 && zeros.length === 0) {
      constant = sd * A0;
    } else {
      constant = sd * calc_A0(poles, zeros, fs);
    }

    constant *= scaleUnit.scalar;
    let sacPZ = new SacPoleZero(poles, zeros, constant);
    sacPZ.gamma = gamma;
    sacPZ.mulFactor = mulFactor;
    sacPZ.sd = sd;
    sacPZ.A0 = A0;
    return sacPZ;
  }
  function calc_A0(poles, zeros, ref_freq) {
    let numer = createComplex(1, 0);
    let denom = createComplex(1, 0);
    let f0;
    let a0;
    f0 = createComplex(0, 2 * Math.PI * ref_freq);

    for (let i = 0; i < zeros.length; i++) {
      denom = denom.timesComplex(f0.minusComplex(zeros[i]));
    }

    for (let i = 0; i < poles.length; i++) {
      numer = numer.timesComplex(f0.minusComplex(poles[i]));
    }

    a0 = numer.overComplex(denom).abs();
    return a0;
  }

  var transfer$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    transfer: transfer,
    transferSacPZ: transferSacPZ,
    transferSacPZSegment: transferSacPZSegment,
    calcResponse: calcResponse,
    calcResponseFromSacPoleZero: calcResponseFromSacPoleZero,
    combine: combine,
    evalPoleZeroInverse: evalPoleZeroInverse,
    calcFreqTaper: calcFreqTaper,
    applyFreqTaper: applyFreqTaper,
    UNITS: UNITS,
    convertToSacPoleZero: convertToSacPoleZero,
    calc_A0: calc_A0
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  let IRIS_HOST$4 = "service.iris.edu";
  const TEXT_FORMAT = "text";
  const JSON_FORMAT = "json";
  const SVG_FORMAT = "svg";
  /**
   * Query to the IRIS traveltime webservice, based on the TauP Toolkit. See
   * http://service.iris.edu/irisws/traveltime/1/ and
   * https://www.seis.sc.edu/TauP/
   *
   * @param host optional host to connect to, defaults to IRIS
   */

  class TraveltimeQuery {
    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */

    /** @private */
    constructor(host) {
      this._specVersion = "1";
      this._protocol = checkProtocol();

      if (!isNonEmptyStringArg(host)) {
        this._host = IRIS_HOST$4;
      } else {
        this._host = host;
      }

      this._format = JSON_FORMAT;
      this._noheader = false; // only for text format
    }

    protocol(value) {
      return hasArgs(value) ? (this._protocol = value, this) : this._protocol;
    }

    host(value) {
      return hasArgs(value) ? (this._host = value, this) : this._host;
    }

    specVersion(value) {
      return hasArgs(value) ? (this._specVersion = value, this) : this._specVersion;
    }

    evdepth(value) {
      return hasArgs(value) ? (this._evdepth = value, this) : this._evdepth;
    }

    distdeg(value) {
      return hasArgs(value) ? (this._distdeg = value, this) : this._distdeg;
    }

    model(value) {
      return hasArgs(value) ? (this._model = value, this) : this._model;
    }

    phases(value) {
      return hasArgs(value) ? (this._phases = value, this) : this._phases;
    }

    stalat(value) {
      return hasArgs(value) ? (this._stalat = value, this) : this._stalat;
    }

    stalon(value) {
      return hasArgs(value) ? (this._stalon = value, this) : this._stalon;
    }

    latLonFromStation(station) {
      this.stalat(station.latitude);
      this.stalon(station.longitude);
      return this;
    }

    evlat(value) {
      return hasArgs(value) ? (this._evlat = value, this) : this._evlat;
    }

    evlon(value) {
      return hasArgs(value) ? (this._evlon = value, this) : this._evlon;
    }

    latLonFromQuake(quake) {
      this.evlat(quake.latitude);
      this.evlon(quake.longitude);
      this.evdepth(quake.depth / 1000);
      return this;
    }

    format(value) {
      return hasArgs(value) ? (this._format = value, this) : this._format;
    }

    noheader(value) {
      return hasArgs(value) ? (this._noheader = value, this) : this._noheader;
    }

    convertToArrival(ttimeline) {
      let items = ttimeline.trim().split(/\s+/);
      return {
        distdeg: parseFloat(items[0]),
        phase: items[2],
        time: parseFloat(items[3]),
        rayparam: parseFloat(items[4]),
        takeoff: parseFloat(items[5]),
        incident: parseFloat(items[6]),
        puristdist: parseFloat(items[7]),
        puristname: items[9]
      };
    }

    queryText() {
      this.format(TEXT_FORMAT);
      return fetch(this.formURL()).then(response => {
        if (response.ok) {
          return response.text();
        } else {
          throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
        }
      });
    }

    queryJson() {
      this.format(JSON_FORMAT);
      return fetch(this.formURL()).then(response => {
        if (response.ok) {
          return response.json();
        } else {
          throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
        }
      });
    }

    querySvg() {
      this.format(SVG_FORMAT);
      return fetch(this.formURL()).then(response => {
        if (response.ok) {
          return response.text().then(textResponse => new window.DOMParser().parseFromString(textResponse, "text/xml")).then(xml => {
            let elArray = xml.getElementsByTagName("svg");

            if (elArray.length > 0) {
              return elArray[0];
            } else {
              throw new Error("Can't find svg element in response");
            }
          });
        } else {
          throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
        }
      });
    }

    queryWadl() {
      return fetch(this.formWadlURL()).then(response => {
        if (response.ok) {
          return response.text().then(textResponse => new window.DOMParser().parseFromString(textResponse, "text/xml"));
        } else {
          throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
        }
      });
    }

    query() {
      if (this._format === JSON_FORMAT) {
        return this.queryJson();
      } else if (this._format === SVG_FORMAT) {
        return this.querySvg();
      } else if (this._format === TEXT_FORMAT) {
        return this.queryText();
      } else {
        throw new Error("Unknown format: " + this._format);
      }
    }

    makeParam(name, val) {
      return name + "=" + encodeURIComponent(stringify(val)) + "&";
    }

    formBaseURL() {
      let colon = ":";

      if (this._protocol.endsWith(colon)) {
        colon = "";
      }

      let url = this._protocol + colon + "//" + this._host + "/irisws/traveltime/" + this._specVersion + "/";
      return url;
    }

    formURL() {
      let url = this.formBaseURL() + 'query?';

      if (isDef(this._noheader) && this._noheader) {
        url = url + "noheader=true&";
      }

      if (isDef(this._evdepth)) {
        url = url + this.makeParam("evdepth", this.evdepth());
      }

      if (isDef(this._stalat) && isDef(this._stalon)) {
        url = url + this.makeParam("staloc", "[" + stringify(this.stalat()) + "," + stringify(this.stalon()) + "]");
      }

      if (isDef(this._evlat) && isDef(this._evlon)) {
        url = url + this.makeParam("evloc", "[" + stringify(this.evlat()) + "," + stringify(this.evlon()) + "]");
      }

      if (isDef(this._distdeg)) {
        url = url + this.makeParam("distdeg", this.distdeg());
      }

      if (isDef(this._model)) {
        url = url + this.makeParam("model", this.model());
      }

      if (isDef(this._phases)) {
        url = url + this.makeParam("phases", this.phases());
      }

      if (isDef(this._format)) {
        url = url + this.makeParam("format", this.format());
      }

      if (url.endsWith('&') || url.endsWith('?')) {
        url = url.substr(0, url.length - 1); // zap last & or ?
      }

      return url;
    }

    queryTauPVersion() {
      return fetch(this.formTauPVersionURL()).then(response => {
        if (response.ok) {
          return response.text();
        } else {
          throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
        }
      });
    }

    formTauPVersionURL() {
      return this.formBaseURL() + 'taupversion';
    }

    formWadlURL() {
      return this.formBaseURL() + 'application.wadl';
    }

  }

  var traveltime = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IRIS_HOST: IRIS_HOST$4,
    TEXT_FORMAT: TEXT_FORMAT,
    JSON_FORMAT: JSON_FORMAT,
    SVG_FORMAT: SVG_FORMAT,
    TraveltimeQuery: TraveltimeQuery
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /**
   * const for degrees to radians, pi/180
   */

  const DtoR = Math.PI / 180;
  /**
   * Result of rotation for 2 seismograms.
   */

  class RotatedSeismograms {
    constructor(radial, azimuthRadial, transverse, azimuthTransverse, rotation) {
      this.radial = radial;
      this.azimuthRadial = azimuthRadial;
      this.transverse = transverse;
      this.azimuthTransverse = azimuthTransverse;
      this.rotation = rotation;
    }

  }
  /**
   * Rotates the given seismograms from their given azimuths so the output radial
   * is along the new azimuth and the output transverse is perpendicular to it.
   *
   * @param   seisA    first seismogram
   * @param   azimuthA azimuth of first seismogram
   * @param   seisB    second seismogram
   * @param   azimuthB azimuth of second seismogram
   * @param   azimuth  output radial azimuth to rotate to
   * @returns radial and transverse seismograms
   */

  function rotate(seisA, azimuthA, seisB, azimuthB, azimuth) {
    if (seisA.segments.length !== seisB.segments.length) {
      throw new Error("Seismograms do not have same number of segments: " + seisA.segments.length + " !== " + seisB.segments.length);
    }

    let rotOutRad = [];
    let rotOutTrans = [];

    for (let i = 0; i < seisA.segments.length; i++) {
      let result = rotateSeismogramSegment(seisA.segments[i], azimuthA, seisB.segments[i], azimuthB, azimuth);
      rotOutRad.push(result.radial);
      rotOutTrans.push(result.transverse);
    }

    let out = new RotatedSeismograms(new Seismogram(rotOutRad), azimuth % 360, new Seismogram(rotOutTrans), (azimuth + 90) % 360, azimuth - azimuthA);
    return out;
  }
  /**
   * Rotates two seismogram segments, checking for same length and time alignment.
   *
   * @param   seisA    first seismogram
   * @param   azimuthA azimuth of first
   * @param   seisB    second seismogram
   * @param   azimuthB azimuth of second
   * @param   azimuth  azimuth to rotate to as radial, transverse will be +90 deg
   * @returns           rotated seismogram segments along with their aziumths
   */

  function rotateSeismogramSegment(seisA, azimuthA, seisB, azimuthB, azimuth) {
    if (seisA.y.length !== seisB.y.length) {
      throw new Error("seisA and seisB should be of same lenght but was " + seisA.y.length + " " + seisB.y.length);
    }

    if (!seisA.startTime.isSame(seisB.startTime)) {
      throw new Error("Expect startTime to be same, but was " + seisA.startTime.toISOString() + " " + seisB.startTime.toISOString());
    }

    if (seisA.sampleRate !== seisB.sampleRate) {
      throw new Error("Expect sampleRate to be same, but was " + seisA.sampleRate + " " + seisB.sampleRate);
    }

    if ((azimuthA + 90) % 360 !== azimuthB % 360) {
      throw new Error("Expect azimuthB to be azimuthA + 90, but was " + azimuthA + " " + azimuthB);
    } //  [   cos(theta)    -sin(theta)    0   ]
    //  [   sin(theta)     cos(theta)    0   ]
    //  [       0              0         1   ]
    // seisB => x
    // seisA => y
    // sense of rotation is opposite for aziumth vs math


    const rotRadian = 1 * DtoR * (azimuth - azimuthA);
    const cosTheta = Math.cos(rotRadian);
    const sinTheta = Math.sin(rotRadian);
    let x = new Float32Array(seisA.y.length);
    let y = new Float32Array(seisA.y.length);

    for (let i = 0; i < seisA.y.length; i++) {
      x[i] = cosTheta * seisB.yAtIndex(i) - sinTheta * seisA.yAtIndex(i);
      y[i] = sinTheta * seisB.yAtIndex(i) + cosTheta * seisA.yAtIndex(i);
    }

    let outSeisRad = seisA.cloneWithNewData(y);
    outSeisRad.channelCode = seisA.chanCode.slice(0, 2) + "R";
    let outSeisTan = seisA.cloneWithNewData(x);
    outSeisTan.channelCode = seisA.chanCode.slice(0, 2) + "T";
    let out = {
      "radial": outSeisRad,
      "transverse": outSeisTan,
      "azimuthRadial": azimuth % 360,
      "azimuthTransverse": (azimuth + 90) % 360
    };
    return out;
  }
  /**
   * creates a new Seismogram where the value at each sample is the
   * vector magnitude of the 3 corresponding data points from each seismogram.
   * Each of the 3 seismograms are assumed to be mutually perpendicular so
   * that each set of samples gives a vector in 3-dimensional space. In particular
   * all three seismograms must have the same number of samples and sample rate.
   * It is assumed, but not checked, that they will be the three components of
   * motion at a station (ie matching network, station and location codes)
   * and have the same start time.
   *
   * @param   seisA first seismogram
   * @param   seisB second seismogram
   * @param   seisC third seismogram
   * @returns Seismogram of vector magnitudes
   */


  function vectorMagnitude(seisA, seisB, seisC) {
    if (seisA.segments.length !== seisB.segments.length) {
      throw new Error("Seismograms do not have same number of segments: " + seisA.segments.length + " !== " + seisB.segments.length + " !== " + seisC.segments.length);
    }

    if (seisA.segments.length !== seisC.segments.length) {
      throw new Error("Seismograms do not have same number of segments: " + seisA.segments.length + " !== " + seisB.segments.length + " !== " + seisC.segments.length);
    }

    let outSeis = [];

    for (let i = 0; i < seisA.segments.length; i++) {
      let result = vectorMagnitudeSegment(seisA.segments[i], seisB.segments[i], seisC.segments[i]);
      outSeis.push(result);
    }

    return new Seismogram(outSeis);
  }
  /**
   * Calculates the vector magnitude of three components of motion. Each of the three
   * should be mutually perpendicular.
   *
   * @param   seisA first seismogram
   * @param   seisB second perpendicular seismogram
   * @param   seisC thrid perpendicular seismogram
   * @returns         seismogram representing the vector magnitude, sqrt(x*x+y*y+z*z)
   */

  function vectorMagnitudeSegment(seisA, seisB, seisC) {
    if (seisA.y.length !== seisB.y.length) {
      throw new Error("seisA and seisB should be of same lenght but was " + seisA.y.length + " " + seisB.y.length);
    }

    if (seisA.sampleRate !== seisB.sampleRate) {
      throw new Error("Expect sampleRate to be same, but was " + seisA.sampleRate + " " + seisB.sampleRate);
    }

    if (seisA.y.length !== seisC.y.length) {
      throw new Error("seisA and seisC should be of same lenght but was " + seisA.y.length + " " + seisC.y.length);
    }

    if (seisA.sampleRate !== seisC.sampleRate) {
      throw new Error("Expect sampleRate to be same, but was " + seisA.sampleRate + " " + seisC.sampleRate);
    }

    let y;

    if (seisA.y instanceof Float64Array) {
      y = new Float64Array(seisA.y.length);
    } else {
      y = new Float32Array(seisA.y.length);
    }

    for (let i = 0; i < seisA.y.length; i++) {
      y[i] = Math.sqrt(seisA.y[i] * seisA.y[i] + seisB.y[i] * seisB.y[i] + seisC.y[i] * seisC.y[i]);
    }

    let outSeis = seisA.cloneWithNewData(y);
    outSeis.channelCode = seisA.chanCode.slice(0, 2) + "M";
    return outSeis;
  }

  var vector = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DtoR: DtoR,
    RotatedSeismograms: RotatedSeismograms,
    rotate: rotate,
    vectorMagnitude: vectorMagnitude
  });

  /*
   * Philip Crotwell
   * University of South Carolina, 2019
   * http://www.seis.sc.edu
   */
  /** const for unknown data version, 0 */

  const UNKNOWN_DATA_VERSION = 0;
  /** const for offset to crc in record, 28 */

  const CRC_OFFSET = 28;
  /** const for size of fixed header part of record, 40 */

  const FIXED_HEADER_SIZE = 40;
  /** const for fdsn prefix for extra headers, FDSN */

  const FDSN_PREFIX = 'FDSN';
  /** const for little endian, true */

  const LITTLE_ENDIAN = true;
  /**
   * parse arrayBuffer into an array of XSeedRecords.
   *
   * @param arrayBuffer bytes to extract xseed records from
   * @returns array of all xseed records contained in the buffer
   */

  function parseXSeedRecords(arrayBuffer) {
    let dataRecords = [];
    let offset = 0;

    while (offset < arrayBuffer.byteLength) {
      let dataView = new DataView(arrayBuffer, offset);

      if (!(dataView.getUint8(0) === 77 && dataView.getUint8(1) === 83)) {
        throw new Error("First byte must be M=77 S=83 at offset=".concat(offset, ", but was ").concat(dataView.getUint8(0), " ").concat(dataView.getUint8(1)));
      }

      let dr = XSeedRecord.createFromDataView(dataView);
      dataRecords.push(dr);
      offset += dr.getSize();
    }

    return dataRecords;
  }
  /**
   * Represents a xSEED Data Record, with header, extras and data.
   *
   * @param header xseed fixed record header
   * @param extraHeaders json compatible object with extra headers
   * @param rawData waveform data, in correct compression for value in header
   */

  class XSeedRecord {
    constructor(header, extraHeaders, rawData) {
      this.header = header;
      this.rawData = rawData;
      this.extraHeaders = extraHeaders;
    }
    /**
     * Parses an xseed data record from a DataView.
     *
     * @param   dataView bytes to parse
     * @returns parsed record
     */


    static createFromDataView(dataView) {
      const header = XSeedHeader.createFromDataView(dataView);
      let extraDataView = new DataView(dataView.buffer, dataView.byteOffset + header.getSize(), header.extraHeadersLength);
      const extraHeaders = parseExtraHeaders(extraDataView);
      let sliceStart = dataView.byteOffset + header.getSize() + header.extraHeadersLength;
      const rawData = new DataView(dataView.buffer.slice(sliceStart, sliceStart + header.dataLength));
      const xr = new XSeedRecord(header, extraHeaders, rawData);
      return xr;
    }
    /**
     * Calculates the byte size of the xseed record to hold this data.
     *
     * @returns size in bytes
     */


    getSize() {
      let json = JSON.stringify(this.extraHeaders);

      if (json.length > 2) {
        this.header.extraHeadersLength = json.length;
      } else {
        this.header.extraHeadersLength = 0;
      }

      return this.header.getSize() + this.header.extraHeadersLength + this.header.dataLength;
    }
    /** Decompresses the data , if the compression
     *  type is known
     *
     * @returns decompressed data as a typed array, usually Int32Array or Float32Array
     */


    decompress() {
      return this.asEncodedDataSegment().decode();
    }
    /**
     * Wraps data in an EncodedDataSegment for future decompression.
     *
     * @returns waveform data
     */


    asEncodedDataSegment() {
      return new EncodedDataSegment(this.header.encoding, this.rawData, this.header.numSamples, LITTLE_ENDIAN);
    }
    /**
     * Just the header.identifier, included as codes() for compatiblility
     * with parsed miniseed2 data records.
     *
     * @returns string identifier
     */


    codes() {
      return this.header.identifier;
    }
    /**
     * Saves xseed record into a DataView, recalculating crc.
     *
     * @param   dataView DataView to save into, must be large enough to hold the record.
     * @returns the number of bytes written to the DataView, can be used as offset
     * for writting the next record.
     */


    save(dataView) {
      let json = JSON.stringify(this.extraHeaders);

      if (json.length > 2) {
        this.header.extraHeadersLength = json.length;
      } else {
        this.header.extraHeadersLength = 0;
      } // don't write crc as we need to recalculate


      let offset = this.header.save(dataView, 0, true);

      if (json.length > 2) {
        for (let i = 0; i < json.length; i++) {
          // not ok for unicode?
          dataView.setInt8(offset, json.charCodeAt(i));
          offset++;
        }
      }

      if (this.rawData !== null) {
        for (let i = 0; i < this.rawData.byteLength; i++) {
          dataView.setUint8(offset + i, this.rawData.getUint8(i));
        }

        offset += this.rawData.byteLength;
      } else {
        throw new Error("rawData is null");
      }

      let dvcrc = dataView.getUint32(CRC_OFFSET, true);

      if (dvcrc !== 0) {
        throw new Error("CRC is not zero before calculate! ".concat(dvcrc));
      }

      let crc = calculateCRC32C(dataView.buffer);
      dataView.setUint32(CRC_OFFSET, crc, true);
      return offset;
    }
    /**
     * Calculates crc by saving to a DataView, which sets the crc header to zero
     * and then calculates it based on the rest of the record.
     *
     * @returns         crc pulled from saved xseed record
     */


    calcCrc() {
      let size = this.getSize();
      let buff = new ArrayBuffer(this.getSize());
      let dataView = new DataView(buff);
      let offset = this.save(dataView);

      if (offset !== size) {
        throw new Error("expect to write ".concat(size, " bytes but only ").concat(offset));
      }

      let crc = dataView.getUint32(CRC_OFFSET, true);
      return crc;
    }

  }
  /**
   * Fixed header of an XSeed data record.
   */

  class XSeedHeader {
    constructor() {
      // empty construction
      this.recordIndicator = 'MS';
      this.formatVersion = 3;
      this.flags = 0;
      this.nanosecond = 0;
      this.year = 1970;
      this.dayOfYear = 1;
      this.hour = 0;
      this.minute = 0;
      this.second = 0;
      this.encoding = 3; // 32 bit ints

      this.sampleRatePeriod = 1;
      this.numSamples = 0;
      this.crc = 0;
      this.publicationVersion = UNKNOWN_DATA_VERSION;
      this.identifierLength = 0;
      this.extraHeadersLength = 2;
      this.identifier = "";
      this.extraHeaders = {};
      this.dataLength = 0;
    }
    /**
     * Parses an xseed fixed header from a DataView.
     *
     * @param   dataView bytes to parse
     * @returns parsed header object
     */


    static createFromDataView(dataView) {
      const header = new XSeedHeader();
      header.recordIndicator = makeString$1(dataView, 0, 2);

      if (!header.recordIndicator === 'MS') {
        throw new Error("First 2 bytes of record should be MS but found " + header.recordIndicator);
      }

      header.formatVersion = dataView.getUint8(2);

      if (header.formatVersion !== 3) {
        throw new Error("Format Version should be 3, " + header.formatVersion);
      }

      header.flags = dataView.getUint8(3);
      const headerLittleEndian = true;
      header.nanosecond = dataView.getInt32(4, headerLittleEndian);
      header.year = dataView.getInt16(8, headerLittleEndian);

      if (checkByteSwap$1(header.year)) {
        throw new Error("Looks like wrong byte order, year=" + header.year);
      }

      header.dayOfYear = dataView.getInt16(10, headerLittleEndian);
      header.hour = dataView.getUint8(12);
      header.minute = dataView.getUint8(13);
      header.second = dataView.getUint8(14);
      header.encoding = dataView.getUint8(15);
      header.sampleRatePeriod = dataView.getFloat64(16, headerLittleEndian);

      if (header.sampleRatePeriod < 0) {
        header.sampleRate = 1 / header.sampleRatePeriod;
      } else {
        header.sampleRate = header.sampleRatePeriod;
      }

      header.numSamples = dataView.getUint32(24, headerLittleEndian);
      header.crc = dataView.getUint32(28, headerLittleEndian);
      header.publicationVersion = dataView.getUint8(32);
      header.identifierLength = dataView.getUint8(33);
      header.extraHeadersLength = dataView.getUint16(34, headerLittleEndian);
      header.dataLength = dataView.getUint32(36, headerLittleEndian);
      header.identifier = makeString$1(dataView, 40, header.identifierLength); // lazily extract json and data

      header.start = header._startToMoment();
      header.end = header.timeOfSample(header.numSamples - 1);
      return header;
    }
    /**
     * Calculates size of the fixed header including the identifier, but without
     * the extra headers.
     *
     * @returns size in bytes of fixed header
     */


    getSize() {
      return FIXED_HEADER_SIZE + this.identifier.length;
    }

    toString() {
      return this.identifier + " " + this.start.toISOString() + " " + this.encoding;
    }
    /**
     * Converts start time header fields to ISO8641 time string.
     *
     * @returns iso start time
     */


    getStartFieldsAsISO() {
      return '' + this.year + '-' + padZeros(this.dayOfYear, 3) + 'T' + padZeros(this.hour, 2) + ':' + padZeros(this.minute, 2) + ":" + padZeros(this.second, 2) + "." + padZeros(this.nanosecond, 9) + "Z";
    }
    /**
     * Calculates time of the ith sample.
     *
     * @param   i sample number
     * @returns the time
     */


    timeOfSample(i) {
      return moment__default.utc(this.start).add(1000 * i / this.sampleRate, 'milliseconds');
    }
    /**
     * Writes to the given dataview.
     *
     * @param   dataView write buffer
     * @param   offset   offset within the buffer
     * @param   zeroCrc  optionally zero out the crc field in order to recalculate
     * @returns          new offset after this record
     */


    save(dataView, offset = 0, zeroCrc = false) {
      dataView.setInt8(offset, this.recordIndicator.charCodeAt(0));
      offset++;
      dataView.setInt8(offset, this.recordIndicator.charCodeAt(1));
      offset++;
      dataView.setInt8(offset, this.formatVersion);
      offset++;
      dataView.setInt8(offset, this.flags);
      offset++;
      dataView.setUint32(offset, this.nanosecond, true);
      offset += 4;
      dataView.setUint16(offset, this.year, true);
      offset += 2;
      dataView.setUint16(offset, this.dayOfYear, true);
      offset += 2;
      dataView.setInt8(offset, this.hour);
      offset++;
      dataView.setInt8(offset, this.minute);
      offset++;
      dataView.setInt8(offset, this.second);
      offset++;
      dataView.setInt8(offset, this.encoding);
      offset++;
      dataView.setFloat64(offset, this.sampleRatePeriod, true);
      offset += 8;
      dataView.setUint32(offset, this.numSamples, true);
      offset += 4;

      if (zeroCrc) {
        dataView.setUint32(offset, 0, true);
      } else {
        dataView.setUint32(offset, this.crc, true);
      }

      offset += 4;
      dataView.setInt8(offset, this.publicationVersion);
      offset++;
      dataView.setInt8(offset, this.identifier.length);
      offset++;
      dataView.setUint16(offset, this.extraHeadersLength, true);
      offset += 2;
      dataView.setUint32(offset, this.dataLength, true);
      offset += 4;

      for (let i = 0; i < this.identifier.length; i++) {
        // not ok for unicode?
        dataView.setInt8(offset, this.identifier.charCodeAt(i));
        offset++;
      }

      return offset;
    }
    /**
     * Converts header start time to moment
     *
     * @returns         start time as moment
     */


    _startToMoment() {
      let m = new moment__default.utc([this.year, 0, 1, this.hour, this.minute, this.second, 0]);
      m.add(Math.round(this.nanosecond / 1000000), 'ms');
      m.dayOfYear(this.dayOfYear);

      if (m.isValid()) {
        return m;
      } else {
        throw new Error("Header start is invalid moment: ".concat(this.year, " ").concat(this.dayOfYear, " ").concat(this.hour, " ").concat(this.minute, " ").concat(this.second, " ").concat(this.nanosecond));
      }
    }

  }
  /**
   * Parses extra headers as json.
   *
   * @param   dataView json bytes as DataView
   * @returns           json object
   */

  function parseExtraHeaders(dataView) {
    if (dataView.byteLength === 0) {
      return {};
    }

    let firstChar = dataView.getUint8(0);

    if (firstChar === 123) {
      // looks like json, '{' is ascii 123
      return JSON.parse(makeString$1(dataView, 0, dataView.byteLength));
    } else {
      // $FlowFixMe
      throw new Error("do not understand extras with first char val: " + firstChar + " " + (firstChar === 123));
    }
  }
  /**
   * Creates a string version of a number with zero prefix padding. For example
   * padZeros(5, 3) is 005.
   *
   * @param   val number to stringify
   * @param   len total length of string
   * @returns      zero padded string
   */

  function padZeros(val, len) {
    let out = "" + val;

    while (out.length < len) {
      out = "0" + out;
    }

    return out;
  }
  /**
   * creates a string from bytes in a DataView.
   *
   * @param   dataView data bytes
   * @param   offset   offset to first byte to use
   * @param   length   number of bytes to convert
   * @returns           string resulting from utf-8 conversion
   */

  function makeString$1(dataView, offset, length) {
    const utf8decoder = new TextDecoder('utf-8');
    let u8arr = new Uint8Array(dataView.buffer, dataView.byteOffset + offset, length);
    return utf8decoder.decode(u8arr).trim();
  }
  /**
   * Sanity checks on year to see if a record might be in the wrong byte order.
   * Checks year betwee 1960 and 2055.
   *
   * @param   year year as number to test
   * @returns        true is byte order appears to be wrong, false if it seems ok
   */

  function checkByteSwap$1(year) {
    return year < 1960 || year > 2055;
  }
  /**
   * Checks if two xseed records are (nearly) contiguous.
   *
   * @param   dr1 first record
   * @param   dr2 second record
   * @param   sampRatio tolerence expressed as ratio of sample period, default 1.5
   * @returns      true if contiguous
   */


  function areContiguous$1(dr1, dr2, sampRatio = 1.5) {
    let h1 = dr1.header;
    let h2 = dr2.header;
    return h1.end.isBefore(h2.start) && moment__default.utc(h1.end).add(sampRatio / h1.sampleRate, 'seconds').isSameOrAfter(h2.start);
  }
  /** concatentates a sequence of XSeedRecords into a single seismogram object.
   * Assumes that they are all contiguous (no gaps or overlaps) and in order.
   * Header values from the first XSeedRecord are used.
   *
   * @param contig array of xseed records
   * @returns seismogram segment for the records
   */

  function createSeismogramSegment$1(contig) {
    let contigData = contig.map(dr => dr.asEncodedDataSegment());
    let out = new SeismogramSegment(contigData, contig[0].header.sampleRate, contig[0].header.start);
    let codes = contig[0].header.identifier.slice(5).split('_');
    out.networkCode = codes[0];
    out.stationCode = codes[1];
    out.locationCode = codes[2];
    out.channelCode = codes[3] + codes[4] + codes[5];
    return out;
  }
  /**
   * Merges xseed records into a Seismogram object, each of
   * which consists of SeismogramSegment objects
   * containing the data as EncodedDataSegment objects. DataRecords are
   * sorted by startTime.
   * This assumes all data records are from the same channel, byChannel
   * can be used first if multiple channels may be present. Gaps may be present.
   *
   * @param drList list of xseed records to convert
   * @returns the seismogram
   */

  function merge$1(drList) {
    let out = [];
    let currDR;
    drList.sort(function (a, b) {
      return a.header.start.getTime() - b.header.start.getTime();
    });
    let contig = [];

    for (let i = 0; i < drList.length; i++) {
      currDR = drList[i];

      if (contig.length === 0) {
        contig.push(currDR);
      } else if (areContiguous$1(contig[contig.length - 1], currDR)) {
        contig.push(currDR);
      } else {
        //found a gap
        out.push(createSeismogramSegment$1(contig));
        contig = [currDR];
      }
    }

    if (contig.length > 0) {
      // last segment
      out.push(createSeismogramSegment$1(contig));
      contig = [];
    }

    return new Seismogram(out);
  }
  /**
   * splits a list of data records by channel identifier, returning an object
   * with each NSLC mapped to an array of data records.
   *
   * @param drList array of xseed records
   * @returns map of channel id to array of xseed records, possibly not contiguous
   */

  function byChannel$1(drList) {
    let out = new Map();
    let key;

    for (let i = 0; i < drList.length; i++) {
      let currDR = drList[i];
      key = currDR.codes();
      let drArray = out.get(key);

      if (!drArray) {
        drArray = [currDR];
        out.set(key, drArray);
      } else {
        drArray.push(currDR);
      }
    }

    return out;
  }
  /**
   * splits the XSeedRecords by channel and creates a single
   * Seismogram for each channel.
   *
   * @param   drList XSeedRecords array
   * @returns         Map of code to Seismogram
   */

  function seismogramPerChannel$1(drList) {
    let out = [];
    let byChannelMap = byChannel$1(drList);
    byChannelMap.forEach(segments => out.push(merge$1(segments)));
    return out;
  }
  /* MSeed2 to xSeed converstion */

  /**
   * Convert array of Miniseed2 DataRecords into an array of XSeedRecords.
   *
   * @param   mseed2 array of DataRecords
   * @returns         array of XSeedRecords
   */

  function convertMS2toXSeed(mseed2) {
    let out = [];

    for (let i = 0; i < mseed2.length; i++) {
      out.push(convertMS2Record(mseed2[i]));
    }

    return out;
  }
  /**
   * Converts a single miniseed2 DataRecord into a single XSeedRecord.
   *
   * @param   ms2record Miniseed2 DataRecord to convert
   * @returns            XSeedRecord
   */

  function convertMS2Record(ms2record) {
    let xHeader = new XSeedHeader();
    let xExtras = {};
    let ms2H = ms2record.header;
    xHeader.flags = (ms2H.activityFlags & 1) * 2 + (ms2H.ioClockFlags & 64) * 4 + (ms2H.dataQualityFlags & 16) * 8;
    xHeader.year = ms2H.startBTime.year;
    xHeader.dayOfYear = ms2H.startBTime.jday;
    xHeader.hour = ms2H.startBTime.hour;
    xHeader.minute = ms2H.startBTime.min;
    xHeader.second = ms2H.startBTime.sec;
    xHeader.nanosecond = ms2H.startBTime.tenthMilli * 100000 + ms2H.startBTime.microsecond * 1000;
    xHeader.sampleRatePeriod = ms2H.sampleRate >= 1 ? ms2H.sampleRate : -1.0 / ms2H.sampleRate;
    xHeader.encoding = ms2record.header.encoding;
    xHeader.publicationVersion = UNKNOWN_DATA_VERSION;
    xHeader.dataLength = ms2record.data.byteLength;
    xHeader.identifier = FDSN_PREFIX + ':' + ms2H.netCode + SEP + ms2H.staCode + SEP + (ms2H.locCode ? ms2H.locCode : "") + SEP + ms2H.chanCode;
    xHeader.identifierLength = xHeader.identifier.length;
    xHeader.numSamples = ms2H.numSamples;
    xHeader.crc = 0;

    if (ms2H.typeCode) {
      if (ms2H.typeCode === 'R') {
        xHeader.publicationVersion = 1;
      } else if (ms2H.typeCode === 'D') {
        xHeader.publicationVersion = 2;
      } else if (ms2H.typeCode === 'Q') {
        xHeader.publicationVersion = 3;
      } else if (ms2H.typeCode === 'M') {
        xHeader.publicationVersion = 4;
      }

      if (ms2H.typeCode !== 'D') {
        xExtras.DataQuality = ms2H.typeCode;
      }
    }

    if (xHeader.nanosecond < 0) {
      xHeader.second -= 1;
      xHeader.nanosecond += 1000000000;

      if (xHeader.second < 0) {
        // might be wrong for leap seconds
        xHeader.second += 60;
        xHeader.minute -= 1;

        if (xHeader.minute < 0) {
          xHeader.minute += 60;
          xHeader.hour -= 1;

          if (xHeader.hour < 0) {
            xHeader.hour += 24;
            xHeader.dayOfYear = -1;

            if (xHeader.dayOfYear < 0) {
              // wrong for leap years
              xHeader.dayOfYear += 365;
              xHeader.year -= 1;
            }
          }
        }
      }
    }

    xHeader.extraHeadersLength = JSON.stringify(xExtras).length; // need to convert if not steim1 or 2

    let out = new XSeedRecord(xHeader, xExtras, ms2record.data);
    return out;
  }
  /**
   * Default separator for channel id.
   */

  const SEP = '_';
  /**
   * Copy from https://github.com/ashi009/node-fast-crc32c/blob/master/impls/js_crc32c.js
   * and modify to use ArrayBuffer.
   *
   * This code is a manual javascript translation of c code generated by
   * pycrc 0.7.1 (http://www.tty1.net/pycrc/). Command line used:
   * './pycrc.py --model=crc-32c --generate c --algorithm=table-driven'
   */

  const kCRCTable = new Int32Array([0x00000000, 0xf26b8303, 0xe13b70f7, 0x1350f3f4, 0xc79a971f, 0x35f1141c, 0x26a1e7e8, 0xd4ca64eb, 0x8ad958cf, 0x78b2dbcc, 0x6be22838, 0x9989ab3b, 0x4d43cfd0, 0xbf284cd3, 0xac78bf27, 0x5e133c24, 0x105ec76f, 0xe235446c, 0xf165b798, 0x030e349b, 0xd7c45070, 0x25afd373, 0x36ff2087, 0xc494a384, 0x9a879fa0, 0x68ec1ca3, 0x7bbcef57, 0x89d76c54, 0x5d1d08bf, 0xaf768bbc, 0xbc267848, 0x4e4dfb4b, 0x20bd8ede, 0xd2d60ddd, 0xc186fe29, 0x33ed7d2a, 0xe72719c1, 0x154c9ac2, 0x061c6936, 0xf477ea35, 0xaa64d611, 0x580f5512, 0x4b5fa6e6, 0xb93425e5, 0x6dfe410e, 0x9f95c20d, 0x8cc531f9, 0x7eaeb2fa, 0x30e349b1, 0xc288cab2, 0xd1d83946, 0x23b3ba45, 0xf779deae, 0x05125dad, 0x1642ae59, 0xe4292d5a, 0xba3a117e, 0x4851927d, 0x5b016189, 0xa96ae28a, 0x7da08661, 0x8fcb0562, 0x9c9bf696, 0x6ef07595, 0x417b1dbc, 0xb3109ebf, 0xa0406d4b, 0x522bee48, 0x86e18aa3, 0x748a09a0, 0x67dafa54, 0x95b17957, 0xcba24573, 0x39c9c670, 0x2a993584, 0xd8f2b687, 0x0c38d26c, 0xfe53516f, 0xed03a29b, 0x1f682198, 0x5125dad3, 0xa34e59d0, 0xb01eaa24, 0x42752927, 0x96bf4dcc, 0x64d4cecf, 0x77843d3b, 0x85efbe38, 0xdbfc821c, 0x2997011f, 0x3ac7f2eb, 0xc8ac71e8, 0x1c661503, 0xee0d9600, 0xfd5d65f4, 0x0f36e6f7, 0x61c69362, 0x93ad1061, 0x80fde395, 0x72966096, 0xa65c047d, 0x5437877e, 0x4767748a, 0xb50cf789, 0xeb1fcbad, 0x197448ae, 0x0a24bb5a, 0xf84f3859, 0x2c855cb2, 0xdeeedfb1, 0xcdbe2c45, 0x3fd5af46, 0x7198540d, 0x83f3d70e, 0x90a324fa, 0x62c8a7f9, 0xb602c312, 0x44694011, 0x5739b3e5, 0xa55230e6, 0xfb410cc2, 0x092a8fc1, 0x1a7a7c35, 0xe811ff36, 0x3cdb9bdd, 0xceb018de, 0xdde0eb2a, 0x2f8b6829, 0x82f63b78, 0x709db87b, 0x63cd4b8f, 0x91a6c88c, 0x456cac67, 0xb7072f64, 0xa457dc90, 0x563c5f93, 0x082f63b7, 0xfa44e0b4, 0xe9141340, 0x1b7f9043, 0xcfb5f4a8, 0x3dde77ab, 0x2e8e845f, 0xdce5075c, 0x92a8fc17, 0x60c37f14, 0x73938ce0, 0x81f80fe3, 0x55326b08, 0xa759e80b, 0xb4091bff, 0x466298fc, 0x1871a4d8, 0xea1a27db, 0xf94ad42f, 0x0b21572c, 0xdfeb33c7, 0x2d80b0c4, 0x3ed04330, 0xccbbc033, 0xa24bb5a6, 0x502036a5, 0x4370c551, 0xb11b4652, 0x65d122b9, 0x97baa1ba, 0x84ea524e, 0x7681d14d, 0x2892ed69, 0xdaf96e6a, 0xc9a99d9e, 0x3bc21e9d, 0xef087a76, 0x1d63f975, 0x0e330a81, 0xfc588982, 0xb21572c9, 0x407ef1ca, 0x532e023e, 0xa145813d, 0x758fe5d6, 0x87e466d5, 0x94b49521, 0x66df1622, 0x38cc2a06, 0xcaa7a905, 0xd9f75af1, 0x2b9cd9f2, 0xff56bd19, 0x0d3d3e1a, 0x1e6dcdee, 0xec064eed, 0xc38d26c4, 0x31e6a5c7, 0x22b65633, 0xd0ddd530, 0x0417b1db, 0xf67c32d8, 0xe52cc12c, 0x1747422f, 0x49547e0b, 0xbb3ffd08, 0xa86f0efc, 0x5a048dff, 0x8ecee914, 0x7ca56a17, 0x6ff599e3, 0x9d9e1ae0, 0xd3d3e1ab, 0x21b862a8, 0x32e8915c, 0xc083125f, 0x144976b4, 0xe622f5b7, 0xf5720643, 0x07198540, 0x590ab964, 0xab613a67, 0xb831c993, 0x4a5a4a90, 0x9e902e7b, 0x6cfbad78, 0x7fab5e8c, 0x8dc0dd8f, 0xe330a81a, 0x115b2b19, 0x020bd8ed, 0xf0605bee, 0x24aa3f05, 0xd6c1bc06, 0xc5914ff2, 0x37faccf1, 0x69e9f0d5, 0x9b8273d6, 0x88d28022, 0x7ab90321, 0xae7367ca, 0x5c18e4c9, 0x4f48173d, 0xbd23943e, 0xf36e6f75, 0x0105ec76, 0x12551f82, 0xe03e9c81, 0x34f4f86a, 0xc69f7b69, 0xd5cf889d, 0x27a40b9e, 0x79b737ba, 0x8bdcb4b9, 0x988c474d, 0x6ae7c44e, 0xbe2da0a5, 0x4c4623a6, 0x5f16d052, 0xad7d5351]);
  /**
   * Copy from https://github.com/ashi009/node-fast-crc32c/blob/master/impls/js_crc32c.js
   * and modify to use ArrayBuffer. Rename calculateCRC32C
   *
   * This code is a manual javascript translation of c code generated by
   * pycrc 0.7.1 (http://www.tty1.net/pycrc/). Command line used:
   * './pycrc.py --model=crc-32c --generate c --algorithm=table-driven'
   *
   * @param buf input data
   * @param initial starting value, from earlier data
   *
   * @returns calculated crc32c value
   */

  function calculateCRC32C(buf, initial = 0) {
    if (buf instanceof ArrayBuffer) {
      buf = new Uint8Array(buf);
    } else if (buf instanceof Uint8Array) ; else {
      throw new Error("arg must be ArrayBuffer or Uint8Array");
    }

    let crc = (initial | 0) ^ -1;

    for (let i = 0; i < buf.length; i++) {
      crc = kCRCTable[(crc ^ buf[i]) & 0xff] ^ crc >>> 8;
    }

    return (crc ^ -1) >>> 0;
  }
  /**
   * Convert crc as a number into a hex string.
   *
   * @param   crc crc as a number
   * @returns      hex representation
   */

  function crcToHexString(crc) {
    if (crc < 0) {
      crc = 0xFFFFFFFF + crc + 1;
    }

    let s = crc.toString(16).toUpperCase();
    return "0x" + s;
  }

  var xseed = /*#__PURE__*/Object.freeze({
    __proto__: null,
    UNKNOWN_DATA_VERSION: UNKNOWN_DATA_VERSION,
    CRC_OFFSET: CRC_OFFSET,
    FIXED_HEADER_SIZE: FIXED_HEADER_SIZE,
    FDSN_PREFIX: FDSN_PREFIX,
    LITTLE_ENDIAN: LITTLE_ENDIAN,
    parseXSeedRecords: parseXSeedRecords,
    XSeedRecord: XSeedRecord,
    XSeedHeader: XSeedHeader,
    parseExtraHeaders: parseExtraHeaders,
    padZeros: padZeros,
    makeString: makeString$1,
    areContiguous: areContiguous$1,
    createSeismogramSegment: createSeismogramSegment$1,
    merge: merge$1,
    byChannel: byChannel$1,
    seismogramPerChannel: seismogramPerChannel$1,
    convertMS2toXSeed: convertMS2toXSeed,
    convertMS2Record: convertMS2Record,
    calculateCRC32C: calculateCRC32C,
    crcToHexString: crcToHexString
  });

  //
  const OregonDSP$1 = OregonDSPTop.com.oregondsp.signalProcessing;
  /**
   * Current version of seisplotjs
   */

  const version = '2.0.1';

  exports.moment = moment;
  exports.d3 = d3;
  exports.RSVP = RSVP__default;
  exports.OregonDSP = OregonDSP$1;
  exports.cssutil = cssutil;
  exports.datalink = datalink;
  exports.datechooser = datechooser;
  exports.distaz = distaz$1;
  exports.fdsnavailability = fdsnavailability;
  exports.fdsndatacenters = fdsndatacenters;
  exports.fdsndataselect = fdsndataselect;
  exports.fdsnevent = fdsnevent;
  exports.fdsnstation = fdsnstation;
  exports.fft = fft;
  exports.fftplot = fftplot;
  exports.filter = filter;
  exports.helicorder = helicorder;
  exports.knownDataCenters = knowndatacenters;
  exports.miniseed = miniseed;
  exports.mseedarchive = mseedarchive;
  exports.oregondsputil = oregondsputil;
  exports.particlemotion = particlemotion;
  exports.plotutil = plotutil;
  exports.quakeml = quakeml;
  exports.ringserverweb = ringserverweb;
  exports.sacPoleZero = sacpolezero;
  exports.seedcodec = seedcodec;
  exports.seedlink = seedlink;
  exports.seismogram = seismogram;
  exports.seismograph = seismograph;
  exports.seismographconfig = seismographconfig;
  exports.stationxml = stationxml;
  exports.taper = taper$1;
  exports.transfer = transfer$1;
  exports.traveltime = traveltime;
  exports.util = util;
  exports.vector = vector;
  exports.version = version;
  exports.xseed = xseed;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=seisplotjs-umd.js.map
