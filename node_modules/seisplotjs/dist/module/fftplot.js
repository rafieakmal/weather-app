import { insertCSS } from './cssutil.js';
import { select, extent, scaleLog, scaleLinear, axisBottom, axisLeft, line } from 'd3';
import { FFTResult } from './fft.js';
import { SeismographConfig } from './seismographconfig.js';

/*
 * Philip Crotwell
 * University of South Carolina, 2019
 * http://www.seis.sc.edu
 */
/**
 * Create a single amplitude plot of FFT data.
 *
 * @param   cssSelector selection of the containing element, usually a div
 * @param   fftResult         data to plot
 * @param   config configuration of the plot, note not all options are supported by fft plots
 * @param   loglog      true for loglog plot, false for linlog
 * @returns             the plot
 */

function createSimpleFFTPlot(cssSelector, fftResult, config, loglog = true) {
  let fftplot = new FFTPlot(cssSelector, config, fftResult, loglog);
  fftplot.draw();
  return fftplot;
}
/**
 * Create a amplitude plot of multiple FFT data.
 *
 * @param   cssSelector selection of the containing element, usually a div
 * @param   fftResults         data to plot
 * @param   config configuration of the plot, note not all options are supported by fft plots
 * @param   loglog      true for loglog plot, false for linlog
 * @returns             the plot
 */

function createOverlayFFTPlot(cssSelector, fftResults, config = new SeismographConfig(), loglog = true) {
  let fftplot = new FFTPlot(cssSelector, config, fftResults, loglog);
  fftplot.draw();
  return fftplot;
}
/**
 * A amplitude plot of fft data.
 *
 * @param cssSelector selector or d3 selection
 * @param seismographConfig config of the plot, not all values are used
 * @param fftResult fft data to plot
 * @param loglog log or linear frequency
 */

class FFTPlot {
  constructor(cssSelector, seismographConfig, fftResult, loglog = true) {
    this.svgParent = cssSelector;
    this.seismographConfig = seismographConfig;
    this.fftResults = Array.isArray(fftResult) ? fftResult : [fftResult];
    this.xScale = null;
    this.yScale = null;
    this.svg = null;
    this.loglog = loglog;

    if (typeof cssSelector === 'string') {
      this.svgParent = select(cssSelector);
    } else {
      this.svgParent = cssSelector;
    }
  }

  draw() {
    const that = this;
    let ampPhaseList = [];
    let ampSliceMap = new Map();
    let maxFFTAmpLen = 0;
    let extentFFTData = null;
    let freqMinMax = [];

    for (const fftA of this.fftResults) {
      if (this.loglog) {
        freqMinMax.push(fftA.fundamentalFrequency); // min freq
      } else {
        freqMinMax.push(0);
      }

      freqMinMax.push(fftA.sampleRate / 2); // max freq

      let ap;

      if (fftA instanceof FFTResult) {
        ap = fftA;
      } else {
        throw new Error("fftResults must be array of FFTResult");
      }

      ampPhaseList.push(ap);

      if (maxFFTAmpLen < ap.amp.length) {
        maxFFTAmpLen = ap.amp.length;
      }

      let ampSlice;

      if (this.loglog) {
        // don't plot zero freq amp
        ampSlice = ap.amp.slice(1);
      } else {
        ampSlice = ap.amp;
      }

      let currExtent = extent(ampSlice);

      if (currExtent[0] === 0) {
        // replace zero with smallest non-zero / 10 for loglog plot
        currExtent[0] = 0.1 * ampSlice.reduce((acc, curr) => {
          if (curr > 0 && curr < acc) {
            return curr;
          } else {
            return acc;
          }
        }, 1e-9);
      }

      ampSliceMap.set(ap, ampSlice);

      if (extentFFTData) {
        extentFFTData = extent([extentFFTData[0], extentFFTData[1], currExtent[0], currExtent[1]], function (d) {
          return d;
        });
      } else {
        extentFFTData = currExtent;
      }
    }

    let svg = this.svgParent.append("svg");
    this.svg = svg;
    svg.classed("fftplot", true);
    let rect = svg.node().getBoundingClientRect();
    let width = +rect.width - this.seismographConfig.margin.left - this.seismographConfig.margin.right;
    let height = +rect.height - this.seismographConfig.margin.top - this.seismographConfig.margin.bottom;
    let g = svg.append("g").attr("transform", "translate(" + this.seismographConfig.margin.left + "," + this.seismographConfig.margin.top + ")");

    if (this.loglog) {
      this.xScale = scaleLog().rangeRound([0, width]);
    } else {
      this.xScale = scaleLinear().rangeRound([0, width]);
    }

    this.xScale.domain(extent(freqMinMax));
    this.yScale = scaleLog().rangeRound([height, 0]);
    this.yScale.domain(extentFFTData);

    if (this.yScale.domain()[0] === this.yScale.domain()[1]) {
      this.yScale.domain([this.yScale.domain()[0] / 2, this.yScale.domain()[1] * 2]);
    }

    const xAxis = axisBottom(this.xScale);
    g.append("g").attr("transform", "translate(0," + height + ")").call(xAxis);
    g.append("g").attr("transform", "translate(0, ".concat(height + this.seismographConfig.margin.bottom, " )")).append("text").attr("fill", "#000").attr("y", 0).attr("x", width / 2).attr("dy", "0.71em").attr("text-anchor", "end").text("Hertz");
    const yAxis = axisLeft(this.yScale);
    g.append("g").call(yAxis);
    svg.append("g").attr("transform", "translate(0, ".concat(this.seismographConfig.margin.top + height / 2, " )")).append("text").attr("fill", "#000").attr("dy", "0.71em").attr("transform", "rotate(-90)").attr("text-anchor", "end").text("Amp");
    let pathg = g.append("g").classed("allfftpaths", true);

    for (const ap of ampPhaseList) {
      let ampSlice = ampSliceMap.get(ap);
      let minFreq = ap.fundamentalFrequency;
      let line$1 = line();

      if (this.loglog) {
        line$1.x(function (d, i) {
          return that.xScale((i + 1) * minFreq);
        }); // minus one as slice off zero freq above
      } else {
        line$1.x(function (d, i) {
          return that.xScale(i * minFreq);
        });
      }

      line$1.y(function (d) {
        if (d !== 0.0 && !isNaN(d)) {
          return that.yScale(d);
        } else {
          return that.yScale.range()[0];
        }
      });
      pathg.append("g").append("path").classed("fftpath", true).datum(ampSlice).attr("d", line$1);
    }

    return this;
  }

}
/**
 * Defualt CSS for styling fft plots.
 */

const fftplot_css = "\n\n\npath.fftpath {\n  stroke: skyblue;\n  fill: none;\n  stroke-width: 1px;\n}\n\nsvg.fftplot {\n  height: 100%;\n  width: 100%;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+1) path.fftpath {\n  stroke: skyblue;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+2) path.fftpath {\n  stroke: olivedrab;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+3) path.fftpath {\n  stroke: goldenrod;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+4) path.fftpath {\n  stroke: firebrick;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+5) path.fftpath {\n  stroke: darkcyan;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+6) path.fftpath {\n  stroke: orange;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+7) path.fftpath {\n  stroke: darkmagenta;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+8) path.fftpath {\n  stroke: mediumvioletred;\n}\n\nsvg.fftplot g.allfftpaths g:nth-child(9n+9) path.fftpath {\n  stroke: sienna;\n}\n\n/* same colors for titles */\n\nsvg.fftplot g.title tspan:nth-child(9n+1)  {\n  fill: skyblue;\n}\n\nsvg.fftplot g.title text tspan:nth-child(9n+2)  {\n  stroke: olivedrab;\n}\n\nsvg.fftplot g.title text tspan:nth-child(9n+3)  {\n  stroke: goldenrod;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+4)  {\n  stroke: firebrick;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+5)  {\n  stroke: darkcyan;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+6)  {\n  stroke: orange;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+7)  {\n  stroke: darkmagenta;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+8)  {\n  stroke: mediumvioletred;\n}\n\nsvg.fftplot g.title tspan:nth-child(9n+9)  {\n  stroke: sienna;\n}\n\n\n/* links in svg */\nsvg.fftplot text a {\n  fill: #0000EE;\n  text-decoration: underline;\n}\n\n";

if (document) {
  insertCSS(fftplot_css);
}

export { FFTPlot, createOverlayFFTPlot, createSimpleFFTPlot, fftplot_css };
//# sourceMappingURL=fftplot.js.map
