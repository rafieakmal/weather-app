{"version":3,"file":"seedcodec.js","sources":["../../src/seedcodec.js"],"sourcesContent":["// @flow\n\n/*\n * Philip Crotwell\n * University of South Carolina, 2019\n * http://www.seis.sc.edu\n */\n\n// converted from Steim2.java in seedCodec\n// http://github.com/crotwell/seedcodec/\n\n\n\n// constants for compression types\n\n/** ascii */\nexport const ASCII = 0;\n\n/** 16 bit integer, or java short */\nexport const SHORT = 1;\n\n/** 24 bit integer */\nexport const INT24 = 2;\n\n/** 32 bit integer, or java int */\nexport const INTEGER = 3;\n\n/** ieee float */\nexport const FLOAT = 4;\n\n/** ieee double*/\nexport const DOUBLE = 5;\n\n/** Steim1 compression */\nexport const STEIM1= 10;\n\n/** Steim2 compression */\nexport const STEIM2 = 11;\n\n/** CDSN 16 bit gain ranged */\nexport const CDSN = 16;\n\n/** (A)SRO */\nexport const SRO = 30;\n\n/** DWWSSN 16 bit */\nexport const DWWSSN = 32;\n\nexport class CodecException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = 'CodecException';\n  }\n}\n\nexport class UnsupportedCompressionType extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = 'UnsupportedCompressionType';\n  }\n}\n\nexport function isFloatCompression(compressionType: number): boolean {\n  if (compressionType === FLOAT || compressionType === DOUBLE) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * A holder for compressed data independent of the file format.\n */\nexport class EncodedDataSegment {\n  compressionType: number;\n  dataView: DataView;\n  numSamples: number;\n  littleEndian: boolean;\n  constructor(compressionType: number, dataView: DataView, numSamples: number, littleEndian: boolean) {\n    this.compressionType = compressionType;\n    this.dataView = dataView;\n    this.numSamples = numSamples;\n    this.littleEndian = littleEndian;\n  }\n  isFloatCompression(): boolean {\n    return isFloatCompression(this.compressionType);\n  }\n  decode(): Int32Array | Float32Array | Float64Array {\n    return decompress(this.compressionType,\n      this.dataView,\n      this.numSamples,\n      this.littleEndian);\n  }\n}\n\n/**\n *  Decompress the samples from the provided DataView and\n *  return an array of the decompressed values.\n *  Only 16 bit short, 32 bit int, 32 bit float and 64 bit double\n *  along with Steim1 and Steim2 are supported.\n *\n *  @param compressionType compression format as defined in SEED blockette 1000\n *  @param dataView input DataView to be decoded\n *  @param numSamples the number of samples that can be decoded from array\n *  <b>b</b>\n *  @param littleEndian if true, dataView is little-endian (intel byte order) <b>b</b>.\n *  @returns array of length <b>numSamples</b>.\n *  @throws CodecException fail to decompress.\n *  @throws UnsupportedCompressionType unsupported compression type\n */\nexport function decompress(compressionType: number, dataView: DataView, numSamples: number, littleEndian: boolean): Int32Array | Float32Array | Float64Array {\n  // in case of record with no data points, ex detection blockette, which often have compression type\n  // set to 0, which messes up the decompresser even though it doesn't matter since there is no data.\n  if (numSamples === 0) {\n    return new Int32Array(0);\n  }\n\n  let out;\n  let offset = 0;\n  let i;\n  switch(compressionType){\n    case SHORT:\n    case DWWSSN:\n      // 16 bit values\n      if(dataView.byteLength < 2 * numSamples) {\n        throw new CodecException(\"Not enough bytes for \"\n                        + numSamples + \" 16 bit data points, only \"\n                        + dataView.byteLength + \" bytes.\");\n      }\n      out = new Int32Array(numSamples);\n      for(i = 0; i < numSamples; i++) {\n        out[i] = dataView.getInt16(offset, littleEndian);\n        offset += 2;\n      }\n      break;\n    case INTEGER:\n      // 32 bit integers\n      if(dataView.byteLength < 4 * numSamples) {\n          throw new CodecException(\"Not enough bytes for \"\n                + numSamples + \" 32 bit data points, only \"\n                + dataView.byteLength + \" bytes.\");\n      }\n      out = new Int32Array(numSamples);\n      for(i = 0; i < numSamples; i++) {\n        out[i] = dataView.getInt32(offset, littleEndian);\n        offset += 4;\n      }\n      break;\n    case FLOAT:\n      // 32 bit floats\n      if(dataView.byteLength < 4 * numSamples) {\n        throw new CodecException(\"Not enough bytes for \"\n              + numSamples + \" 32 bit data points, only \"\n              + dataView.byteLength + \" bytes.\");\n      }\n      out = new Float32Array(numSamples);\n      for(i = 0; i < numSamples; i++) {\n        out[i] = dataView.getFloat32(offset, littleEndian);\n        offset += 4;\n      }\n      break;\n    case DOUBLE:\n      // 64 bit doubles\n      if(dataView.byteLength < 8 * numSamples) {\n          throw new CodecException(\"Not enough bytes for \"\n                + numSamples + \" 64 bit data points, only \"\n                + dataView.byteLength + \" bytes.\");\n      }\n      out = new Float64Array(numSamples);\n      for(i = 0; i < numSamples; i++) {\n        out[i] = dataView.getFloat64(offset, littleEndian);\n        offset += 8;\n      }\n      break;\n    case STEIM1:\n      // steim 1\n      out = decodeSteim1(dataView, numSamples, littleEndian, 0);\n      break;\n    case STEIM2:\n      // steim 2\n      out = decodeSteim2(dataView, numSamples, littleEndian, 0);\n      break;\n    default:\n      // unknown format????\n      throw new UnsupportedCompressionType(\"Type \" + compressionType\n                    + \" is not supported at this time.\");\n  } // end of switch ()\n  return out;\n}\n\n/**\n *  Decode the indicated number of samples from the provided byte array and\n *  return an integer array of the decompressed values.  Being differencing\n *  compression, there may be an offset carried over from a previous data\n *  record.  This offset value can be placed in <b>bias</b>, otherwise leave\n *  the value as 0.\n *\n *  @param dataView input DataView to be decoded\n *  @param numSamples the number of samples that can be decoded from array\n *  <b>b</b>\n *  @param littleEndian if true, dataView is little-endian (intel byte order) <b>b</b>.\n *  @param bias the first difference value will be computed from this value.\n *  If set to 0, the method will attempt to use the X(0) constant instead.\n *  @returns int array of length <b>numSamples</b>.\n *  @throws CodecException - encoded data length is not multiple of 64\n *  bytes.\n */\nexport function decodeSteim1(dataView: DataView, numSamples: number, littleEndian: boolean, bias: number): Int32Array {\n  // Decode Steim1 compression format from the provided byte array, which contains numSamples number\n  // of samples.  swapBytes is set to true if the value words are to be byte swapped.  bias represents\n  // a previous value which acts as a starting constant for continuing differences integration.  At the\n  // very start, bias is set to 0.\n  if (dataView.byteLength % 64 !== 0) {\n    throw new CodecException(\"encoded data length is not multiple of 64 bytes (\" + dataView.byteLength + \")\");\n  }\n  let buf = new ArrayBuffer(4 * numSamples);\n  let samples = new Int32Array(buf);\n  let tempSamples;\n  let numFrames = dataView.byteLength / 64;\n  let current = 0;\n  let start=0;\n  let firstData=0;\n  let lastValue = 0;\n  let i, j;\n\n  for (i=0; i< numFrames; i++ ) {\n    tempSamples = extractSteim1Samples(dataView, i*64, littleEndian);   // returns only differences except for frame 0\n    firstData = 0; // d(0) is byte 0 by default\n    if (i===0) {   // special case for first frame\n      lastValue = bias; // assign our X(-1)\n      // x0 and xn are in 1 and 2 spots\n      start = tempSamples[1];  // X(0) is byte 1 for frame 0\n      //  end = tempSamples[2];    // X(n) is byte 2 for frame 0\n      firstData = 3; // d(0) is byte 3 for frame 0\n      // if bias was zero, then we want the first sample to be X(0) constant\n      if (bias === 0) lastValue = start - tempSamples[3];  // X(-1) = X(0) - d(0)\n    }\n    for (j = firstData; j < tempSamples.length && current < numSamples; j++) {\n      samples[current] = lastValue + tempSamples[j];  // X(n) = X(n-1) + d(n)\n      lastValue = samples[current];\n      current++;\n    }\n  }  // end for each frame...\n  if (current !== numSamples) {\n    throw new CodecException(\"Number of samples decompressed doesn't match number in header: \"+current+\" !== \"+numSamples);\n  }\n  // ignore last sample check???\n  //if (end !== samples[numSamples-1]) {\n  //    throw new SteimException(\"Last sample decompressed doesn't match value x(n) value in Steim1 record: \"+samples[numSamples-1]+\" !== \"+end);\n  //}\n  return samples;\n}\n\n/**\n * Extracts differences from the next 64 byte frame of the given compressed\n * byte array (starting at offset) and returns those differences in an int\n * array.\n * An offset of 0 means that we are at the first frame, so include the header\n * bytes in the returned int array...else, do not include the header bytes\n * in the returned array.\n *\n * @param dataView byte array of compressed data differences\n * @param offset index to begin reading compressed bytes for decoding\n * @param littleEndian reverse the endian-ness of the compressed bytes being read\n * @returns integer array of difference (and constant) values\n */\nfunction extractSteim1Samples(dataView: DataView, offset: number,  littleEndian: boolean): Array<number> {\n  /* get nibbles */\n  let nibbles = dataView.getInt32(offset, littleEndian);\n  let currNibble = 0;\n  let temp = [];  // 4 samples * 16 longwords, can't be more than 64\n  let currNum = 0;\n  let i, n;\n  for (i=0; i<16; i++) {   // i is the word number of the frame starting at 0\n    //currNibble = (nibbles >>> (30 - i*2 ) ) & 0x03; // count from top to bottom each nibble in W(0)\n    currNibble = (nibbles >> (30 - i*2) ) & 0x03; // count from top to bottom each nibble in W(0)\n    //System.err.print(\"c(\" + i + \")\" + currNibble + \",\");  // DEBUG\n    // Rule appears to be:\n    // only check for byte-swap on actual value-atoms, so a 32-bit word in of itself\n    // is not swapped, but two 16-bit short *values* are or a single\n    // 32-bit int *value* is, if the flag is set to TRUE.  8-bit values\n    // are naturally not swapped.\n    // It would seem that the W(0) word is swap-checked, though, which is confusing...\n    // maybe it has to do with the reference to high-order bits for c(0)\n    switch (currNibble) {\n      case 0:\n        //System.out.println(\"0 means header info\");\n        // only include header info if offset is 0\n        if (offset === 0) {\n          temp[currNum++] = dataView.getInt32(offset+(i*4), littleEndian);\n        }\n        break;\n      case 1:\n        //System.out.println(\"1 means 4 one byte differences\");\n        for ( n=0; n<4; n++) {\n          temp[currNum] = dataView.getInt8(offset+(i*4)+n);\n          currNum++;\n        }\n        break;\n      case 2:\n        //System.out.println(\"2 means 2 two byte differences\");\n        for ( n=0; n<4; n+=2) {\n          temp[currNum] = dataView.getInt16(offset+(i*4)+n, littleEndian);\n          currNum++;\n        }\n        break;\n      case 3:\n        //System.out.println(\"3 means 1 four byte difference\");\n        temp[currNum++] =dataView.getInt32(offset+(i*4), littleEndian);\n        break;\n      default:\n        throw new CodecException(\"unreachable case: \"+currNibble);\n        //System.out.println(\"default\");\n    }\n  }\n  return temp;\n}\n\n/**\n *  Decode the indicated number of samples from the provided byte array and\n *  return an integer array of the decompressed values.  Being differencing\n *  compression, there may be an offset carried over from a previous data\n *  record.  This offset value can be placed in <b>bias</b>, otherwise leave\n *  the value as 0.\n *\n *  @param dataView input byte array to be decoded\n *  @param numSamples the number of samples that can be decoded from array\n *  @param swapBytes if true, swap reverse the endian-ness of the elements of\n *  dataview\n *  @param bias the first difference value will be computed from this value.\n *  If set to 0, the method will attempt to use the X(0) constant instead.\n *  @returns int array of length <b>numSamples</b>.\n *  @throws SteimException - encoded data length is not multiple of 64\n *  bytes.\n */\nexport function decodeSteim2(dataView: DataView, numSamples: number, swapBytes: boolean, bias: number): Int32Array {\n  if (dataView.byteLength % 64 !== 0) {\n    throw new CodecException(\"encoded data length is not multiple of 64 bytes (\" + dataView.byteLength + \")\");\n  }\n  let buf = new ArrayBuffer(4 * numSamples);\n  let samples = new Int32Array(buf);\n  let tempSamples;\n  let numFrames = dataView.byteLength / 64;\n  let current = 0;\n  let start=0;\n  let firstData=0;\n  let lastValue = 0;\n\n  //System.err.println(\"DEBUG: number of samples: \" + numSamples + \", number of frames: \" + numFrames + \", byte array size: \" + b.length);\n  for (let i=0; i< numFrames ; i++ ) {\n    tempSamples = extractSteim2Samples(dataView, i*64, swapBytes);   // returns only differences except for frame 0\n    firstData = 0; // d(0) is byte 0 by default\n    if (i===0) {   // special case for first frame\n      lastValue = bias; // assign our X(-1)\n      // x0 and xn are in 1 and 2 spots\n      start = tempSamples[1];  // X(0) is byte 1 for frame 0\n      // end = tempSamples[2];    // X(n) is byte 2 for frame 0\n      firstData = 3; // d(0) is byte 3 for frame 0\n      // if bias was zero, then we want the first sample to be X(0) constant\n      if (bias === 0) lastValue = start - tempSamples[3];  // X(-1) = X(0) - d(0)\n    }\n    //System.err.print(\"DEBUG: \");\n    for (let j = firstData; j < tempSamples.length && current < numSamples; j++) {\n      samples[current] = lastValue + tempSamples[j];  // X(n) = X(n-1) + d(n)\n      lastValue = samples[current];\n      current++;\n    }\n    //System.err.println(\"DEBUG: end of frame \" + i);\n  }  // end for each frame...\n  if (current !== numSamples) {\n    throw new CodecException(\"Number of samples decompressed doesn't match number in header: \"+current+\" !== \"+numSamples);\n  }\n  // ignore last sample check???\n  //if (end !== samples[numSamples-1]) {\n  //    throw new SteimException(\"Last sample decompressed doesn't match value x(n) value in Steim2 record: \"+samples[numSamples-1]+\" !== \"+end);\n  //}\n  return samples;\n}\n\n\n/**\n * Extracts differences from the next 64 byte frame of the given compressed\n * byte array (starting at offset) and returns those differences in an int\n * array.\n * An offset of 0 means that we are at the first frame, so include the header\n * bytes in the returned int array...else, do not include the header bytes\n * in the returned array.\n *\n * @param dataView byte array of compressed data differences\n * @param offset index to begin reading compressed bytes for decoding\n * @param swapBytes reverse the endian-ness of the compressed bytes being read\n * @returns integer array of difference (and constant) values\n */\nfunction extractSteim2Samples(dataView: DataView, offset: number, swapBytes: boolean): Int32Array {\n  /* get nibbles */\n  let nibbles = dataView.getUint32(offset, swapBytes);\n  let currNibble = 0;\n  let dnib = 0;\n  let temp = new Int32Array(106); //max 106 = 7 samples * 15 long words + 1 nibble int\n  let tempInt;\n  let currNum = 0;\n  let diffCount = 0;  // number of differences\n  let bitSize = 0;    // bit size\n  let headerSize = 0; // number of header/unused bits at top\n  for (let i=0; i<16; i++) {\n    currNibble = (nibbles >> (30 - i*2 ) ) & 0x03;\n    switch (currNibble) {\n      case 0:\n        // \"0 means header info\"\n        // only include header info if offset is 0\n        if (offset === 0) {\n          temp[currNum++] = dataView.getInt32(offset+(i*4), swapBytes);\n        }\n        break;\n      case 1:\n        //  \"1 means 4 one byte differences \" +currNum+\" \"+dataView.getInt8(offset+(i*4))+\" \"+dataView.getInt8(offset+(i*4)+1)+\" \"+dataView.getInt8(offset+(i*4)+2)+\" \"+dataView.getInt8(offset+(i*4)+3)\n        temp[currNum++] = dataView.getInt8(offset+(i*4));\n        temp[currNum++] = dataView.getInt8(offset+(i*4)+1);\n        temp[currNum++] = dataView.getInt8(offset+(i*4)+2);\n        temp[currNum++] = dataView.getInt8(offset+(i*4)+3);\n        break;\n      case 2:\n        tempInt = dataView.getUint32(offset+(i*4), swapBytes);\n        dnib = (tempInt >> 30) & 0x03;\n        switch (dnib) {\n          case 1:\n            // \"2,1 means 1 thirty bit difference\"\n            temp[currNum++] = (tempInt << 2) >> 2;\n            break;\n          case 2:\n            // \"2,2 means 2 fifteen bit differences\"\n            temp[currNum++] = (tempInt << 2) >> 17;  // d0\n            temp[currNum++] = (tempInt << 17) >> 17; // d1\n            break;\n          case 3:\n            //  \"2,3 means 3 ten bit differences\"\n            temp[currNum++] = (tempInt << 2) >> 22;  // d0\n            temp[currNum++] = (tempInt << 12) >> 22; // d1\n            temp[currNum++] = (tempInt << 22) >> 22; // d2\n            break;\n          default:\n            throw new CodecException(`Unknown case currNibble=${currNibble} dnib=${dnib}`);\n        }\n        break;\n      case 3:\n        tempInt = dataView.getUint32(offset+(i*4), swapBytes);\n        dnib = (tempInt >> 30) & 0x03;\n        // for case 3, we are going to use a for-loop formulation that\n        // accomplishes the same thing as case 2, just less verbose.\n        diffCount = 0;  // number of differences\n        bitSize = 0;    // bit size\n        headerSize = 0; // number of header/unused bits at top\n        switch (dnib) {\n          case 0:\n            //System.out.println(\"3,0 means 5 six bit differences\");\n            headerSize = 2;\n            diffCount = 5;\n            bitSize = 6;\n            break;\n          case 1:\n            //System.out.println(\"3,1 means 6 five bit differences\");\n            headerSize = 2;\n            diffCount = 6;\n            bitSize = 5;\n            break;\n          case 2:\n            //System.out.println(\"3,2 means 7 four bit differences, with 2 unused bits\");\n            headerSize = 4;\n            diffCount = 7;\n            bitSize = 4;\n            break;\n          default:\n            throw new CodecException(`Unknown case currNibble=${currNibble} dnib=${dnib}`);\n        }\n        if (diffCount > 0) {\n          for (let d=0; d<diffCount; d++) {  // for-loop formulation\n            temp[currNum++] = ( tempInt << (headerSize+(d*bitSize)) ) >> (((diffCount-1)*bitSize) + headerSize);\n          }\n        }\n        break;\n      default:\n        throw new CodecException(`Unknown case currNibble=${currNibble}`);\n    }\n  }\n  return temp.slice(0, currNum);\n}\n"],"names":["ASCII","SHORT","INT24","INTEGER","FLOAT","DOUBLE","STEIM1","STEIM2","CDSN","SRO","DWWSSN","CodecException","Error","constructor","message","name","UnsupportedCompressionType","isFloatCompression","compressionType","EncodedDataSegment","dataView","numSamples","littleEndian","decode","decompress","Int32Array","out","offset","i","byteLength","getInt16","getInt32","Float32Array","getFloat32","Float64Array","getFloat64","decodeSteim1","decodeSteim2","bias","buf","ArrayBuffer","samples","tempSamples","numFrames","current","start","firstData","lastValue","j","extractSteim1Samples","length","nibbles","currNibble","temp","currNum","n","getInt8","swapBytes","extractSteim2Samples","getUint32","dnib","tempInt","diffCount","bitSize","headerSize","d","slice"],"mappings":"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"}