export { default as moment } from 'moment';
import { selectAll, select } from 'd3';
import * as d3 from 'd3';
export { d3 };
import RSVP__default from 'rsvp';
export { default as RSVP } from 'rsvp';
import { isDef, StartEndDuration } from './util.js';
import { SeismogramDisplayData } from './seismogram.js';
import { seismogramPerChannel, parseDataRecords } from './miniseed.js';
import * as miniseed from './miniseed.js';
export { miniseed };
import { DataSelectQuery } from './fdsndataselect.js';
import * as fdsndataselect from './fdsndataselect.js';
export { fdsndataselect as dataselect };
import { SeismographConfig } from './seismographconfig.js';
import { Seismograph } from './seismograph.js';

/*
 * Philip Crotwell
 * University of South Carolina, 2019
 * http://www.seis.sc.edu
 */

/**
 * Returns an array of Promises, one per selected element. This assumes each
 * element has some combination of start, end, duration, net, sta, loc, and chan
 * attributes sufficient to form the data query. Or an href to a miniseed file.
 *
 * @param selector css selector
 * @returns promise to array of plot data types
 */
function createPlotsBySelectorPromise(selector) {
  let out = [];
  selectAll(selector).each(function () {
    let svgParent = select(this);
    let url;
    let startAttr = svgParent.attr("start") ? svgParent.attr("start") : null;
    let endAttr = svgParent.attr("end") ? svgParent.attr("end") : null;
    let duration = svgParent.attr("duration");
    let timeWindow = null;

    if (isDef(startAttr) || isDef(endAttr) || isDef(duration)) {
      timeWindow = new StartEndDuration(startAttr, endAttr, duration);
    } else {
      throw new Error("Need at least one of start, end, duration.");
    }

    if (svgParent.attr("href")) {
      // url to miniseed file
      url = svgParent.attr("href");
      out.push(fetch(url).then(response => {
        if (response.ok) {
          return response.arrayBuffer();
        } else {
          throw new Error("Fetching over network was not ok: " + response.status + " " + response.statusText);
        }
      }).then(ab => {
        let seismograms = seismogramPerChannel(parseDataRecords(ab));
        let sddList = seismograms.map(s => {
          let sdd = SeismogramDisplayData.fromSeismogram(s);

          if (timeWindow) {
            sdd.timeWindow = timeWindow;
          }

          return sdd;
        });
        return {
          "sddList": sddList,
          "svgParent": svgParent
        };
      }));
    } else {
      let net = svgParent.attr("net");
      let sta = svgParent.attr("sta");
      let loc = svgParent.attr("loc");
      let chan = svgParent.attr("chan");

      if (!(net && sta && loc && chan)) {
        throw new Error("Must set all of net, sta, loc, chan, but got ".concat(net, ", ").concat(sta, ", ").concat(loc, ", ").concat(chan));
      }

      let host = svgParent.attr("host");

      if (!host) {
        host = "service.iris.edu";
      } // $FlowFixMe


      let request = new DataSelectQuery().timeWindow(timeWindow);

      if (host) {
        request.host(host);
      }

      if (net) {
        request.networkCode(net);
      }

      if (sta) {
        request.stationCode(sta);
      }

      if (loc) {
        request.locationCode(loc);
      }

      if (chan) {
        request.channelCode(chan);
      }

      out.push(request.querySeismograms().then(seismograms => {
        let sddList = seismograms.map(s => {
          let sdd = SeismogramDisplayData.fromSeismogram(s);

          if (isDef(timeWindow)) {
            sdd.timeWindow = timeWindow;
          }

          return sdd;
        });
        return {
          "sddList": sddList,
          "svgParent": svgParent
        };
      }));
    }
  });
  return RSVP__default.all(out);
}
function createPlotsBySelector(selector) {
  return createPlotsBySelectorPromise(selector).then(function (resultArray) {
    resultArray.forEach(function (result) {
      result.svgParent.append("p").text("Build plot");

      if (result.sddList.length > 0) {
        let svgDiv = result.svgParent.append("div");
        svgDiv.classed("svg-container-wide", true);
        let seisConfig = new SeismographConfig();
        let seismogram = new Seismograph(svgDiv, seisConfig, result.sddList);
        seismogram.draw();
      } else {
        result.svgParent.append("p").text("No Data");
      }
    });
    return resultArray;
  });
}
function alphabeticalSort(traceA, traceB) {
  if (traceA.codes() < traceB.codes()) {
    return -1;
  } else {
    return 1;
  }
}

export { alphabeticalSort, createPlotsBySelector, createPlotsBySelectorPromise };
//# sourceMappingURL=plotutil.js.map
