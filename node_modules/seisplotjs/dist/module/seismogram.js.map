{"version":3,"file":"seismogram.js","sources":["../../src/seismogram.js"],"sourcesContent":["// @flow\n\n/*\n * Philip Crotwell\n * University of South Carolina, 2019\n * http://www.seis.sc.edu\n */\n\nimport moment from 'moment';\nimport { checkStringOrDate, meanOfSlice, isDef, stringify } from './util';\nimport * as seedcodec from './seedcodec';\n\nimport {Channel, InstrumentSensitivity} from './stationxml.js';\nimport {Quake} from './quakeml.js';\nimport {StartEndDuration } from './util';\n\nexport const COUNT_UNIT = 'count';\n\nexport type HighLowType = {\n      xScaleDomain: Array<number>;\n      xScaleRange: Array<number>;\n      secondsPerPixel: number;\n      samplesPerPixel: number;\n      highlowArray: Array<number>;\n};\n\nexport type MarkerType = {\n  name: string,\n  time: moment,\n  type: string,\n  description: string\n};\n\n/**\n * A contiguous segment of a Seismogram.\n *\n * @param  yArray array of Y sample values, ie the timeseries\n * @param  sampleRate sample rate of the seismogram, hertz\n * @param  startTime start time of seismogrm as a momentjs moment in utc or a string that can be parsed\n */\nexport class SeismogramSegment {\n  /** Array of y values */\n  _y: null | Int32Array | Float32Array | Float64Array;\n  _compressed: null | Array<seedcodec.EncodedDataSegment>;\n  /**\n   * the sample rate in hertz\n   *\n   * @private\n   */\n  _sampleRate: number;\n  /** @private */\n  _startTime: moment;\n  _endTime_cache: null | moment;\n  _endTime_cache_numPoints: number;\n  networkCode: string;\n  stationCode: string;\n  locationCode: string;\n  channelCode: string;\n  yUnit: string;\n  _highlow: HighLowType;\n  constructor(yArray: Array<seedcodec.EncodedDataSegment> | Int32Array | Float32Array | Float64Array,\n              sampleRate: number,\n              startTime: moment) {\n    if (yArray instanceof Int32Array || yArray instanceof Float32Array || yArray instanceof Float64Array) {\n      this._y = yArray;\n      this._compressed = null;\n    } else if (Array.isArray(yArray) && yArray.every( ee => ee instanceof seedcodec.EncodedDataSegment)) {\n        this._compressed = yArray;\n        this._y = null;\n    } else if (Array.isArray(yArray) && yArray.every( ee => typeof ee === 'number')) {\n      // numbers in js are 64bit, so...\n      this._y = Float64Array.from(((yArray: any): Array<number>));\n      this._compressed = null;\n    }\n    this._sampleRate = sampleRate;\n    this._startTime = checkStringOrDate(startTime);\n    this.yUnit = COUNT_UNIT;\n    // to avoid recalc of end time as it is kind of expensive\n    this._endTime_cache = null;\n    this._endTime_cache_numPoints = 0;\n  }\n  /**\n   * Y data of the seismogram. Decompresses data if needed.\n   *\n   * @returns y data as typed array\n   */\n  get y(): Int32Array | Float32Array | Float64Array {\n    let out;\n    if (this._y) {\n      out = this._y;\n    } else {\n      if ( ! this.isEncoded()) {\n        throw new Error(\"Seismogram not y as TypedArray or encoded.\");\n      }\n      // data is still compressed\n      let outLen = this.numPoints;\n\n      if ( this._compressed === null) {\n        // for flow\n        throw new Error(\"Seismogram not y as TypedArray or encoded.\");\n      }\n      if (this._compressed[0].compressionType === seedcodec.DOUBLE) {\n        out = new Float64Array(outLen);\n      } else if (this._compressed[0].compressionType === seedcodec.FLOAT) {\n        out = new Float32Array(outLen);\n      } else {\n        out = new Int32Array(outLen);\n      }\n      let currIdx = 0;\n      for (let c of this._compressed) {\n        const cData = c.decode();\n        for (let i=0; i<c.numSamples; i++) {\n          out[currIdx+i] = cData[i];\n        }\n        currIdx += c.numSamples;\n      }\n      this._y = out;\n      this._compressed = null;\n    }\n    return out;\n  }\n  set y(value: Int32Array | Float32Array | Float64Array) {\n    this._y = value;\n    this._invalidate_endTime_cache();\n  }\n  get startTime(): moment {\n    return this._startTime;\n  }\n  set startTime(value: moment | string) {\n    this._startTime = checkStringOrDate(value);\n    this._invalidate_endTime_cache();\n  }\n  get endTime(): moment {\n    if ( ! this._endTime_cache || this._endTime_cache_numPoints !== this.numPoints) {\n      // array length modified, recalc cached end time\n      this._endTime_cache_numPoints = this.numPoints;\n      this._endTime_cache = this.timeOfSample(this._endTime_cache_numPoints-1);\n    }\n    return this._endTime_cache;\n  }\n  get timeWindow(): StartEndDuration {\n    return new StartEndDuration(this.startTime, this.endTime);\n  }\n  get sampleRate() {\n    return this._sampleRate;\n  }\n  set sampleRate(value: number) {\n    this._sampleRate = value;\n    this._invalidate_endTime_cache();\n  }\n  get numPoints(): number {\n    let out = 0;\n    if (this._y) {\n      out = this._y.length;\n    } else if (this._compressed) {\n      for (let c of this._compressed) {\n        out += c.numSamples;\n      }\n    }\n    return out;\n  }\n  get netCode(): string {\n    return this.networkCode;\n  }\n  get staCode(): string {\n    return this.stationCode;\n  }\n  get locId(): string {\n    return this.locationCode;\n  }\n  get locCode(): string {\n    return this.locationCode;\n  }\n  get chanCode(): string {\n    return this.channelCode;\n  }\n  /**\n   * Checks if the data is encoded\n   *\n   * @returns true if encoded, false otherwise\n   */\n  isEncoded(): boolean {\n    if (this._y && this._y.length > 0) {\n      return false;\n    } else if (this._compressed && this._compressed.length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Gets encoded data, if it is.\n   *\n   * @returns array of encoded data segments\n   * @throws Error if data is not encoded\n   */\n  getEncoded(): Array<seedcodec.EncodedDataSegment> {\n    if (this.isEncoded()) {\n      return ((this._compressed: any): Array<seedcodec.EncodedDataSegment>);\n    } else {\n      throw new Error(\"Data is not encoded.\");\n    }\n  }\n  yAtIndex(i: number): number {\n    return this.y[i];\n  }\n  /**\n   * Finds the min and max values of a SeismogramSegment, with an optional\n   * accumulator for use with gappy data.\n   *\n   * @param minMaxAccumulator optional initialized accumulator as an array\n   * of two numbers, min and max\n   * @returns min, max as arry of length two\n   */\n  findMinMax(minMaxAccumulator?: Array<number>): Array<number> {\n    let minAmp = Number.MAX_SAFE_INTEGER;\n    let maxAmp = -1 * (minAmp);\n    if ( minMaxAccumulator) {\n      minAmp = minMaxAccumulator[0];\n      maxAmp = minMaxAccumulator[1];\n    }\n    let yData = this.y;\n    for (let n = 0; n < yData.length; n++) {\n      if (minAmp > yData[n]) {\n        minAmp = yData[n];\n      }\n      if (maxAmp < yData[n]) {\n        maxAmp = yData[n];\n      }\n    }\n    return [ minAmp, maxAmp ];\n  }\n  timeOfSample(i: number ): moment {\n    return moment.utc(this.startTime).add(i/this.sampleRate, 'seconds');\n  }\n  indexOfTime(t: moment): number {\n    if (t.isBefore(this.startTime)\n        || t.isAfter(moment.utc(this.endTime).add(1/this.sampleRate, 'seconds'))) {\n        return -1;\n    }\n    return Math.round(t.diff(this.startTime) * this.sampleRate /1000);\n  }\n  hasCodes(): boolean {\n    return isDef(this.networkCode)\n      || isDef(this.stationCode)\n      || isDef(this.locationCode)\n      || isDef(this.channelCode);\n  }\n  /**\n   * return network, station, location and channels codes as one string\n   *\n   * @param sep separator, defaults to '.'\n   * @returns nslc codes separated by sep\n   */\n  codes(sep: string = '.'): string {\n    return (this.networkCode ? this.networkCode : '')\n    +sep+(this.stationCode ? this.stationCode : '')\n    +sep+(this.locationCode ? this.locationCode : '')\n    +sep+(this.channelCode ? this.channelCode : '');\n  }\n  seisId(): string {\n   return (this.codes()+\"_\"+this.startTime.toISOString()+\"_\"+this.endTime.toISOString()).replace(/\\./g,'_').replace(/:/g,'');\n  }\n  clone(): SeismogramSegment {\n    let clonedData = this._y;\n    if (clonedData !== null) {\n      clonedData = clonedData.slice();\n    } else if (this.isEncoded()) {\n      // shallow copy array, assume Encoded is immutable\n      clonedData = Array.from(this.getEncoded());\n    } else {\n      throw new Error(\"no _y and no _compressed\");\n    }\n    return this.cloneWithNewData(clonedData);\n  }\n\n  cloneWithNewData(clonedData: Array<seedcodec.EncodedDataSegment> | Int32Array | Float32Array | Float64Array,\n    clonedStartTime: moment = this._startTime): SeismogramSegment {\n    let out = new SeismogramSegment(clonedData,\n                          this.sampleRate,\n                          moment.utc(clonedStartTime));\n    out.networkCode = this.networkCode;\n    out.stationCode = this.stationCode;\n    out.locationCode = this.locationCode;\n    out.channelCode = this.channelCode;\n    out.yUnit = this.yUnit;\n    return out;\n  }\n  cut(timeWindow: StartEndDuration): SeismogramSegment | null {\n    if (timeWindow.endTime.isBefore(this._startTime) || timeWindow.startTime.isAfter(this.endTime)) {\n      return null;\n    }\n    let sIndex = 0;\n    if (timeWindow.startTime.isAfter(this._startTime)) {\n      let milliDiff = timeWindow.startTime.diff(this._startTime);\n      let offset = milliDiff * this.sampleRate /1000.0;\n      sIndex = Math.floor(offset);\n    }\n    let eIndex = this.y.length;\n    if (timeWindow.endTime.isBefore(this.endTime)) {\n      let milliDiff = moment.utc(this.endTime).diff(timeWindow.endTime);\n      let offset = milliDiff * this.sampleRate /1000.0;\n      eIndex = this.y.length - Math.floor(offset);\n    }\n    let cutY = this.y.slice(sIndex, eIndex);\n\n    let out = this.cloneWithNewData(cutY,\n        moment.utc(this._startTime).add(sIndex / this.sampleRate, 'seconds'));\n\n    return out;\n  }\n  _invalidate_endTime_cache() {\n    this._endTime_cache = null;\n    this._endTime_cache_numPoints = 0;\n  }\n}\n\n /** Represents time window for a single channel that may\n  * contain gaps or overlaps, but is otherwise more or less\n  * continuous, or at least adjacent data from the channel.\n  * Each segment within\n  * the Seismogram will have the same units, channel identifiers\n  * and sample rate, but cover different times.\n  */\nexport class Seismogram {\n  _segmentArray: Array<SeismogramSegment>;\n  _startTime: moment;\n  _endTime: moment;\n  _y: null | Int32Array | Float32Array | Float64Array;\n  constructor(segmentArray: SeismogramSegment | Array<SeismogramSegment>) {\n    this._y = null;\n    if ( Array.isArray(segmentArray) && segmentArray[0] instanceof SeismogramSegment) {\n      this._segmentArray = segmentArray;\n    } else if ( segmentArray instanceof SeismogramSegment) {\n      this._segmentArray = [ segmentArray ];\n    } else {\n      throw new Error(`segmentArray is not Array<SeismogramSegment> or SeismogramSegment: ${stringify(segmentArray)}`);\n    }\n    this.checkAllSimilar();\n    this.findStartEnd();\n  }\n  checkAllSimilar() {\n    if (this._segmentArray.length === 0) {throw new Error(\"Seismogram is empty\");}\n    let f = this._segmentArray[0];\n    this._segmentArray.forEach((s, i) => {\n      if (! s) {\n        throw new Error(`index ${i} is null in trace`);\n      }\n      this.checkSimilar(f, s);\n    });\n  }\n  checkSimilar(f: SeismogramSegment, s: SeismogramSegment) {\n    if (s.networkCode !== f.networkCode) {throw new Error(\"NetworkCode not same: \"+s.networkCode+\" !== \"+f.networkCode);}\n    if (s.stationCode !== f.stationCode) {throw new Error(\"StationCode not same: \"+s.stationCode+\" !== \"+f.stationCode);}\n    if (s.locationCode !== f.locationCode) {throw new Error(\"LocationCode not same: \"+s.locationCode+\" !== \"+f.locationCode);}\n    if (s.channelCode !== f.channelCode) {throw new Error(\"ChannelCode not same: \"+s.channelCode+\" !== \"+f.channelCode);}\n    if (s.yUnit !== f.yUnit) {throw new Error(\"yUnit not same: \"+s.yUnit+\" !== \"+f.yUnit);}\n  }\n  findStartEnd() {\n    let allStart = this._segmentArray.map(seis => {\n      return moment.utc(seis.startTime);\n    });\n    this._startTime = moment.min(allStart);\n    let allEnd = this._segmentArray.map(seis => {\n      return moment.utc(seis.endTime);\n    });\n    this._endTime = moment.max(allEnd);\n  }\n  findMinMax(minMaxAccumulator?: Array<number>): Array<number> {\n    if (this._segmentArray.length === 0) {\n      throw new Error(\"No data\");\n    }\n    for (let s of this._segmentArray) {\n      minMaxAccumulator = s.findMinMax(minMaxAccumulator);\n    }\n    if (minMaxAccumulator){\n      return minMaxAccumulator;\n    } else {\n      // should never happen, for flow\n      throw new Error(\"No data to calc minmax\");\n    }\n  }\n  /**\n   * calculates the mean of a seismogrma.\n   *\n   * @returns       mean value\n   */\n  mean(): number {\n    let meanVal = 0;\n\n    let npts = this.numPoints;\n    for (let s of this.segments) {\n      meanVal += meanOfSlice(s.y, s.y.length)*s.numPoints;\n    }\n    meanVal = meanVal / npts;\n    return meanVal;\n  }\n\n  get startTime(): moment {\n    return this._startTime;\n  }\n  get endTime(): moment {\n    return this._endTime;\n  }\n  get timeRange(): StartEndDuration {\n    return new StartEndDuration(this.startTime, this.endTime);\n  }\n  get networkCode(): string {\n    return this._segmentArray[0].networkCode;\n  }\n  set networkCode(value: string) {\n    this._segmentArray.forEach(s => s.networkCode = value);\n  }\n  get stationCode(): string {\n    return this._segmentArray[0].stationCode;\n  }\n  set stationCode(value: string) {\n    this._segmentArray.forEach(s => s.stationCode = value);\n  }\n  get locationCode(): string {\n    return this._segmentArray[0].locationCode;\n  }\n  set locationCode(value: string) {\n    this._segmentArray.forEach(s => s.locationCode = value);\n  }\n  get channelCode(): string {\n    return this._segmentArray[0].channelCode;\n  }\n  set channelCode(value: string) {\n    this._segmentArray.forEach(s => s.channelCode = value);\n  }\n  get sampleRate(): number {\n    return this._segmentArray[0].sampleRate;\n  }\n  get yUnit(): string {\n    return this._segmentArray[0].yUnit;\n  }\n  get numPoints(): number {\n    return this._segmentArray.reduce((accumulator, seis) => accumulator + seis.numPoints, 0);\n  }\n  hasCodes(): boolean {\n    return this._segmentArray[0].hasCodes();\n  }\n  codes(): string {\n    return this._segmentArray[0].codes();\n  }\n  get segments(): Array<SeismogramSegment> {\n    return this._segmentArray;\n  }\n  append(seismogram: SeismogramSegment | Seismogram) {\n    if (seismogram instanceof Seismogram) {\n      seismogram._segmentArray.forEach(s => this.append(s));\n    } else {\n      this.checkSimilar(this._segmentArray[0], seismogram);\n      this._startTime = moment.min([ this.startTime, moment.utc(seismogram.startTime)]);\n      this._endTime = moment.max([ this.endTime, moment.utc(seismogram.endTime)]);\n      this._segmentArray.push(seismogram);\n    }\n  }\n  /**\n   * Cut the seismogram. Creates a new seismogram with all datapoints\n   * contained in the time window.\n   *\n   * @param  timeWindow start and end of cut\n   * @returns            new seismogram\n   */\n  cut(timeWindow: StartEndDuration): null | Seismogram {\n    // coarse trim first\n    let out = this.trim(timeWindow);\n    if (out && out._segmentArray) {\n      let cutSeisArray = this._segmentArray.map(seg => seg.cut(timeWindow)).filter(Boolean);\n      if (cutSeisArray.length > 0) {\n        out = new Seismogram(cutSeisArray);\n      } else {\n        out = null;\n      }\n    } else {\n      out = null;\n    }\n    return out;\n  }\n  /**\n   * Creates a new Seismogram composed of all seismogram segments that overlap the\n   * given time window. If none do, this returns null. This is a faster but coarser\n   * version of cut as it only removes whole segments that do not overlap the\n   * time window. For most seismograms that consist of a single contiguous\n   * data segment, this will do nothing.\n   *\n   * @param timeWindow time range to trim to\n   * @returns seismogram if data in the window, null otherwise\n   * @see cut\n   */\n  trim(timeWindow: StartEndDuration): null | Seismogram {\n    let out = null;\n    if (this._segmentArray) {\n      let trimSeisArray = this._segmentArray.filter(function(d) {\n        return d.endTime.isSameOrAfter(timeWindow.startTime);\n      }).filter(function(d) {\n        return d.startTime.isSameOrBefore(timeWindow.endTime);\n      });\n      if (trimSeisArray.length > 0) {\n        out = new Seismogram(trimSeisArray);\n      }\n    }\n    return out;\n  }\n  break(duration: moment.Duration) {\n    if (this._segmentArray) {\n      let breakStart = moment.utc(this.startTime);\n      let out = [];\n      while (breakStart.isBefore(this.endTime)) {\n        let breakWindow = new StartEndDuration(breakStart, null, duration);\n        let cutSeisArray = this._segmentArray.map(seg => seg.cut(breakWindow));\n        out = out.concat(cutSeisArray);\n        breakStart.add(duration);\n      }\n      // check for null, filter true if seg not null\n      out = out.filter(Boolean);\n      this._segmentArray = out;\n    }\n    return this;\n  }\n  isContiguous() {\n    if (this._segmentArray.length === 1) {\n      return true;\n    }\n    let prev = null;\n    for (const s of this._segmentArray) {\n      if (prev && ! (prev.endTime.isBefore(s.startTime)\n          && prev.endTime.add(1000*1.5/prev.sampleRate, 'ms').isAfter(s.startTime))) {\n        return false;\n      }\n      prev = s;\n    }\n    return true;\n  }\n  merge(): Int32Array | Float32Array | Float64Array {\n    let outArray;\n    if (this._segmentArray[0].y instanceof Int32Array) {\n      outArray = new Int32Array(this.numPoints);\n    } else if (this._segmentArray[0].y instanceof Float32Array) {\n      outArray = new Float32Array(this.numPoints);\n    } else if (this._segmentArray[0].y instanceof Float64Array) {\n      outArray = new Float64Array(this.numPoints);\n    } else {\n      throw new Error(`data not one of Int32Array, Float32Array or Float64Array: ${this._segmentArray[0].y.constructor.name}`);\n    }\n    let i=0;\n    this._segmentArray.forEach( seg => {\n      for(let v of seg.y) {\n        outArray[i] = v;\n        i++;\n      }\n    });\n    return outArray;\n  }\n  /**\n   * Gets the timeseries as an typed array if it is contiguous.\n   *\n   * @throws {NonContiguousData} if data is not contiguous.\n   * @returns  timeseries as array of number\n   */\n  get y(): Int32Array | Float32Array | Float64Array {\n    if ( ! this._y) {\n      if (this.isContiguous()) {\n        this._y = this.merge();\n      }\n    }\n    if (this._y) {\n      return this._y;\n    } else {\n      throw new Error(\"Seismogram is not contiguous, acces each SeismogramSegment idividually.\");\n    }\n  }\n  set y(val: Int32Array | Float32Array | Float64Array ) {\n    // ToDo\n    throw new Error(\"seismogram y setter not impl, see cloneWithNewData()\");\n  }\n  clone(): Seismogram {\n    let cloned = this._segmentArray.map( s => s.clone());\n    return new Seismogram(cloned);\n  }\n\n  cloneWithNewData(newY: Int32Array | Float32Array | Float64Array): Seismogram {\n    if (newY && newY.length > 0) {\n      let seg = this._segmentArray[0].cloneWithNewData(newY);\n      return new Seismogram([seg]);\n    } else {\n      throw new Error(\"Y value is empty\");\n    }\n  }\n  /**\n   * factory method to create a single segment Seismogram from either encoded data\n   *  or a TypedArray, along with sample rate and start time.\n   *\n   * @param yArray array of encoded data or typed array\n   * @param sampleRate sample rate, samples per second of the data\n   * @param startTime time of first sample\n   * @returns seismogram initialized with the data\n   */\n  static createFromContiguousData(yArray: Array<seedcodec.EncodedDataSegment> | Int32Array | Float32Array | Float64Array,\n                                  sampleRate: number,\n                                  startTime: moment) {\n    const seg = new SeismogramSegment(yArray, sampleRate, startTime);\n    return new Seismogram([seg]);\n  }\n}\n\nexport class NonContiguousData extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nexport function ensureIsSeismogram(seisSeismogram: Seismogram | SeismogramSegment) {\n  if (typeof seisSeismogram === \"object\") {\n    if (seisSeismogram instanceof Seismogram) {\n      return seisSeismogram;\n    } else if (seisSeismogram instanceof SeismogramSegment) {\n      return new Seismogram([ seisSeismogram ]);\n    } else {\n      let s = typeof seisSeismogram;\n      if (seisSeismogram.prototype && seisSeismogram.prototype.constructor) {\n        s += \" \"+seisSeismogram.prototype.constructor.name;\n      } else {\n        s += \" \"+seisSeismogram;\n      }\n      throw new Error(\"must be Seismogram or SeismogramSegment but \"+s);\n    }\n  } else {\n    throw new Error(\"must be Seismogram or SeismogramSegment but not an object\");\n  }\n}\n\n\nexport class SeismogramDisplayData {\n  /** @private */\n  _seismogram: Seismogram | null;\n  _id: string | null;\n  label: string | null;\n  markerList: Array<MarkerType>;\n  channel: Channel | null;\n  _instrumentSensitivity: InstrumentSensitivity | null;\n  quakeList: Array<Quake>;\n  timeWindow: StartEndDuration;\n  alignmentTime: moment | null;\n  doShow: boolean;\n  _statsCache: SeismogramDisplayStats | null;\n  constructor(timeWindow: StartEndDuration) {\n    if ( ! timeWindow) {\n      throw new Error(\"StartEndDuration must not be missing.\");\n    }\n    this._id = null;\n    this._seismogram = null;\n    this.label = null;\n    this.markerList = [];\n    this.channel = null;\n    this._instrumentSensitivity = null;\n    this.quakeList = [];\n    this.timeWindow = timeWindow;\n    this.alignmentTime = null;\n    this.doShow = true;\n    this._statsCache = null;\n  }\n  static fromSeismogram(seismogram: Seismogram ): SeismogramDisplayData {\n    const out = new SeismogramDisplayData(new StartEndDuration(seismogram.startTime, seismogram.endTime, null, null));\n    out.seismogram = seismogram;\n    return out;\n  }\n  static fromChannelAndTimeWindow(channel: Channel, timeWindow: StartEndDuration): SeismogramDisplayData {\n    const out = new SeismogramDisplayData(timeWindow);\n    out.channel = channel;\n    return out;\n  }\n  static fromChannelAndTimes(channel: Channel, startTime: moment, endTime: moment): SeismogramDisplayData {\n    const out = new SeismogramDisplayData(new StartEndDuration(startTime, endTime));\n    out.channel = channel;\n    return out;\n  }\n  addQuake(quake: Quake | Array<Quake> ) {\n    if (Array.isArray(quake)) {\n      quake.forEach(q => this.quakeList.push(q));\n    } else {\n      this.quakeList.push(quake);\n    }\n  }\n  addMarkers(markers: MarkerType | Array<MarkerType>) {\n      if (Array.isArray(markers)) {\n        markers.forEach(m => this.markerList.push(m));\n      } else {\n        this.markerList.push(markers);\n      }\n  }\n  hasQuake(): boolean {\n    return this.quakeList.length > 0;\n  }\n  hasSeismogram(): boolean {\n    return isDef(this._seismogram);\n  }\n  hasChannel(): boolean {\n    return this.channel !== null;\n  }\n  hasSensitivity(): boolean {\n    return this._instrumentSensitivity !== null\n        || (isDef(this.channel) && this.channel.hasInstrumentSensitivity());\n  }\n  /**\n   * Allows id-ing a seismogram. Optional.\n   *\n   * @returns         string id\n   */\n  get id(): string | null {\n    return this._id;\n  }\n  /**\n   * Allows iding a seismogram. Optional.\n   *\n   * @param   value string id\n   */\n  set id(value: string | null) {\n    this._id = value;\n  }\n  /**\n   * return network code as a string.\n   * Uses this.channel if it exists, this.seismogram if not.\n   *\n   * @returns network code\n   */\n  get networkCode(): string {\n    if (this.channel !== null) {\n      return this.channel.networkCode;\n    } else if (isDef(this._seismogram)) {\n      return this._seismogram.networkCode;\n    } else {\n      return \"unknown\";\n    }\n  }\n  /**\n   * return station code as a string.\n   * Uses this.channel if it exists, this.seismogram if not.\n   *\n   * @returns station code\n   */\n  get stationCode(): string {\n    if (this.channel !== null) {\n      return this.channel.stationCode;\n    } else if (isDef(this._seismogram)) {\n      return this._seismogram.stationCode;\n    } else {\n      return \"unknown\";\n    }\n  }\n  /**\n   * return location code a a string.\n   * Uses this.channel if it exists, this.seismogram if not.\n   *\n   * @returns location code\n   */\n  get locationCode(): string {\n    if (this.channel !== null) {\n      return this.channel.locationCode;\n    } else if (isDef(this._seismogram)) {\n      return this._seismogram.locationCode;\n    } else {\n      return \"unknown\";\n    }\n  }\n  /**\n   * return channels code as a string.\n   * Uses this.channel if it exists, this.seismogram if not.\n   *\n   * @returns channel code\n   */\n  get channelCode(): string {\n    if (this.channel !== null) {\n      return this.channel.channelCode;\n    } else if (isDef(this._seismogram)) {\n      return this._seismogram.channelCode;\n    } else {\n      return \"unknown\";\n    }\n  }\n  /**\n   * return network, station, location and channels codes as one string.\n   * Uses this.channel if it exists, this.seismogram if not.\n   *\n   * @param sep separator, defaults to '.'\n   * @returns nslc codes separated by sep\n   */\n  codes(sep: string = '.'): string {\n    if (this.channel !== null) {\n      return this.channel.codes();\n    } else {\n    return (this.networkCode ? this.networkCode : '')\n      +sep+(this.stationCode ? this.stationCode : '')\n      +sep+(this.locationCode ? this.locationCode : '')\n      +sep+(this.channelCode ? this.channelCode : '');\n    }\n  }\n  get startTime(): moment {\n    return this.timeWindow.startTime;\n  }\n  get endTime(): moment {\n    return this.timeWindow.endTime;\n  }\n  get sensitivity(): InstrumentSensitivity | null {\n    const channel = this.channel;\n    if (this._instrumentSensitivity) {\n      return this._instrumentSensitivity;\n    } else if (isDef(channel) && channel.hasInstrumentSensitivity()) {\n      return channel.instrumentSensitivity;\n    } else {\n      return null;\n    }\n  }\n  set sensitivity(value: InstrumentSensitivity | null) {\n    this._instrumentSensitivity = value;\n  }\n  get min() {\n    if ( ! this._statsCache ) {\n      this._statsCache = this.calcStats();\n    }\n    return this._statsCache.min;\n  }\n  get max() {\n    if ( ! this._statsCache ) {\n      this._statsCache = this.calcStats();\n    }\n    return this._statsCache.max;\n  }\n  get mean() {\n    if ( ! this._statsCache ) {\n      this._statsCache = this.calcStats();\n    }\n    return this._statsCache.mean;\n  }\n  get seismogram() {\n    return this._seismogram;\n  }\n  set seismogram(value: Seismogram | null) {\n    this._seismogram = value;\n    this._statsCache = null;\n  }\n  calcStats() {\n    let stats = new SeismogramDisplayStats();\n    if (this.seismogram) {\n      let minMax = this.seismogram.findMinMax();\n      stats.min = minMax[0];\n      stats.max = minMax[1];\n      // $FlowFixMe  know seismogram is not null\n      stats.mean = this.seismogram.mean();\n    }\n    this._statsCache = stats;\n    return stats;\n  }\n  clone(): SeismogramDisplayData {\n    return this.cloneWithNewSeismogram(this.seismogram ? this.seismogram.clone() : null);\n  }\n  cloneWithNewSeismogram(seis: Seismogram | null): SeismogramDisplayData {\n      let out = new SeismogramDisplayData(this.timeWindow);\n      Object.getOwnPropertyNames(this).forEach( name => {\n        if (name === '_seismogram') {\n          out._seismogram = seis;\n        // $FlowFixMe\n        } else if (this[name] instanceof moment) {\n          // $FlowFixMe\n          out[name] = moment.utc(this[name]);\n          // $FlowFixMe\n        } else if ( Array.isArray(this[name]) ) {\n          // $FlowFixMe\n          out[name] = this[name].slice();\n        } else {\n          // $FlowFixMe\n          out[name] = this[name];\n        }\n      });\n      out.seismogram = seis;\n      out._statsCache = null;\n      return out;\n  }\n  /**\n   * Cut the seismogram. Creates a new seismogramDisplayData with the cut\n   * seismogram and the timeWindow set to the new time window.\n   *\n   * @param  timeWindow start and end of cut\n   * @returns           new seismogramDisplayData\n   */\n  cut(timeWindow: StartEndDuration): null | SeismogramDisplayData {\n    let cutSeis = this.seismogram;\n    let out;\n    if (cutSeis) {\n      cutSeis = cutSeis.cut(timeWindow);\n      out = this.cloneWithNewSeismogram(cutSeis);\n    } else {\n      // no seismogram, so just clone?\n      out = this.clone();\n    }\n    out.timeWindow = timeWindow;\n    return out;\n  }\n}\n\nexport class SeismogramDisplayStats {\n  min: number;\n  max: number;\n  mean: number;\n  trendSlope: number;\n  constructor() {\n    this.min = 0;\n    this.max = 0;\n    this.mean = 0;\n    this.trendSlope = 0;\n  }\n}\n\nexport function findStartEnd(sddList: Array<SeismogramDisplayData>): StartEndDuration {\n  let allStart = sddList.map(sdd => {\n    return moment.utc(sdd.timeWindow.startTime);\n  });\n  let startTime = moment.min(allStart);\n  let allEnd = sddList.map(sdd => {\n    return moment.utc(sdd.timeWindow.endTime);\n  });\n  let endTime = moment.max(allEnd);\n  return new StartEndDuration(startTime, endTime);\n}\n\nexport function findMinMax(sddList: Array<SeismogramDisplayData>): Array<number> {\n  let min = sddList.map(sdd => {\n    return sdd.min;\n  }).reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n  let max = sddList.map(sdd => {\n    return sdd.max;\n  }).reduce(function (p, v) {\n    return ( p > v ? p : v );\n  });\n  return [min, max];\n}\n\nconst initial_minAmp = Number.MAX_SAFE_INTEGER;\nconst initial_maxAmp = -1 * (initial_minAmp);\n\nexport function findMinMaxOverTimeRange(sddList: Array<SeismogramDisplayData>, timeWindow: StartEndDuration): Array<number> {\n  let minMaxArr = sddList.map(sdd => {\n      if (sdd.seismogram) {\n        const cutSeis = sdd.seismogram.cut(timeWindow);\n        if (cutSeis) {\n          return cutSeis.findMinMax();\n        }\n      }\n      return [initial_minAmp,initial_maxAmp];\n    });\n  let min = minMaxArr.map(mm => {\n    return mm[0];\n  }).reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n  let max = minMaxArr.map(mm => {\n    return mm[1];\n  }).reduce(function (p, v) {\n    return ( p > v ? p : v );\n  });\n  return [min, max];\n}\n\n\nexport function findStartEndOfSeismograms(data: Array<Seismogram>, accumulator?: StartEndDuration): StartEndDuration {\n  let out: StartEndDuration;\n  if ( ! accumulator && ! data) {\n    throw new Error(\"data and accumulator are not defined\");\n  } else if ( ! accumulator) {\n    out = new StartEndDuration( moment.utc('2500-01-01'), moment.utc('1001-01-01'));\n  } else {\n    out = accumulator;\n  }\n  if ( Array.isArray(data)) {\n    for (let s of data) {\n      if ( s.startTime < out.startTime) {\n        out = new StartEndDuration( moment.utc(s.startTime), out.endTime);\n      }\n      if ( out.endTime < s.endTime ) {\n        out = new StartEndDuration( out.startTime, moment.utc(s.endTime));\n      }\n    }\n  } else {\n    throw new Error(`Expected Array as first arg but was: ${typeof data}`);\n  }\n  return out;\n}\n\n\nexport function findMinMaxOfSeismograms(data: Array<Seismogram> , minMaxAccumulator ?: Array<number>): Array<number> {\n  for(let s of data) {\n    minMaxAccumulator = s.findMinMax(minMaxAccumulator);\n  }\n  if (minMaxAccumulator) {\n    return minMaxAccumulator;\n  } else {\n    return [-1, 1];\n  }\n}\n"],"names":["COUNT_UNIT","SeismogramSegment","constructor","yArray","sampleRate","startTime","Int32Array","Float32Array","Float64Array","_y","_compressed","Array","isArray","every","ee","seedcodec","from","_sampleRate","_startTime","checkStringOrDate","yUnit","_endTime_cache","_endTime_cache_numPoints","y","out","isEncoded","Error","outLen","numPoints","compressionType","currIdx","c","cData","decode","i","numSamples","value","_invalidate_endTime_cache","endTime","timeOfSample","timeWindow","StartEndDuration","length","netCode","networkCode","staCode","stationCode","locId","locationCode","locCode","chanCode","channelCode","getEncoded","yAtIndex","findMinMax","minMaxAccumulator","minAmp","Number","MAX_SAFE_INTEGER","maxAmp","yData","n","moment","utc","add","indexOfTime","t","isBefore","isAfter","Math","round","diff","hasCodes","isDef","codes","sep","seisId","toISOString","replace","clone","clonedData","slice","cloneWithNewData","clonedStartTime","cut","sIndex","milliDiff","offset","floor","eIndex","cutY","Seismogram","segmentArray","_segmentArray","stringify","checkAllSimilar","findStartEnd","f","forEach","s","checkSimilar","allStart","map","seis","min","allEnd","_endTime","max","mean","meanVal","npts","segments","meanOfSlice","timeRange","reduce","accumulator","append","seismogram","push","trim","cutSeisArray","seg","filter","Boolean","trimSeisArray","d","isSameOrAfter","isSameOrBefore","break","duration","breakStart","breakWindow","concat","isContiguous","prev","merge","outArray","name","v","val","cloned","newY","createFromContiguousData","NonContiguousData","message","ensureIsSeismogram","seisSeismogram","prototype","SeismogramDisplayData","_id","_seismogram","label","markerList","channel","_instrumentSensitivity","quakeList","alignmentTime","doShow","_statsCache","fromSeismogram","fromChannelAndTimeWindow","fromChannelAndTimes","addQuake","quake","q","addMarkers","markers","m","hasQuake","hasSeismogram","hasChannel","hasSensitivity","hasInstrumentSensitivity","id","sensitivity","instrumentSensitivity","calcStats","stats","SeismogramDisplayStats","minMax","cloneWithNewSeismogram","Object","getOwnPropertyNames","cutSeis","trendSlope","sddList","sdd","p","initial_minAmp","initial_maxAmp","findMinMaxOverTimeRange","minMaxArr","mm","findStartEndOfSeismograms","data","findMinMaxOfSeismograms"],"mappings":"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"}