import moment$1 from 'moment';
import { format, utcFormat, utcSecond, utcMinute, utcHour, utcDay, utcMonth, utcYear } from 'd3';
import { isDef } from './util.js';
import { Seismogram, SeismogramDisplayData } from './seismogram.js';

/*
 * Philip Crotwell
 * University of South Carolina, 2019
 * http://www.seis.sc.edu
 */

/** Constant for drawing seismogram using svg. */
const DRAW_SVG = "svg";
/** Constant for drawing seismogram using canvas, axies are still svg. */

const DRAW_CANVAS = "canvas";
/** Constant for drawing seismogram using both canvas and svg, for testing. */

const DRAW_BOTH = "both"; // for testing

/** Constant for drawing seismogram using both canvas and svg plus alignment markers, for testing. */

const DRAW_BOTH_ALIGN = "alignment"; // for testing

/**
 * Configuration object for Seismograph display.
 * 
 */

class SeismographConfig {
  //below this draw all points, above draw minmax
  // no zoom in past point of sample
  // separated by pixels
  constructor() {
    this.drawingType = DRAW_CANVAS;
    this.isXAxis = true;
    this.isXAxisTop = false;
    this.isYAxisNice = true;
    this.isYAxis = true;
    this.isYAxisRight = false;
    this.xScaleFormat = multiFormatHour;
    this.yScaleFormat = formatCountOrAmp;
    this._title = [];
    this.xLabel = "Time";
    this.xLabelOrientation = "horizontal";
    this.xSublabel = "";
    this.yLabel = "Amplitude";
    this.yLabelRight = "";
    this.yLabelOrientation = "vertical";
    this.ySublabel = "";
    this.ySublabelTrans = 15;
    this.ySublabelIsUnits = true;
    this.doRMean = true;
    this.doGain = true;
    this.windowAmp = true;
    this.fixedYScale = null;
    this.fixedTimeScale = null;
    this.doMarkers = true;
    this.markerTextOffset = .85;
    this.markerTextAngle = 45;
    this.markerFlagpoleBase = "bottom"; // bottom or center

    this.minHeight = 0;
    this.margin = {
      top: 20,
      right: 20,
      bottom: 42,
      left: 85,
      toString: function toString() {
        return "t:" + this.top + " l:" + this.left + " b:" + this.bottom + " r:" + this.right;
      }
    };
    this.segmentDrawCompressedCutoff = 10; //below this draw all points, above draw minmax

    this.maxZoomPixelPerSample = 20; // no zoom in past point of sample
    // separated by pixels

    this.wheelZoom = true;
    this.connectSegments = false;
    this.lineColors = ["skyblue", "olivedrab", "goldenrod", "firebrick", "darkcyan", "orange", "darkmagenta", "mediumvioletred", "sienna", "black"];
    this.lineWidth = 1;
  }
  /**
   * gets the current title
   *
   * @returns        title as an array of strings
   */


  get title() {
    return this._title;
  }
  /**
   * Sets the title as simple string or array of strings. If an array
   * then each item will be in a separate tspan for easier formatting.
   *
   * @param value string or array of strings to be the title
   */


  set title(value) {
    if (Array.isArray(value)) {
      this._title = value;
    } else {
      this._title = [value];
    }
  }
  /** Fake data to use to test alignment of seismograph axis and between canvas
   *  and svg drawing.
   *
   * @param   timeWindow start and end of fake data
   * @param   min        min amplitude for fake data, default is -100
   * @param   max        max amplitude for fake data, default is 100
   * @returns             fake data
   */


  createAlignmentData(timeWindow, min = -100, max = 100) {
    const mid = (max + min) / 2;
    const fakeData = Float32Array.from([max, min, max, min, mid, mid, max, mid, mid, min]);
    const fakeSampleRate = 1 / (timeWindow.duration.asSeconds() / (fakeData.length - 1));
    const fakeSeis = Seismogram.createFromContiguousData(fakeData, fakeSampleRate, timeWindow.startTime);
    const fakeSDD = SeismogramDisplayData.fromSeismogram(fakeSeis);
    return fakeSDD;
  }

  getColorForIndex(i) {
    if (isDef(this.lineColors) && this.lineColors.length > 0) {
      return this.lineColors[i % this.lineColors.length];
    } else {
      return "black";
    }
  }

  clone() {
    let out = new SeismographConfig();
    Object.getOwnPropertyNames(this).forEach(name => {
      // $FlowFixMe
      if (this[name] instanceof moment$1) {
        // $FlowFixMe
        out[name] = moment$1.utc(this[name]); // $FlowFixMe
      } else if (Array.isArray(this[name])) {
        // $FlowFixMe
        out[name] = this[name].slice();
      } else {
        // $FlowFixMe
        out[name] = this[name];
      } // handle margin separately


      out.margin = {
        top: this.margin.top,
        right: this.margin.right,
        bottom: this.margin.bottom,
        left: this.margin.left,
        toString: function toString() {
          return "t:" + this.top + " l:" + this.left + " b:" + this.bottom + " r:" + this.right;
        }
      };
    });
    return out;
  }

  toString() {
    let outS = "";
    Object.getOwnPropertyNames(this).forEach(name => {
      // $FlowFixMe
      outS += "  seisConfig.".concat(name, " = ").concat(JSON.stringify(this[name]), "\n");
    });
    return outS;
  }

}
const formatCount = format('~s');
const formatExp = format('.2e');
const formatCountOrAmp = function formatCountOrAmp(v) {
  return -1 < v && v < 1 && v !== 0 ? formatExp(v) : formatCount(v);
};
const formatMillisecond = utcFormat(".%L");
const formatSecond = utcFormat(":%S");
const formatMinute = utcFormat("%H:%M");
const formatHour = utcFormat("%H:%M");
const formatDay = utcFormat("%m/%d");
const formatMonth = utcFormat("%Y/%m");
const formatYear = utcFormat("%Y");
const multiFormatHour = function multiFormatHour(date) {
  return (utcSecond(date) < date ? formatMillisecond : utcMinute(date) < date ? formatSecond : utcHour(date) < date ? formatMinute : utcDay(date) < date ? formatHour : utcMonth(date) < date ? formatDay : utcYear(date) < date ? formatMonth : formatYear)(date);
};

export { DRAW_BOTH, DRAW_BOTH_ALIGN, DRAW_CANVAS, DRAW_SVG, SeismographConfig, formatCount, formatCountOrAmp, formatDay, formatExp, formatHour, formatMillisecond, formatMinute, formatMonth, formatSecond, formatYear, multiFormatHour };
//# sourceMappingURL=seismographconfig.js.map
