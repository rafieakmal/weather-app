{"version":3,"file":"mseedarchive.js","sources":["../../src/mseedarchive.js"],"sourcesContent":["// @flow\n\n/*\n * Philip Crotwell\n * University of South Carolina, 2019\n * http://www.seis.sc.edu\n */\n\nimport moment from 'moment';\nimport * as util from './util';\nimport * as miniseed from './miniseed';\nimport * as RSVP from 'rsvp';\n\nimport {SeismogramDisplayData } from './seismogram';\nimport {Channel} from './stationxml';\nimport {StartEndDuration, isDef} from './util.js';\n\nexport const Allowed_Flags = [ 'n', 's', 'l', 'c', 'Y', 'j', 'H'];\n\n/**\n * A web based connection to an archive of miniseed files\n * arranged based on a pattern using n, s, l, c, Y, j, H\n * for network, station, locid, channel, year, day of year\n * and hour. This is a subset of the options available within\n * the IRIS Ringserver MSeedArchive option, on which this\n * is based. Retrieved seismograms are cut from the larger\n * miniseed files retrieved via http(s), and so there is\n * wasted bandwidth to the server. On the other hand this\n * requires no extra software on the server side beyond\n * a directory structure with suitably small miniseed files.\n * Generally we find channel-hour is a reasonable size for\n * most seismic channels. The URL to needed files is\n * constructed by concatenating the rootUrl with the pattern\n * using a time range large enough to get all overlaps\n * based on the smallest sample rate per channel band code\n * and record size, which defaults to 512.\n *\n */\nexport class MSeedArchive {\n  _rootUrl: string;\n  _pattern: string;\n  _recordSize: number;\n  _timeoutSec: number;\n  constructor(rootUrl: string, pattern: string) {\n    this._rootUrl = rootUrl;\n    this._pattern = pattern;\n    this._recordSize = 512;\n    this._timeoutSec = 30;\n    this.checkPattern(this._pattern);\n  }\n  get rootUrl(): string {\n    return this._rootUrl;\n  }\n  get pattern(): string {\n    return this._pattern;\n  }\n  get recordSize(): number {\n    return this._recordSize;\n  }\n  /**\n   * checks pattern for allowed flags as not all that are supported\n   * by ringserver are supported here. Must only include:\n   * * n network code, white space removed\n   * * s station code, white space removed\n   * * l  location code, white space removed\n   * * c  channel code, white space removed\n   * * Y  year, 4 digits\n   * * j  day of year, 3 digits zero padded\n   * * H  hour, 2 digits zero padded\n   *\n   * @param p mseed archive pattern string\n   * @returns true if all flags are allowed\n   */\n  checkPattern(p: string): boolean {\n    let regexp = /%[a-zA-Z]/g;\n    let allFlags = p.match(regexp);\n    if ( ! allFlags) {\n      return false;\n    } else {\n      for( let f of allFlags) {\n        if (Allowed_Flags.indexOf(f.slice(1)) === -1) {\n          throw new Error(`${f} not allowed in pattern`);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Loads seismograms from the remote miniseed archive via\n   * http(s). Files downloaded include all that might overlap\n   * the given time window based on record size,\n   * the minimum sample rate\n   * for the channel band code and the given time window.\n   *\n   * @param   channelTimeList requst channels and time windows\n   * @returns Promise to the same SeismogramDisplayData array, but with seismograms populated\n   */\n  loadSeismograms(channelTimeList: Array<SeismogramDisplayData>): Promise<Array<SeismogramDisplayData>> {\n    let promiseArray = channelTimeList.map(ct => {\n      if (isDef(ct.channel)) {\n        const channel = ct.channel;\n        return RSVP.hash({\n            \"request\": ct,\n            \"dataRecords\": this.loadDataForChannel(channel, ct.startTime, ct.endTime)\n          });\n        } else {\n          throw new Error(\"channel is missing in loadSeismograms \");\n        }\n      });\n    return RSVP.all(promiseArray).then(pArray => {\n        let out = [];\n        pArray.forEach(p => {\n          let seisArray = miniseed.seismogramPerChannel(p.dataRecords);\n          // should only be one\n          for (let seis of seisArray) {\n            let cutSeis = seis.cut(new StartEndDuration(p.request.startTime, p.request.endTime));\n            p.request.seismogram = cutSeis;\n            out.push(p.request);\n          }\n        });\n        return out;\n    });\n  }\n  /**\n   * Loads miniseed records based on channel and time window.\n   *\n   * @param   channel   channel to request\n   * @param   startTime start time\n   * @param   endTime   end time\n   * @returns Promise to array of miniseed records\n   */\n  loadDataForChannel(channel: Channel, startTime: moment, endTime: moment): Promise<Array<miniseed.DataRecord>> {\n    return this.loadData(channel.station.network.networkCode,\n                    channel.station.stationCode,\n                    channel.locationCode,\n                    channel.channelCode,\n                    startTime,\n                    endTime,\n                    channel.sampleRate);\n  }\n  /**\n   * Loads miniseed records based on string channel codes.\n   *\n   * @param   net        network code\n   * @param   sta        station code\n   * @param   loc        location code\n   * @param   chan       channel code\n   * @param   startTime  start time\n   * @param   endTime    end time\n   * @param   sampleRate known sample rate for this channel\n   * @returns             Promise to array of miniseed records\n   */\n  loadData(net: string, sta: string, loc: string, chan: string, startTime: moment, endTime: moment, sampleRate: number): Promise<Array<miniseed.DataRecord>> {\n    let basePattern = this.fillBasePattern(net, sta, loc, chan);\n    if ( ! util.isDef(sampleRate)) {\n      sampleRate = minSampleRate(chan);\n    }\n    let recordTime = maxTimeForRecord(this._recordSize, sampleRate);\n    let t = moment.utc(startTime).subtract(recordTime, 'seconds');\n    let urlList = [];\n    while (t.isBefore(endTime)) {\n      let url = this.rootUrl+'/'+this.fillTimePattern(basePattern, t);\n      t.add(1, 'hour');\n      urlList.push(url);\n    }\n    if (moment.utc(t).add(recordTime, 'seconds').isAfter(endTime)) {\n      let url = this.rootUrl+'/'+this.fillTimePattern(basePattern, t);\n      urlList.push(url);\n    }\n    return loadDataRecords(urlList).then(dataRecords => {\n      if (dataRecords) {\n        dataRecords =  dataRecords.filter(dr => dr.header.endTime.isSameOrAfter(startTime) &&\n                                        dr.header.startTime.isSameOrBefore(endTime));\n      } else {\n        dataRecords = []; // for flow\n      }\n      return dataRecords;\n    });\n  }\n  /**\n   * Replaces codes from channel in base pattern.\n   *\n   * @param   net  string to replace '%n'\n   * @param   sta  string to replace '%s'\n   * @param   loc  string to replace '%l'\n   * @param   chan string to replace '%c'\n   * @returns       new string with channel replacements made\n   */\n  fillBasePattern(net: string, sta: string, loc: string, chan: string): string {\n    return this.pattern.replace(/%n/g, net)\n      .replace(/%s/g, sta)\n      .replace(/%l/g, loc)\n      .replace(/%c/g, chan);\n  }\n  /**\n   * Replaces time entries ( %Y, %j, %H ) in pattern.\n   *\n   * @param   basePattern pattern to replace in\n   * @param   t           moment in time\n   * @returns              string with time replaces\n   */\n  fillTimePattern(basePattern: string, t: moment): string {\n    return basePattern.replace(/%Y/g, t.format('YYYY'))\n      .replace(/%j/g, t.format('DDDD'))\n      .replace(/%H/g, t.format('HH'));\n\n  }\n}\n\nexport function loadDataRecords(urlList: Array<string>,\n                                fetchInit?: { [key: string]: any},\n                                timeoutSec?: number): Promise<Array<miniseed.DataRecord>> {\n  let promiseArray = urlList.map( (url) => {\n    return util.doFetchWithTimeout(url, fetchInit, timeoutSec)\n    .then(fetchResponse => {\n      if (fetchResponse.ok) {\n        if (fetchResponse.status === 200 || fetchResponse.status === 304) {\n          return fetchResponse.arrayBuffer().then(ab => {\n            let dataRecords = [];\n            if (ab.byteLength > 0) {\n              dataRecords = miniseed.parseDataRecords(ab);\n            }\n            return dataRecords;\n          });\n        } else if (fetchResponse.status === 404 ) {\n          return []; // empty array means no data\n        } else {\n          util.log(\"no data: status=\"+fetchResponse.status+\" \"+fetchResponse.url);\n          return [];\n        }\n      } else if (fetchResponse.status === 404 ) {\n        return []; // empty array means no data\n      } else {\n        // $FlowFixMe\n        throw new Error(\"fetch error: \"+fetchResponse.ok+\" \"+fetchResponse.status+\" \"+fetchResponse.url);\n      }\n    }).catch(err => {\n      util.log(\"caught fetch err, continuing with empty: \"+err);\n      return [];\n    });\n  });\n\n  return RSVP.all(promiseArray).then(pArray => {\n      let dataRecords: Array<miniseed.DataRecord> = [];\n      pArray.forEach(p => {\n        dataRecords = dataRecords.concat(p);\n      });\n      return dataRecords;\n  });\n}\n\n\n/**\n * Gives the maximum sample rate for the channel, based on the\n * band code, first char, of the channel code.\n *\n * @param chan channel code like BHZ, only the first letter is used\n * @returns mimumum sample rate this could be\n */\nexport function maxSampleRate(chan: string): number {\n  let f = chan.slice(0,1);\n  switch(f) {\n    case 'F':\n    case 'G':\n      return 5000;\n    case 'D':\n    case 'C':\n      return 1000;\n    case 'E':\n    case 'H':\n      return 250;\n    case 'S':\n    case 'B':\n      return 80;\n    case 'M':\n      return 10;\n    case 'L':\n      return 1;\n    case 'V':\n      return .1;\n    case 'U':\n      return .01;\n    case 'R':\n      return .001;\n    case 'P':\n      return .0001;\n    case 'Q':\n      return .000001;\n    default:\n      throw new Error(\"Unknown band code \"+f+\" in \"+chan);\n  }\n}\n\n\n /**\n  * Gives the minimum sample rate for the channel, based on the\n  * band code, first char, of the channel code.\n  *\n  * @param chan channel code like BHZ, only the first letter is used\n  * @returns mimumum sample rate this could be\n  **/\nexport function minSampleRate(chan: string): number {\n  let f = chan.slice(0,1);\n  switch(f) {\n    case 'F':\n    case 'G':\n      return 1000;\n    case 'D':\n    case 'C':\n      return 2500;\n    case 'E':\n    case 'H':\n      return 80;\n    case 'S':\n    case 'B':\n      return 10;\n    case 'M':\n      return 1;\n    case 'L':\n      return 1; // maybe wrong, seed manual not clear\n    case 'V':\n      return .1; // maybe wrong, seed manual not clear\n    case 'U':\n      return .01; // maybe wrong, seed manual not clear\n    case 'R':\n      return .0001;\n    case 'P':\n      return .00001;\n    case 'Q':\n      return .0000001;\n    default:\n      throw new Error(\"Unknown band code \"+f+\" in \"+chan);\n  }\n}\n /** Calculates the maximum time coverage for a single miniseed record\n  * given the record size (usually 512 or 4096) and the sample rate (Hertz).\n  * This assumes 40 bytes of header and maximum compression of 2 samples\n  * per byte (4 bit per sample) which is the best Steim2.\n  *\n  * @param recordSize record size (usually 512 or 4096)\n  * @param sampleRate sample rate of record\n  * @returns maximum interval of time that a full record could cover when\n  * compression is at its most efficient\n  */\nexport function maxTimeForRecord(recordSize: number, sampleRate: number): number {\n  return (recordSize-40)*2/sampleRate;\n}\n"],"names":["Allowed_Flags","MSeedArchive","constructor","rootUrl","pattern","_rootUrl","_pattern","_recordSize","_timeoutSec","checkPattern","recordSize","p","regexp","allFlags","match","f","indexOf","slice","Error","loadSeismograms","channelTimeList","promiseArray","map","ct","isDef","channel","RSVP","loadDataForChannel","startTime","endTime","then","pArray","out","forEach","seisArray","miniseed","dataRecords","seis","cutSeis","cut","StartEndDuration","request","seismogram","push","loadData","station","network","networkCode","stationCode","locationCode","channelCode","sampleRate","net","sta","loc","chan","basePattern","fillBasePattern","util","minSampleRate","recordTime","maxTimeForRecord","t","moment","utc","subtract","urlList","isBefore","url","fillTimePattern","add","isAfter","loadDataRecords","filter","dr","header","isSameOrAfter","isSameOrBefore","replace","format","fetchInit","timeoutSec","fetchResponse","ok","status","arrayBuffer","ab","byteLength","catch","err","concat","maxSampleRate"],"mappings":"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"}