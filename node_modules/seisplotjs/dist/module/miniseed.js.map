{"version":3,"file":"miniseed.js","sources":["../../src/miniseed.js"],"sourcesContent":["// @flow\n\n/*\n * Philip Crotwell\n * University of South Carolina, 2019\n * http://www.seis.sc.edu\n */\n\n import moment from 'moment';\n\nimport {SeismogramSegment, Seismogram} from './seismogram';\nimport * as seedcodec from './seedcodec';\nimport { isDef, isNonEmptyStringArg } from './util.js';\n\nexport const MINISEED_MIME = \"application/vnd.fdsn.mseed\";\n\n/**\n * parse arrayBuffer into an array of DataRecords.\n *\n * @param arrayBuffer bytes to parse\n * @returns arry of data records\n */\nexport function parseDataRecords(arrayBuffer: ArrayBuffer): Array<DataRecord> {\n  let dataRecords = [];\n  let offset = 0;\n  while (offset < arrayBuffer.byteLength) {\n    let dataView = new DataView(arrayBuffer, offset);\n    let dr = parseSingleDataRecord(dataView);\n    dataRecords.push(dr);\n    offset += dr.header.recordSize;\n  }\n  return dataRecords;\n}\n\n/**\n * parse a single DataRecord starting at the beginning of the DataView.\n * Currently only some blockettes are parsed, 100, 1000, 1001, others are separated,\n * but left as just a DataView.\n *\n * @param dataView bytes as DataView\n * @returns data record\n */\nexport function parseSingleDataRecord(dataView: DataView): DataRecord {\n  let header = parseSingleDataRecordHeader(dataView);\n  let data = new DataView(dataView.buffer,\n                          dataView.byteOffset+header.dataOffset,\n                          header.recordSize-header.dataOffset);\n  return new DataRecord(header, data);\n}\n\n/**\n * parse the DataHeader from a single DataRecord starting at the beginning of the DataView.\n *\n * @param dataView bytes as DataView\n * @returns data record header\n */\nexport function parseSingleDataRecordHeader(dataView: DataView): DataHeader {\n  if (dataView.byteLength < 47) {\n    throw new Error(`Not enought bytes for header, need 47, found ${dataView.byteLength}`);\n  }\n  let out = new DataHeader();\n  out.seq = makeString(dataView, 0, 6);\n  out.typeCode = dataView.getUint8(6);\n  out.continuationCode = dataView.getUint8(7);\n  out.staCode = makeString(dataView, 8, 5);\n  out.locCode = makeString(dataView, 13, 2);\n  out.chanCode = makeString(dataView, 15, 3);\n  out.netCode = makeString(dataView, 18, 2);\n  out.startBTime = parseBTime(dataView, 20);\n  let headerByteSwap = checkByteSwap(out.startBTime);\n  if (headerByteSwap) {\n    out.startBTime = parseBTime(dataView, 20, headerByteSwap);\n  }\n  out.numSamples = dataView.getInt16(30, headerByteSwap);\n  out.sampRateFac = dataView.getInt16(32, headerByteSwap);\n  out.sampRateMul = dataView.getInt16(34, headerByteSwap);\n  out.activityFlags = dataView.getUint8(36);\n  out.ioClockFlags = dataView.getUint8(37);\n  out.dataQualityFlags = dataView.getUint8(38);\n  out.numBlockettes = dataView.getUint8(39);\n  out.timeCorrection = dataView.getInt32(40, headerByteSwap);\n  out.dataOffset = dataView.getUint16(44, headerByteSwap);\n  out.blocketteOffset = dataView.getUint16(46, headerByteSwap);\n  let offset = out.blocketteOffset;\n  out.blocketteList = [];\n  out.recordSize = 4096;\n  out.sampleRate = out.calcSampleRate();\n  out.startTime = out.startBTime.toMoment();\n  for (let i=0; i< out.numBlockettes; i++) {\n    let nextOffset = dataView.getUint16(offset+2, headerByteSwap);\n    if (nextOffset === 0) {\n      // last blockette\n      nextOffset = out.dataOffset;\n    }\n    if (nextOffset === 0) {\n      nextOffset = offset; // zero length, probably an error...\n    }\n    let blockette = parseBlockette(dataView, offset, nextOffset-offset, headerByteSwap);\n    out.blocketteList.push(blockette);\n    offset = nextOffset;\n    if (blockette instanceof Blockette1000) {\n      out.recordSize = 1 << blockette.dataRecordLengthByte;\n      out.encoding = blockette.encoding;\n      out.littleEndian = (blockette.wordOrder === 0);\n    } else if(blockette instanceof Blockette1001) {\n      out.startBTime.microsecond = blockette.microsecond;\n    } else if(blockette instanceof Blockette100) {\n      out.sampleRate = blockette.sampleRate;\n    }\n  }\n  out.endTime = out.timeOfSample(out.numSamples-1);\n  return out;\n}\n\n/**\n * parses a Blockette within the DataView.\n *\n * @param  dataView containing the data\n * @param  offset offset into the DataView to start\n * @param  length size in bytes of the Blockette\n * @param headerByteSwap true if byte swapping is needed\n * @returns Blockette instance\n */\nexport function parseBlockette(dataView: DataView, offset: number, length: number, headerByteSwap: boolean): Blockette {\n  const type = dataView.getUint16(offset, headerByteSwap);\n  const body = new DataView(dataView.buffer, dataView.byteOffset+offset, length);\n  if (type === 1000) {\n    const encoding = body.getUint8(4);\n    const wordOrder = body.getUint8(5);\n    const dataRecordLengthByte = body.getUint8(6);\n    return new Blockette1000(type, body, encoding, dataRecordLengthByte, wordOrder);\n  } else if (type === 1001) {\n    const timeQual = body.getUint8(4);\n    const microsecond = body.getUint8(5);\n    //const reserved = body.getUint8(6)\n    const frameCount = body.getUint8(7);\n    return new Blockette1001(type, body, timeQual, microsecond, frameCount);\n  } else if (type === 100) {\n    const sampleRate = body.getFloat32(4);\n    const flags = body.getUint8(8);\n    return new Blockette100(type, body, sampleRate, flags);\n  } else {\n    return new Blockette(type, body);\n  }\n}\n\n/**\n * Represents a SEED Data Record, with header, blockettes and data.\n *  */\nexport class DataRecord {\n  header: DataHeader;\n  data: DataView;\n\n  constructor(header: DataHeader, data: DataView) {\n    this.header = header;\n    this.data = data;\n  }\n  /**\n   * Decompresses the data , if the compression type is known.\n   *\n   * @returns decompressed data\n   */\n  decompress() {\n    return this.asEncodedDataSegment().decode();\n  }\n  asEncodedDataSegment() {\n    return new seedcodec.EncodedDataSegment(this.header.encoding, this.data, this.header.numSamples, this.header.littleEndian);\n  }\n\n  /**\n   * Concatenates the net, station, loc and channel codes,\n   * separated by the given seperator, or periods if not given.\n   *\n   * @param sep optional separater, defaults to .\n   * @returns string of codes\n   */\n  codes(sep?: string): string {\n    if ( ! isNonEmptyStringArg(sep)) { sep = '.';}\n    return this.header.netCode+sep+this.header.staCode+sep+this.header.locCode+sep+this.header.chanCode;\n  }\n}\n\n/**\n * Represents the header part of the DataRecord, including all the actual\n *  fixed header plus fields pulled from a blockette 1000 if present.\n */\nexport class DataHeader {\n  seq: string;\n  typeCode: number;\n  continuationCode: number;\n  staCode: string;\n  locCode: string;\n  chanCode: string;\n  netCode: string;\n  startBTime: BTime;\n  numSamples: number;\n  encoding: number;\n  littleEndian: boolean;\n  sampRateFac: number;\n  sampRateMul: number;\n  sampleRate: number;\n  activityFlags: number;\n  ioClockFlags: number;\n  dataQualityFlags: number;\n  numBlockettes: number;\n  timeCorrection: number;\n  dataOffset: number;\n  blocketteOffset: number;\n  recordSize: number;\n  blocketteList: Array<Blockette>;\n  startTime: moment;\n  endTime: moment;\n  constructor() {\n    this.seq = \"      \";\n    this.typeCode = 68; // D\n    this.continuationCode = 32; // space\n    this.staCode = '';\n    this.locCode = '';\n    this.chanCode = '';\n    this.netCode = '';\n    this.startBTime = new BTime(1900, 1, 0, 0, 0, 0);\n    this.numSamples = 0;\n    this.sampRateFac = 0;\n    this.sampRateMul = 0;\n    this.activityFlags = 0;\n    this.ioClockFlags = 0;\n    this.dataQualityFlags = 0;\n    this.numBlockettes = 0;\n    this.timeCorrection = 0;\n    this.dataOffset = 0;\n    this.blocketteOffset = 0;\n    this.blocketteList = [];\n    this.recordSize = 4096;\n    this.encoding = 0;\n    this.littleEndian = false;\n    this.sampleRate = 0;\n    this.startTime = this.startBTime.toMoment();\n    this.endTime = moment.utc(this.startTime);\n  }\n\n  toString() {\n    return this.netCode+\".\"+this.staCode+\".\"+this.locCode+\".\"+this.chanCode+\" \"+this.startTime.toISOString()+\" \"+this.encoding;\n  }\n\n  /**\n   * Calculates the sample rate in hertz from the sampRateFac and sampRateMul\n   * parameters. This.sampleRate value is set to this value at construction.\n   *\n   * @returns sample rate\n   */\n  calcSampleRate(): number {\n    let factor = this.sampRateFac;\n    let multiplier = this.sampRateMul;\n    let sampleRate = 10000.0; // default (impossible) value;\n    if((factor * multiplier) !== 0.0) { // in the case of log records\n        sampleRate = Math.pow(Math.abs(factor),\n                              (factor / Math.abs(factor)))\n                     * Math.pow(Math.abs(multiplier),\n                              (multiplier / Math.abs(multiplier)));\n    }\n    return sampleRate;\n  }\n\n  /**\n   * Calculates the time of the i-th sample in the record, zero based,\n   *  so timeOfSample(0) is the start and timeOfSample(this.numSamples-1) is end.\n   *\n   * @param i sample index\n   * @returns time at i-th sample as moment\n   */\n  timeOfSample(i: number): moment {\n    return moment.utc(this.startTime).add(i/this.sampleRate, 'second');\n  }\n}\n\nexport class Blockette {\n  type: number;\n  body: DataView;\n\n  constructor(type: number, body: DataView) {\n    this.type = type;\n    this.body = body;\n  }\n}\n\n\nexport class Blockette1000 extends Blockette {\n  encoding: number;\n  dataRecordLengthByte: number;\n  wordOrder: number;\n  constructor(type: number, body: DataView, encoding: number, dataRecordLengthByte: number, wordOrder: number) {\n    super(type, body);\n    if (type !== 1000) {throw new Error(\"Not a blockette1000: \"+this.type);}\n    this.encoding = encoding;\n    this.dataRecordLengthByte = dataRecordLengthByte;\n    this.wordOrder = wordOrder;\n  }\n}\n\nexport class Blockette1001 extends Blockette {\n  timeQual: number;\n  microsecond: number;\n  frameCount: number;\n  constructor(type: number, body: DataView, timeQual: number, microsecond: number, frameCount: number) {\n    super(type, body);\n    if (type !== 1001) {throw new Error(\"Not a blockette1001: \"+this.type);}\n    this.timeQual = timeQual;\n    this.microsecond = microsecond;\n    this.frameCount = frameCount;\n  }\n}\n\nexport class Blockette100 extends Blockette {\n  sampleRate: number;\n  flags: number;\n  constructor(type: number, body: DataView, sampleRate: number, flags: number) {\n    super(type, body);\n    if (type !== 100) {throw new Error(\"Not a blockette100: \"+this.type);}\n    this.sampleRate = sampleRate;\n    this.flags = flags;\n  }\n}\n\nfunction makeString(dataView: DataView, offset: number, length: number): string {\n  let out = \"\";\n  for (let i=offset; i<offset+length; i++) {\n    let charCode = dataView.getUint8(i);\n    if (charCode > 31) {\n      out += String.fromCharCode(charCode);\n    }\n  }\n  return out.trim();\n}\n\nexport function parseBTime(dataView: DataView, offset: number, byteSwap?: boolean): BTime {\n    if ( ! isDef(byteSwap) ) { byteSwap = false; }\n    let year = dataView.getInt16(offset, byteSwap);\n    let jday = dataView.getInt16(offset+2, byteSwap);\n    let hour = dataView.getInt8(offset+4);\n    let min = dataView.getInt8(offset+5);\n    let sec = dataView.getInt8(offset+6);\n    // byte 7 unused, alignment\n    let tenthMilli = dataView.getInt16(offset+8, byteSwap);\n    return new BTime(year, jday, hour, min, sec, tenthMilli);\n}\n\nexport class BTime {\n  year: number;\n  jday: number;\n  hour: number;\n  min: number;\n  sec: number;\n  tenthMilli: number;\n  microsecond: number; // -50 to 49, not part of BTime proper, but added in case of B1001\n  length: number;\n  constructor(year: number, jday: number, hour: number, min: number, sec: number, tenthMilli: number) {\n    this.length = 10;\n    this.year = year;\n    this.jday = jday;\n    this.hour = hour;\n    this.min = min;\n    this.sec = sec;\n    this.tenthMilli = tenthMilli;\n    this.microsecond = 0;\n  }\n  toString(): string {\n    return this.year+\"-\"+this.jday+\" \"+this.hour+\":\"+this.min+\":\"+this.sec+\".\"+this.tenthMilli.toFixed().padStart(4,'0')+\" \"+this.toMoment().toISOString();\n  }\n  /**\n   * Converts this BTime to a momentjs utc moment. Note momentjs's precision\n   * is limited to milliseconds.\n   *\n   * @returns         BTime as a moment\n   */\n  toMoment(): moment {\n    let m = new moment.utc([this.year, 0, 1, this.hour, this.min, this.sec, 0]);\n    m.add(Math.round(this.tenthMilli/10), 'ms');\n    m.dayOfYear(this.jday);\n    if (m.isValid()) {\n      return m;\n    } else {\n      throw new Error(`BTime.start is invalid moment: ${this.year} ${this.jday} ${this.hour} ${this.min} ${this.sec} ${this.tenthMilli}`);\n    }\n  }\n}\n\n/**\n * Sanity checks on a BTime to see if a record might be in the wrong byte order\n * and so need to be byte swapped before parsing. Checks year betwee 1960 and 2055.\n *\n * @param   bTime  time\n * @returns        true is byte order appears to be wrong, false if it seems ok\n */\nexport function checkByteSwap(bTime: BTime): boolean {\n  return bTime.year < 1960 || bTime.year > 2055;\n}\n\n/** Determines if two DataRecords are contiguous, ie if the second starts\n * after the end of the first and the start time of the second is within\n * 1.5 times the sample period of the end of the first.\n *\n * @param dr1 first data record\n * @param dr2 seconds data record\n * @returns true if contiguous\n */\nexport function areContiguous(dr1: DataRecord, dr2: DataRecord): boolean {\n    let h1 = dr1.header;\n    let h2 = dr2.header;\n    return h1.endTime.isBefore(h2.startTime)\n        && h1.endTime.valueOf() + 1000*1.5/h1.sampleRate > h2.startTime.valueOf();\n}\n\n/**\n * Concatentates a sequence of DataRecords into a single seismogram object.\n * Assumes that they are all contiguous and in order. Header values from the first\n * DataRecord are used.\n *\n * @param contig array of data records\n * @returns SeismogramSegment instance\n * */\nexport function createSeismogramSegment(contig: Array<DataRecord> | DataRecord): SeismogramSegment {\n  if ( ! Array.isArray(contig)) { contig = [ contig ];}\n  let contigData = contig.map(dr => dr.asEncodedDataSegment());\n  let out = new SeismogramSegment(contigData,\n                           contig[0].header.sampleRate,\n                           contig[0].header.startTime);\n  out.networkCode = contig[0].header.netCode;\n  out.stationCode = contig[0].header.staCode;\n  out.locationCode = contig[0].header.locCode;\n  out.channelCode = contig[0].header.chanCode;\n\n  return out;\n}\n\n\n/**\n * Merges data records into a Seismogram object, each of\n * which consists of SeismogramSegment objects\n * containing the data as EncodedDataSegment objects. DataRecords are\n * sorted by startTime.\n * This assumes all data records are from the same channel, byChannel\n * can be used first if multiple channels may be present.\n *\n * @param drList array of data records\n * @returns Seismogram instance\n */\nexport function merge(drList: Array<DataRecord>): Seismogram {\n  let out = [];\n  let currDR;\n  drList.sort(function(a,b) {\n      return a.header.startTime.diff(b.header.startTime);\n  });\n  let contig = [];\n  for (let i=0; i<drList.length; i++) {\n    currDR = drList[i];\n    if ( contig.length === 0 ) {\n      contig.push(currDR);\n    } else if (areContiguous(contig[contig.length-1], currDR)) {\n      contig.push(currDR);\n    } else {\n      //found a gap\n      out.push(createSeismogramSegment(contig));\n      contig = [ currDR ];\n    }\n  }\n  if (contig.length > 0) {\n      // last segment\n      out.push(createSeismogramSegment(contig));\n      contig = [];\n  }\n  return new Seismogram(out);\n}\n\n\n/**\n * Splits a list of data records by channel code, returning a Map\n * with each NSLC string mapped to an array of data records.\n *\n * @param drList array of data records\n * @returns map of arrays of data records keyed by channel\n * */\nexport function byChannel(drList: Array<DataRecord>): Map<string, Array<DataRecord>> {\n  let out: Map<string, Array<DataRecord>> = new Map();\n  let key;\n  for (let i=0; i<drList.length; i++) {\n    let currDR = drList[i];\n    key = currDR.codes();\n    let drArray = out.get(key);\n    if ( ! drArray) {\n      drArray = [currDR];\n      out.set(key, drArray);\n    } else {\n      drArray.push(currDR);\n    }\n  }\n  return out;\n}\n\n/**\n * splits the DataRecords by channel and creates a single\n * Seismogram for each channel.\n *\n * @param   drList DataRecords array\n * @returns         Array of Seismogram\n */\nexport function seismogramPerChannel(drList: Array<DataRecord> ): Array<Seismogram> {\n  let out = [];\n  let byChannelMap = byChannel(drList);\n  byChannelMap.forEach(segments => out.push(merge(segments)));\n  return out;\n}\n"],"names":["MINISEED_MIME","parseDataRecords","arrayBuffer","dataRecords","offset","byteLength","dataView","DataView","dr","parseSingleDataRecord","push","header","recordSize","parseSingleDataRecordHeader","data","buffer","byteOffset","dataOffset","DataRecord","Error","out","DataHeader","seq","makeString","typeCode","getUint8","continuationCode","staCode","locCode","chanCode","netCode","startBTime","parseBTime","headerByteSwap","checkByteSwap","numSamples","getInt16","sampRateFac","sampRateMul","activityFlags","ioClockFlags","dataQualityFlags","numBlockettes","timeCorrection","getInt32","getUint16","blocketteOffset","blocketteList","sampleRate","calcSampleRate","startTime","toMoment","i","nextOffset","blockette","parseBlockette","Blockette1000","dataRecordLengthByte","encoding","littleEndian","wordOrder","Blockette1001","microsecond","Blockette100","endTime","timeOfSample","length","type","body","timeQual","frameCount","getFloat32","flags","Blockette","constructor","decompress","asEncodedDataSegment","decode","seedcodec","codes","sep","isNonEmptyStringArg","BTime","moment","utc","toString","toISOString","factor","multiplier","Math","pow","abs","add","charCode","String","fromCharCode","trim","byteSwap","isDef","year","jday","hour","getInt8","min","sec","tenthMilli","toFixed","padStart","m","round","dayOfYear","isValid","bTime","areContiguous","dr1","dr2","h1","h2","isBefore","valueOf","createSeismogramSegment","contig","Array","isArray","contigData","map","SeismogramSegment","networkCode","stationCode","locationCode","channelCode","merge","drList","currDR","sort","a","b","diff","Seismogram","byChannel","Map","key","drArray","get","set","seismogramPerChannel","byChannelMap","forEach","segments"],"mappings":"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"}